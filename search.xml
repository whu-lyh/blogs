<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows-BoostUp</title>
      <link href="/blogs/2025/02/08/Windows-BoostUp/"/>
      <url>/blogs/2025/02/08/Windows-BoostUp/</url>
      
        <content type="html"><![CDATA[<h3 id="sublime中文乱码">Sublime中文乱码</h3><blockquote><p>自觉抵制涉猎台独相关的NotePad++，使用Sublime作为文本编辑器</p></blockquote><p>但是在显示中文的时候容易出现乱码，因此需要安装一个插件ConvertToUTF8</p><h4 id="解决步骤">解决步骤</h4><p>打开Sublime Text，按 <strong>ctrl+`</strong> 或者点击菜单栏<strong>View</strong>下的<strong>Show Console</strong>调出控制台终端界面</p><ul><li>== Sublime Text2 对于SublimeText2，输入粘贴以下代码到底部命令行，并回车</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import urllib2,os,hashlib; h = <span class="hljs-string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="hljs-string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="hljs-string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) <span class="hljs-keyword">if</span> not os.path.exists(ipp) <span class="hljs-keyword">else</span> None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( <span class="hljs-string">'http://packagecontrol.io/'</span> + pf.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'%20'</span>)).<span class="hljs-built_in">read</span>(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), <span class="hljs-string">'wb'</span> ).write(by) <span class="hljs-keyword">if</span> dh == h <span class="hljs-keyword">else</span> None; <span class="hljs-built_in">print</span>(<span class="hljs-string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h) <span class="hljs-keyword">if</span> dh != h <span class="hljs-keyword">else</span> <span class="hljs-string">'Please restart Sublime Text to finish installation'</span>)<br></code></pre></td></tr></table></figure><ul><li>== Sublime Text3 对于SublimeText3，输入粘贴以下代码到底部命令行，并回车</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import urllib.request,os,hashlib; h = <span class="hljs-string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="hljs-string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="hljs-string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="hljs-string">'http://packagecontrol.io/'</span> + pf.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'%20'</span>)).<span class="hljs-built_in">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class="hljs-built_in">print</span>(<span class="hljs-string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="hljs-keyword">if</span> dh != h <span class="hljs-keyword">else</span> open(os.path.join( ipp, pf), <span class="hljs-string">'wb'</span> ).write(by)<br></code></pre></td></tr></table></figure><p>等待一会儿之后<code>Ctrl+Shift+P</code> 打开PackageControl来安装插件，打开之后输入install，选择InstallPackage，然后选择<strong>ConvertToUTF8</strong>插件。</p><p><a href="https://www.cnblogs.com/1693977889zz/p/14089625.html">参考链接</a></p><h3 id="gpu压力测试工具">GPU压力测试工具</h3><p><a href="https://geeks3d.com/furmark/">FurMark2</a>提供界面，测试GPU在不同工号下是否有问题。</p><h3 id="内存压力测试工具">内存压力测试工具</h3><p><a href="https://www.mersenne.org/download/">Prime95</a>可通过计算一个Prime相关的数学问题来，验证内存和CPU是否有问题，但是不建议长时间的测试，一方面会过度损耗电脑，另一方面还比较耗电。。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鱼眼图像转等距投影图像</title>
      <link href="/blogs/2025/02/08/%E9%B1%BC%E7%9C%BC%E5%9B%BE%E5%83%8F%E8%BD%AC%E7%AD%89%E8%B7%9D%E6%8A%95%E5%BD%B1%E5%9B%BE%E5%83%8F/"/>
      <url>/blogs/2025/02/08/%E9%B1%BC%E7%9C%BC%E5%9B%BE%E5%83%8F%E8%BD%AC%E7%AD%89%E8%B7%9D%E6%8A%95%E5%BD%B1%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="目的">目的</h3><p>​ 单张图像的使用方法见下面的博客。</p><ul><li><p>鱼眼图像的说明见<a href="http://whu-lyh.github.io/blogs/2023/04/13/%E9%B1%BC%E7%9C%BC%E5%9B%BE%E5%83%8F/">这里</a>。</p></li><li><p>FFMPEG的使用说明见<a href="http://whu-lyh.github.io/blogs/2020/02/29/%E8%A7%86%E9%A2%91%E5%8A%A0%E9%80%9F%E5%B0%8F%E6%8A%80%E5%B7%A7/">这里</a>。</p></li></ul><a id="more"></a><h3 id="批处理">批处理</h3><ol type="1"><li>Fisheye image sequences to fisheye video.将单个鱼眼图像序列转成视频，注意图像的个数和视频的帧数保持一致。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ffmpeg.exe -f image2 -r 1 -i kitti360imagespath\image_03\data_rgb/000000000%d.png -vcodec libx265 -pix_fmt yuv420p -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy -y -r 1 ./fisheye_rgb_sequence_r.mp4<br>.\ffmpeg.exe -f image2 -r 1 -i kitti360imagespath\image_02\data_rgb/000000000%d.png -vcodec libx265 -pix_fmt yuv420p -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy -y -r 1 ./fisheye_rgb_sequence_l.mp4<br></code></pre></td></tr></table></figure><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=697967612&amp;bvid=BV1Mm4y117ST&amp;cid=1109999779&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" controls="controls" loop="loop"></iframe></div><ol start="2" type="1"><li>Join to single fisheye video to dual fisheye video.将两个视频拼接起来。就是两个视频水平放置。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ffmpeg.exe -i .\fisheye_rgb_sequence_l.mp4 -i .\fisheye_rgb_sequence_r.mp4 -filter_complex hstack -y ./dual_fisheye_image.mp4<br></code></pre></td></tr></table></figure><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=655461073&bvid=BV1ya4y1V7nh&cid=1110007562&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div><ol start="3" type="1"><li>Dual fisheye video to equirectangular video.将双鱼眼视频转换为等距投影视频。这里FOV187.8是微调的，为了得到一个比较好的转换结果。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ffmpeg.exe -y -i .\dual_fisheye_image.mp4 -vf v360=dfisheye:e:yaw=-90:ih_fov=187.8:iv_fov=185 -c:v libx265 -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy equirectangular_image_sequence.mp4<br></code></pre></td></tr></table></figure><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=910476358&bvid=BV17M4y187hN&cid=1110007603&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div><ol start="4" type="1"><li>Fisheye video to fisheye imagesequences将等距投影视频转换为图像，并按照原始鱼眼图像的命名方式命名。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ffmpeg.exe -i .\equirectangular_image_sequence.mp4 -r 1 -q:v 1 -start_number 0 ./%10d.png<br></code></pre></td></tr></table></figure><p>这里给一个KITTI-360数据集中鱼眼图像批量转换为等距投影图像的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>file_list=(<span class="hljs-string">"2013_05_28_drive_0000_sync"</span><br>            <span class="hljs-string">"2013_05_28_drive_0002_sync"</span> <br>        <span class="hljs-string">"2013_05_28_drive_0003_sync"</span><br>            <span class="hljs-string">"2013_05_28_drive_0004_sync"</span> <br>            <span class="hljs-string">"2013_05_28_drive_0005_sync"</span> <br>            <span class="hljs-string">"2013_05_28_drive_0006_sync"</span> <br>            <span class="hljs-string">"2013_05_28_drive_0007_sync"</span> <br>            <span class="hljs-string">"2013_05_28_drive_0009_sync"</span> <br>        <span class="hljs-string">"2013_05_28_drive_0010_sync"</span>)<br><br><span class="hljs-comment"># create the destiny dir</span><br>data_2d_pano=data_2d_pano<br>mkdir -p <span class="hljs-variable">$data_2d_pano</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$data_2d_pano</span><br><span class="hljs-keyword">for</span> sequence <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;file_list[@]&#125;</span>; <span class="hljs-keyword">do</span><br>    mkdir -p <span class="hljs-variable">$sequence</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$sequence</span><br>    mkdir -p pano<br>    <span class="hljs-built_in">cd</span> pano<br>    mkdir -p data_rgb<br>    <span class="hljs-built_in">cd</span> ../..<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">cd</span> ../data_2d_pano<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Current dir:"</span><br><span class="hljs-built_in">pwd</span> <br><br><span class="hljs-comment"># #ffmpeg operation</span><br><span class="hljs-keyword">for</span> sequence <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;file_list[@]&#125;</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># create the path and move into</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$sequence</span><br>    <span class="hljs-comment"># 1. fetch images and merge into videos</span><br>    ffmpeg -f image2 -r 1 -i ../../data_2d_raw/<span class="hljs-variable">$sequence</span>/image_03/data_rgb/%10d.png -vcodec libx265 -pix_fmt yuv420p -b:v 40000k -bufsize 5000k -preset fast -c:a copy -y -r 1 fisheye_rgb_sequence_r.mp4<br>    ffmpeg -f image2 -r 1 -i ../../data_2d_raw/<span class="hljs-variable">$sequence</span>/image_02/data_rgb/%10d.png -vcodec libx265 -pix_fmt yuv420p -b:v 40000k -bufsize 5000k -preset fast -c:a copy -y -r 1 fisheye_rgb_sequence_l.mp4<br>    <span class="hljs-comment"># 2. merge two videos into one video</span><br>    ffmpeg -i fisheye_rgb_sequence_l.mp4 -i fisheye_rgb_sequence_r.mp4 -filter_complex hstack -y dual_fisheye_image.mp4<br>    <span class="hljs-comment"># 3. transform to equirectangular video</span><br>    ffmpeg -y -i dual_fisheye_image.mp4 -vf v360=dfisheye:e:yaw=-90:ih_fov=187.8:iv_fov=185 -c:v libx265 -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy equirectangular_image_sequence.mp4<br>    <span class="hljs-comment"># 4. Equirectangular video to separate images</span><br>    ffmpeg -i equirectangular_image_sequence.mp4 -r 1 -q:v 1 -start_number 0 ./pano/data_rgb/%10d.png<br>    <span class="hljs-built_in">cd</span> ..<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>​这里面图像转视频默认图像的名字是按照数字排序的，而且序号是从0开始的，如果不想从0开始，就要在<code>-f image2</code>后面加<code>-start_number 4613</code>。就可以了。其他位置无效。</p><p>当然直接使用FFMPEG得到的等距投影图像中间存在明显的拼接缝，因为FFMPEG并没有经过blend操作。可以手动刺点的方式获取两张鱼眼图像上的同名点，来获得更好的拼接结果，但是比较麻烦，而且需要手动刺点，如果想得到比较好的等距投影图像，应该增加这个步骤。比如使用<a href="https://github.com/trek-view/Fusion2sphere">Fusion2sphere</a>的方式得到拼接较好的结果。</p><ul class="task-list"><li><label><input type="checkbox">时间比较紧，就先不测试了。</label></li></ul><h3 id="reference">Reference</h3><ul><li>https://www.trekview.org/blog/2022/using-ffmpeg-process-gopro-fusion-fisheye/(<strong>Recommanded</strong>:+1::+1::+1:)</li><li>https://github.com/raboof/dualfisheye2equirectangular</li><li>https://stackoverflow.com/questions/37796911/is-there-a-fisheye-or-dual-fisheye-to-equirectangular-filter-for-ffmpeg</li><li>https://github.com/trek-view/Fusion2sphere</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鱼眼图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算服务器使用记录</title>
      <link href="/blogs/2025/02/08/%E8%B6%85%E7%AE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/blogs/2025/02/08/%E8%B6%85%E7%AE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>​课题组提供的GPU实在是不够用，就想着用一下学校的超算，结合之前使用的广东超算中心的经验，这里简单列一下学校服务器的一些常用命令。</p><p>​ 武大超算使用 Slurm系统，统一管理所有计算资源、统一调度所有用户的计算任务，用户必须通过Slurm 系统来进行计算</p><a id="more"></a><h2 id="空间管理">空间管理</h2><ol type="1"><li>查看当前空间使用<code>/bin/myDiskQuota</code>,查看当前空间有多少剩余。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">name@swarm02 ~]$ /bin/myDiskQuota<br>     Dir    DiskUsed   DiskQuota    DiskFree       Files  FilesQuota<br>    home          0M       1024M       1024M          10       10000<br> project          0G        500G        500G           1      500000<br></code></pre></td></tr></table></figure><h2 id="数据上传">数据上传</h2><ol type="1"><li>直接用FileZilla上传就行。</li></ol><h2 id="作业提交">作业提交</h2><p>​ 需要编写一个sbatch的脚本文件，然后调用sbatchxxx.sbatch即可。sbatch脚本如下样例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">#SBATCH --partition=hpxg</span><br><span class="hljs-comment">#SBATCH --nodes=1</span><br><span class="hljs-comment">#SBATCH --ntasks-per-node=1</span><br><span class="hljs-comment">#SBATCH --time=06:00:00</span><br><br>module load anaconda/3.7<br><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$SLURM_SUBMIT_DIR</span><br><br>python mycode.py<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鱼眼图像投影模型及使用</title>
      <link href="/blogs/2025/02/08/%E9%B1%BC%E7%9C%BC%E5%9B%BE%E5%83%8F/"/>
      <url>/blogs/2025/02/08/%E9%B1%BC%E7%9C%BC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前序">前序</h3><p>​简单介绍一下目前的相机种类，主要是对相机镜头按照焦距及视角的大小，可分为标准镜头、广角镜头和鱼眼镜头。他们的一些特点如下：</p><ul><li><p>焦距：鱼眼镜头（小于等于16<span class="math inline">\(mm\)</span>）&lt;广角镜头&lt;普通标准镜头（50<span class="math inline">\(mm\)</span>）。</p></li><li><p>视场角：鱼眼镜头（接近或者大于180°，工程上大于140°的就算）&gt;广角镜头&gt;普通标准镜头。</p></li><li><p>畸变：鱼眼镜头&gt;广角镜头&gt;普通标准镜头。</p></li></ul><h2 id="普通单目相机">普通单目相机</h2><h3 id="简介">简介</h3><p>​一般常见的普通小孔成像相机的成像模型如下所示，小孔相机模型采用相似成像的方式（入射角和出射角等大），内参包括焦距<span class="math inline">\(f_x,f_y\)</span>和主点偏差<span class="math inline">\(c_x,c_y\)</span>。如果焦距一定，那么图像传感器像素平面的面积直接决定了相机视场角的大小，超过这个视场角范围的物体不会被镜头获取到。因此基于透镜成像原理的相机，视场角无法做到足够大，水平视场角一般小于140°。在某些时候，比如气象科学空间观测、太阳能辐射研究计算天空视角系数、安防视频监控等实际场景中可能会需要更大视场角的相机，那么这时候广角相机-鱼眼相机就出现了。</p><div data-align="center"><img src="/blogs/.io//pinhole_perspective_camera.png" width="0.05%" height="0.05%"></div><div data-align="center">透视成像的小孔成像相机模型，图源于<a href="https://mp.weixin.qq.com/s/CE9PHZ1IDbA7YA_FmiKRYw">这里</a></div><h3 id="投影模型">投影模型</h3><p><span class="math display">\[r_d=f \cdot tan \theta\]</span></p><a id="more"></a><h3 id="投影和反投影过程">投影和反投影过程</h3><p>​<strong>不考虑图像畸变的情况下</strong>，透视（小孔）成像的相机投影过程（3D-&gt;2D）如下，<span class="math inline">\(u,v\)</span>为<strong>图像像素坐标</strong>，<span class="math inline">\(X,Y,Z\)</span>为相机坐标系下的坐标。 <span class="math display">\[\begin{align}\label{pinhole_projection}u &amp;= \frac{f_x X}{Z}+c_x \\v &amp;= \frac{f_y Y}{Z}+c_y\end{align}\]</span> ​ 其对应相机反投影过程（2D-&gt;3D）如下，<span class="math inline">\(\bar{X},\bar{Y}\)</span>为归一化坐标（即相机坐标系下的坐标变换到归一化相机坐标系）。<span class="math display">\[\begin{align}\label{pinhole_inverse_projection}\bar{X} &amp;= \frac{u-c_x}{f_x} \\\bar{Y} &amp;= \frac{v-c_y}{f_y}\end{align}\]</span></p><h2 id="广角相机">广角相机</h2><p>​ 为了获得更大视角，出现了广角相机。根据==DavideScaramuzza==大神写的“OmnidirectionalCamera”一文，有三种镜头聚光方式：第一种通过透镜折射实现；第二种通过使用标准相机加一个面镜实现；第三种通过多个相机<strong>共心</strong>组装而成（测绘中常见这种，拼接出全景图像）。如下图所示：</p><div data-align="center"><img src="/blogs/.io//omnidirectional_camera_paper_fig_1.png" width="0.05%" height="0.05%"></div><p>​传统广角相机的镜头一般由多个镜头组成，如下图所示为几种镜头的结构方式及其参数：</p><div data-align="center"><img src="/blogs/.io//Nature_Electron_wide_angle_carema.png" width="0.05%" height="0.05%"></div><div data-align="center">广角镜头示意图，图源于An aquatic-vision-inspired camera based on amonocentric lens and a silicon nanorod photodiode array</div><h2 id="鱼眼相机">鱼眼相机</h2><h3 id="简介-1">简介</h3><p>​广角相机的视场角也没有超过180°，人们为了获得更大的视场角，根据<strong>斯内尔（Snell'slaw）现象</strong>发明了鱼眼相机，又因为其镜头和鱼眼非常接近，因此取名鱼眼相机。鱼眼相机拥有更大的球面弧度（<strong>超广角</strong>），成像平面离透镜更近（<strong>短焦距</strong>）。为了获得更加的视场角，鱼眼相机只能牺牲一部分精度，引入一些畸变（主要是径向畸变）的同时压缩边缘。</p><p>​ 鱼眼镜头属于一种特殊的超广角镜头。</p><p>​鱼眼镜头采用<strong>非相似成像</strong>（入射角比出射角大）。其镜头组成如下图所示：</p><div data-align="center"><img src="/blogs/.io//fisheye_lenses.png" style="zoom:100%;"></div><div data-align="center">鱼眼相机的镜头组成，图源于<a href="https://mp.weixin.qq.com/s/TffJXlFjGwOKC1kIFs3sjQ">这里</a></div><p>​鱼眼相机的成像方式可以看成是<strong>先将3d点投影到单位球面</strong>，单位球上的点在以偏离<span class="math inline">\(z\)</span>轴<span class="math inline">\(\xi(或f)\)</span>处通过针孔模型进行投影，这样水平入射的光线也能投影到图像的像素区域内。其成像模型如下所示。单位半球面上的点<span class="math inline">\(q\)</span>投影到相机成像平面上的点<span class="math inline">\(r_d\)</span>的过程是一个非线性过程，此时折射角<span class="math inline">\(\theta_d\)</span>小于入射角<span class="math inline">\(\theta\)</span>。成像模型也称投影模型。投影模型要表征的就是成像平面的像高<span class="math inline">\(r_d\)</span>和入射角<span class="math inline">\(\theta\)</span>之间的映射关系。</p><div data-align="center"><img src="/blogs/.io//fisheye_carema_projection_model.png" style="zoom:100%;"></div><div data-align="center">鱼眼相机的成像模型，图源于<a href="https://mp.weixin.qq.com/s/CE9PHZ1IDbA7YA_FmiKRYw">这里</a></div><p>​ 鱼眼相机根据不同的投影方式可以分为以下几种：<span class="math inline">\(\theta\)</span>为入射光线与鱼眼相机光轴之间的夹角（入射角），<span class="math inline">\(f\)</span>为焦距，<span class="math inline">\(r_d\)</span>为像点至畸变中心的距离。</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr><th style="text-align: center;">等距投影</th><th style="text-align: center;">等立体角投影</th><th style="text-align: center;">体视投影</th><th style="text-align: center;">正交投影</th></tr></thead><tbody><tr><td style="text-align: center;"><img src="/blogs/.io//fisheye_carema_projection_model_1.png"></td><td style="text-align: center;"><img src="/blogs/.io//fisheye_carema_projection_model_2.png"></td><td style="text-align: center;"><img src="/blogs/.io//fisheye_carema_projection_model_3.png"></td><td style="text-align: center;"><img src="/blogs/.io//fisheye_carema_projection_model_4.png"></td></tr><tr><td style="text-align: center;">畸变量适中，最常用</td><td style="text-align: center;">相等立体角的入射面会产生相等面积的像</td><td style="text-align: center;">保角不变投影</td><td style="text-align: center;">畸变最大，但不会产生透射导致的近大远小</td></tr><tr><td style="text-align: center;"><span class="math inline">\(r_d=f \cdot\theta\)</span></td><td style="text-align: center;"><span class="math inline">\(r_d=2 \cdotf \cdot sin(\theta/2)\)</span></td><td style="text-align: center;"><span class="math inline">\(r_d=2 \cdotf \cdot tan(\theta/2)\)</span></td><td style="text-align: center;"><span class="math inline">\(r_d=f \cdotsin(\theta)\)</span></td></tr></tbody></table><div data-align="center">鱼眼相机的成像模型分类，图源于<a href="https://mp.weixin.qq.com/s/CE9PHZ1IDbA7YA_FmiKRYw">这里</a></div><h3 id="通用相机模型">通用相机模型</h3><p>​鱼眼相机是由多个镜头组成的，上面的投影方式还是过于简单了，理论计算出来的结果和实际差很多，因此出现了一些对鱼眼相机进行建模的方案。常见的有Kannala-Brandt模型、Mei模型、Scaramuzza模型、PolyFisheye模型等。</p><h4 id="kannala-brandt-模型">Kannala-Brandt 模型</h4><p>​ Kannala-Brandt 模型发表于TPAMI2006的“A Generic Camera Model andCalibration Method for Conventional, Wide-Angle, and Fish-EyeLenses”，作者将普通小孔成像、广角、超广角、鱼眼相机模型统一起来。同时统一了畸变的建模方式。通过将不同投影模型的函数，如<span class="math inline">\(\sin,\tan\)</span>进行泰勒展开，发现遵循一个相似的多项式方程，因此Kannala-Brandt模型采用了多项式来近似畸变。原始论文中给出了径向畸变、切向畸变等模型，但是实际中发现只选取多项式的前几项即可得到不错的精度，因此后续的代码库中均存在不同程度的简化和近似。如<a href="https://github.com/hengli/camodocal">camodocal</a>和<a href="https://docs.opencv.org/4.x/db/d58/group__calib3d__fisheye.html">OpenCV</a>中均采用了8参数模型(固定<span class="math inline">\(k_0=1\)</span>，<span class="math inline">\(k_1,k_2,k_3,k_4,f_x,f_y,c_x,c_y\)</span>)，如下为OpenCV中实现的通用相机去畸变模型，由于只是兼容鱼眼相机，因此其中充满小孔成像的影子。<span class="math display">\[\begin{align}世界坐标系X\rightarrow相机坐标系X_c &amp;:\left[\begin{array}{c} X_c \\Y_c \\ Z_c \end{array} \right] = RX+t \\归一化相机坐标系p_c &amp;: x_c = \frac{X_c}{Z_c},\ y_c=\frac{Y_c}{Z_c}\\&amp; \theta = arctan(r),r^2 = x^2_c + y^2_c\\畸变模型 &amp;: \theta _d =\theta(k_0+k_1\theta^2+k_2\theta^4+k_3\theta^6+k_4\theta^8)\\去畸变之后的点p_{u} :&amp; x_d=\frac{\theta_d}{r}x_c, \y_d=\frac{\theta_d}{r}y_c\\归一化相机坐标系\rightarrow 像素坐标系 &amp;:u=f_xx_d+c_x, \v=f_yy_d+c_y\end{align}\]</span></p><p>​ but there still are some paper use the following model, and i don'tknow why... <span class="math display">\[\begin{align}r_d &amp; = f \theta_{distorted} \\k_0\theta + k_1 \theta^3 + k_2 \theta^5 + k_3 \theta^7 + k_4 \theta^9\end{align}\]</span></p><p>​ KB模型需要5个参数就能实现畸变校正，<span class="math inline">\(k_0,k_1,k_2,k_3,k_4\)</span>。但KB模型仍遵循针孔成像的基本假设，导致该模型存在奇点（水平入射的光线将被投影到无穷远），因此Mei模型就出现了。</p><ul><li>In practice, most systems will characterize Kannala-Brandtdistortions purely in terms of the <strong>symmetric radialdistortion</strong>, as that distortion is significantly larger inmagnitude and will be the leading kind of distortion in wider-anglelenses.</li></ul><h4 id="scaramuzza模型">Scaramuzza模型</h4><p>​ Scaramuzza大神在IROS 2006的文章“A Toolbox for Easy CalibratingOmnidirectional Cameras”中提出的的鱼眼相机模型。</p><h4 id="mei模型">Mei模型</h4><p>​ Mei模型是在ICRA2007中的“Single View Point Omnidirectional CameraCalibration from PlanarGrids”一文中专门针对鱼眼相机提出的模型，也称为Unified CameraModel（或者unified omnidirectional cameramodel），同时被VINS-Fusion、VINS-Mono、鱼眼DSO采用，KITTI360数据集中提供的鱼眼相机也采用了这种模型。这种通用的相机模型可以模拟小孔成像的相机模型，也可以模拟鱼眼相机的成像模型。当<span class="math inline">\(\xi\)</span>=0时，鱼眼相机模型就退化为了小孔相机模型。优点（源于<a href="https://mp.weixin.qq.com/s/aMJnwTvI87YrBKkmMaGQbQ">这里</a>）是它能精确的模拟各种图像设备和畸变的几何图像生成过程，（2）它的反投影是一个闭式解。</p><div data-align="center"><img src="/blogs/.io//Mei_model.jpg" width="0.05%" height="0.05%"></div><p>​ 鱼眼相机的投影过程为<span class="math inline">\(\pi_c:\mathbb{R}^3\rightarrow \Omega\)</span>：</p><p>0.将世界坐标系下的点转到相机坐标系下，需要<span class="math inline">\(R,T\)</span>;</p><p>1.设原点为<span class="math inline">\(C_m\)</span>的相机坐标系中的一个三维点为<span class="math inline">\(\mathcal{X}(X,Y,Z)\)</span>，先将其坐标归一化，即将其坐标缩放到单位球面上，得到<span class="math inline">\(\mathcal{X_s}=\frac{\mathcal{X}}{|\mathcal{X}|}=(X_s,Y_s,Z_s)^{T}\)</span>，<span class="math inline">\(|\mathcal{X}|=\sqrt{X^2+Y^2+Z^2}\)</span>;</p><p>2.随后改变坐标系，设现在坐标系为<span class="math inline">\(C_p\)</span>， <span class="math inline">\(C_p\)</span>相对于坐标系<span class="math inline">\(C_m\)</span>在<span class="math inline">\(z\)</span>轴方向上有一个负方向的平移<span class="math inline">\(\xi\)</span>，相当于形成一个虚拟的光心（坐标系原点），这样导致<span class="math inline">\(\mathcal{X_s}\)</span>在新坐标系中的坐标为<span class="math inline">\((X_s,Y_s,Z_s+\xi)^{T}\)</span>；</p><p>3.随后将新的<span class="math inline">\(\mathcal{X_s}\)</span>投影到归一化平面上，得到三维点<span class="math inline">\(\mathbf{m}_u(x,y,1)\)</span>: <span class="math display">\[\begin{align}\label{fisheye_normalized_point}\mathbf{m}_u=(\frac{X_s}{Z_s+\xi},\frac{Y_s}{Z_s+\xi},1)^{T}=(\frac{X}{Z+\xi|\mathcal{X}|},\frac{Y}{Z+\xi |\mathcal{X}|},1)^T=h(\mathcal{X_s})\end{align}\]</span>4.引入径向畸变和切向畸变参数（这里采用一般的标准相机、广角相机畸变模型<strong>Brownand Conrady模型</strong>，也可以是其他畸变校正模型）后，得到去畸变之后的点坐标<span class="math inline">\(\mathbf{m}_d(x_{distorted},y_{distorted},1)\)</span>：<span class="math display">\[\begin{align}x_{distorted} &amp;=x+k_1\rho^2+k_2\rho^4+k_3\rho^6+2p_1xy+p_2(\rho^2+2x^2) \\y_{distorted} &amp;=y+k_1\rho^2+k_2\rho^4+k_3\rho^6+p_1(\rho^2+2y^2)+2p_2xy \\\mathbf{m}_d &amp;=\mathbf{m}_u+D(\mathbf{m}_u,V),\rho=\sqrt{x^2+y^2},V=(k_1,k_2,k_3,p_1,p_2)\end{align}\]</span> 5.最后将去畸变之后的归一化平面坐标系中的坐标<span class="math inline">\(\mathbf{m}_d\)</span>用一个类似于针孔相机的内参的<span class="math inline">\(K\)</span>矩阵投影到像素平面上。即最终的像素点<span class="math inline">\(\mathbf{p}(u,v)\)</span>: <span class="math display">\[\begin{align}\mathbf{p}=K\mathbf{m}_d=\left[ \begin{array}{ccc} f_x &amp; \alpha&amp; u_0 \\ 0 &amp; f_y &amp; v_0 \\ 0 &amp; 0 &amp; 1 \end{array}\right]\end{align}\]</span> ​ Mei模型下的鱼眼图像在标定时只需要知道<span class="math inline">\(\xi\)</span>，内参矩阵<span class="math inline">\(K\)</span>（其中<span class="math inline">\(\alpha\)</span>为坐标轴倾斜参数，理想情况为0）以及图像畸变参数<span class="math inline">\(k_1,k_2,p_1,p_2\)</span>。但也正因为相比于针孔相机模型，仅仅多了一个参数<span class="math inline">\(\xi\)</span>，因此一些图像边缘处高畸变的像素的矫正并不是很准。</p><h5 id="投影和反投影过程-1">投影和反投影过程</h5><p>​<strong>不考虑图像畸变的情况下</strong>。Mei模型的<strong>投影过程（3D-&gt;2D）</strong>如下：<span class="math display">\[\begin{align}\label{uocm_projection}\left[ \begin{array}{c}u \\ v \end{array} \right] &amp;=\left[ \begin{array}{c}f_x\frac{X}{\xi d+Z}+c_x \\ f_y\frac{Y}{\xid+Z}+c_y \end{array} \right] \\d &amp;= \sqrt{X^2+Y^2+Z^2}\end{align}\]</span></p><p>​<strong>反投影过程（2D-&gt;3D）</strong>：(提供额外深度信息时才能得到实际的三维坐标，否则只能得到归一化平面上的点的三维点坐标)<span class="math display">\[\begin{align}\label{uocm_inverse_projection2}\left[ \begin{array}{c}\tilde{u} \\ \tilde{v} \end{array} \right] &amp;=\left[ \begin{array}{c}\frac{(u-c_x)}{f_x} \\ \frac{v-c_y}{f_y}\end{array} \right]\\\pi_u^{-1}(u)&amp;=\frac{\xi+\sqrt{1+(1-\xi^2)(\tilde{u}^2+\tilde{v}^2)}}{\tilde{u}^2+\tilde{v}^2+1}\left[\begin{array}{c}\tilde{u} \\ \tilde{v} \\1\end{array} \right]-\left[\begin{array}{c}0 \\ 0 \\ \xi \end{array} \right]\end{align}\]</span></p><p>​ 根据上述<span class="math inline">\(\ref{fisheye_normalized_point}\)</span>中的<span class="math inline">\(\mathbf{m}_u(x,y,1)\)</span>，对于<span class="math inline">\(x,y\)</span>轴，只需要计算一个<span class="math inline">\(\lambda= \frac{Z+\xi|\mathcal{X}|}{|\mathcal{X}|}\)</span>结合内参矩阵<span class="math inline">\(K\)</span>即可实现从像素坐标系坐标<span class="math inline">\(\mathbf{p}(u,v)\)</span>到归一化平面系坐标<span class="math inline">\(\mathbf{m}_u(x,y,1)\)</span>向归一化球面系坐标<span class="math inline">\(\mathcal{X_s}\)</span>的转换；对于<span class="math inline">\(z\)</span>轴，则差了一个<span class="math inline">\(\frac{Z}{|\mathcal{X}|}=\lambda-\xi\)</span>，因此核心在于找到<span class="math inline">\(\lambda\)</span>到底应该是多少。转换过程：<span class="math inline">\(\mathbf{m}_u \rightarrow \mathcal{X}_{C_p}\rightarrow \mathcal{X}_{C_m}\)</span>，推导过程如下： <span class="math display">\[\begin{align}\label{fisheye_2d_to_3d}\mathbf{m}_u &amp;= (x,y,1)^T = K^{-1}\mathbf{p} \\multiply: \quad \lambda &amp;  \Downarrow\\\mathcal{X}_{C_p} &amp;=(\frac{X}{|\mathcal{X}|},\frac{Y}{|\mathcal{X}|},\frac{Z}{|\mathcal{X}|}+\xi)^{T}\\minus: \quad \xi &amp; \Downarrow \\\mathcal{X}_{C_m} &amp;=\frac{\mathcal{X}}{|\mathcal{X}|}=(\frac{X}{|\mathcal{X}|},\frac{Y}{|\mathcal{X}|},\frac{Z}{|\mathcal{X}|})^{T}\end{align}\]</span> ​ <span class="math inline">\(\lambda\)</span>的计算方法如下：<span class="math display">\[\begin{align}\label{lambda}\lambda &amp;= \frac{Z+\xi |\mathcal{X}|}{|\mathcal{X}|} \\&amp;= \frac{1}{\sqrt{(\frac{X}{Z+\xi |\mathcal{X}|})^2+(\frac{Y}{Z+\xi|\mathcal{X}|})^2+(\frac{Z}{Z+\xi |\mathcal{X}|})^2}} \\&amp;= \frac{1}{\sqrt{(\frac{X}{Z+\xi |\mathcal{X}|})^2+(\frac{Y}{Z+\xi|\mathcal{X}|})^2+(\frac{Z+\xi |\mathcal{X}|-\xi |\mathcal{X}|}{Z+\xi|\mathcal{X}|})^2}} \\\label{lambda_3}&amp;= \frac{1}{\sqrt{(\frac{X}{Z+\xi |\mathcal{X}|})^2+(\frac{Y}{Z+\xi|\mathcal{X}|})^2+(1-\frac{\xi}{\lambda})^2}} \\&amp;= \frac{1}{\sqrt{x^2+y^2+(1-\frac{\xi}{\lambda})^2}} \\\end{align}\]</span> ​ 将上式转成二元一次方程求解<span class="math inline">\(\lambda\)</span>的解析解如下： <span class="math display">\[\begin{align}(x^2+y^2)\lambda^2+(\lambda-\xi)^2 &amp;= 1 \\\Downarrow &amp; \\(1+x^2+y^2)\lambda^2-2\xi \lambda+(-1+\xi^2) &amp;= 0 \\\Downarrow &amp; \\\lambda &amp;= \frac{\xi+\sqrt{\xi^2+(1+x^2+y^2)(1-\xi^2)}}{(1+x^2+y^2)}\\&amp;= \frac{\xi+\sqrt{1+(x^2+y^2)(1-\xi^2)}}{(1+x^2+y^2)}\end{align}\]</span> ​<strong>2D-&gt;3D的射线变换</strong>为：从图像上任意像素为起点，方向朝向空间中的点，此射线上的所有点的归一化平面坐标均为<span class="math inline">\(\mathbf{m}_u(x,y,1)\)</span>，按照<span class="math inline">\(\ref{fisheye_2d_to_3d}\)</span>中将归一化平面坐标系下的坐标变换到归一化球面坐标系下坐标有<span class="math inline">\(\ref{fisheye_3d_to_2d}\)</span>的假设。 <span class="math display">\[\begin{align}\label{fisheye_3d_to_2d}(\lambda x, \lambda y,\lambda - \xi)^T \backsimeq (x,y,m)^T\end{align}\]</span> ​ 结合<span class="math inline">\(\ref{fisheye_normalized_point}\)</span>和<span class="math inline">\(\ref{lambda_3}\)</span>可以得出<span class="math inline">\(m=1-\xi/\lambda=1-\xi\frac{(1+x^2+y^2)}{\xi+\sqrt{\xi^2+(1+x^2+y^2)(1-\xi^2)}}\)</span>，即：<span class="math display">\[\begin{align}\label{fisheye_3d_to_2d2}(x,y, 1-\xi \frac{(1+x^2+y^2)}{\xi+\sqrt{\xi^2+(1+x^2+y^2)(1-\xi^2)}})^T\end{align}\]</span></p><h4 id="polyfisheye模型">PolyFisheye模型</h4><p>​ PolyFisheye模型是在IROS2017中的Dual-Fisheye OmnidirectionalStereo中提出的。</p><div data-align="center"><img src="/blogs/.io//polyfisheye.png" width="0.05%" height="0.05%"></div><p>​ 从模型图上看基本和Mei模型一模一样，唯一的不同是，假设空间点<span class="math inline">\(\mathcal{P}^c\)</span>最终投影得到的像素点为<span class="math inline">\(u\)</span>，他们认为<span class="math inline">\(u\)</span>到光心<span class="math inline">\(O_i\)</span>的距离<span class="math inline">\(\mathcal{R}\)</span>并不是直接等于沿着<span class="math inline">\(\theta_r\)</span>方向上投影过来的大小，而是和<span class="math inline">\(O^{cl}\)</span>到<span class="math inline">\(u\)</span>的距离存在一个关于<span class="math inline">\(\theta\)</span>的七次多项式的多项式倍数关系。这样就相比Mei模型多了七个参数来刻画鱼眼相机，自然就更准了。<span class="math display">\[\begin{align}\mathcal{R}(\theta)=[1+\mathcal{D}(\theta)]\mathcal{R}_{ref}(\theta)=f\Sigma_{i=0}^N \eta_i \theta^i\end{align}\]</span> ​ 鱼眼相机的投影模型分为三步：1）<span class="math inline">\(\mathcal{P}^c \rightarrow\bar{\mathcal{P}^c}\)</span>相机坐标系中的点转换到单位球面上；2）<span class="math inline">\(\bar{\mathcal{P}}^c \rightarrow\overrightarrow{O^{cl}\mathbf{u}}\)</span>单位球面上的点进行光线的折射变换;3）<span class="math inline">\(\overrightarrow{O^{cl}\mathbf{u}} \rightarrow\mathbf{u}\)</span>将光线投影到像平面空间。其中<span class="math inline">\(\mathcal{R}(\theta)=\overrightarrow{O_i\mathbf{u}}\)</span>就是实际入射光线折射之后投影到相平面坐标系的长度，存在畸变，而<span class="math inline">\(\mathcal{R}_{ref}\)</span>就是无畸变的投影向量，具体如下：</p><p>1.将相机坐标系中的点归一化到单位球面<span class="math inline">\(\bar{\mathcal{P}}^c=-\mathcal{P}^c/||\mathcal{P}^c||=[\bar{x}^c,\bar{y}^c,\bar{z}^c]^T\)</span>;</p><p>2.将单位球面上的点转换到球面坐标系<span class="math inline">\(\cos(\theta)=\bar{z}^c,\tan(\varphi)=\bar{y}^c/\bar{x}^c\)</span>，<span class="math inline">\(\bar{x}^c=0\)</span>时<span class="math inline">\(\varphi=0\)</span>；</p><p>3.根据<span class="math inline">\(\theta\)</span>构建与成像系统无关的镜头光学模型<span class="math inline">\(\mathcal{R}_0(\theta)=\Sigma_{i=0}^N \eta_i\theta^i\)</span>;</p><p>4.通过焦距<span class="math inline">\(f\)</span>将光线投影到像素坐标系<span class="math inline">\(\mathbf{u}=f\mathcal{R}_0(\theta)\left[\begin{array}{c} \cos(\varphi) \\ \sin(\varphi) \end{array} \right] +\left[\begin{array}{c} c_x \\ c_y \end{array} \right]\)</span>；</p><p>5.综上所示，将焦距<span class="math inline">\(f\)</span>表示成矩阵形式<span class="math inline">\(A_f\)</span>,则投影过程为： <span class="math display">\[\begin{align}\label{polyfiseye}\mathbf{u}=\Sigma_{i} \eta_i \theta^i A_f \left[ \begin{array}{c}\cos(\varphi) \\ \sin(\varphi) \end{array} \right] +\left[\begin{array}{c} c_x \\ c_y \end{array} \right]，A_f=\left[\begin{array}{cc} A_{11} &amp; A_{12} \\ 0 &amp; A_{22} \end{array}\right]\end{align}\]</span></p><ul><li>同样由于现代工艺的提升，镜头的切向畸变已经很小了，相比于径向畸变，可以忽略不计。出自TPAMI2013的文章“Calibrationof ultrawide fisheye lens cameras by eigenvalue minimization”。</li></ul><h4 id="相关实现">相关实现</h4><p>​ 主要依赖HKUST航空机器人所开源的一系列代码实现。真强</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr><th style="text-align: center;">Kannala-Brandt</th><th style="text-align: center;">Scaramuzza模型</th><th style="text-align: center;">Mei模型</th><th style="text-align: center;">PolyFisheye模型</th></tr></thead><tbody><tr><td style="text-align: center;">Lionel Heng博士的<a href="https://github.com/hengli/camodocal">CamOdoCal</a></td><td style="text-align: center;">高文良博士的<a href="https://github.com/gaowenliang/camera_model">camera_model</a></td><td style="text-align: center;">Lionel Heng博士的<a href="https://github.com/hengli/camodocal">CamOdoCal</a></td><td style="text-align: center;">高文良博士的<a href="https://github.com/gaowenliang/camera_model">camera_model</a></td></tr><tr><td style="text-align: center;"><a href="https://docs.opencv.org/4.x/db/d58/group__calib3d__fisheye.html">OpenCV</a></td><td style="text-align: center;"><a href="https://ww2.mathworks.cn/help/vision/ug/fisheye-calibration-basics.html#References">MATLAB鱼眼图像标定</a></td><td style="text-align: center;"><a href="https://github.com/ethz-asl/kalibr/wiki/Supported-models">Kalibr</a></td><td style="text-align: center;">EpsAvlc的<a href="https://github.com/EpsAvlc/EpsAvlc_toys/blob/master/fisheye_to_pinhole/src/fisheye_to_pinhole.cpp">小项目</a></td></tr><tr><td style="text-align: center;"><a href="https://github.com/ethz-asl/kalibr/wiki/Supported-models">Kalibr</a></td><td style="text-align: center;">yangzhenfei的<a href="https://github.com/dvorak0/camera_model">carema_model</a></td><td style="text-align: center;"><a href="https://docs.opencv.org/4.x/dd/d12/tutorial_omnidir_calib_main.html">OpenCV</a><code>cv::omnidir::calibrate</code></td><td style="text-align: center;">HKUST的xuhao开源的<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Fisheye">Vins-fisheye</a>,许久未更新</td></tr><tr><td style="text-align: center;">yangzhenfei的<a href="https://github.com/dvorak0/camera_model">carema_model</a></td><td style="text-align: center;"><a href="https://github.com/urbste/MultiCol-SLAM">MultiCol-SLAM</a></td><td style="text-align: center;">yangzhenfei的<a href="https://github.com/dvorak0/camera_model">carema_model</a></td><td style="text-align: center;"><a href="https://github.com/xuhao1/VINS-Fisheye">项目，还在维护</a></td></tr></tbody></table><ul><li>高文良博士的camera_model是在LionelHeng博士的CamOdoCal基础以及yangzhenfei的carema_model优化的基础上改进的。</li><li>VINS-Fusion、VINS-Mono、VINS-Fisheye、GVINS等项目都是基于yangzhenfei的carema_model改进的。</li><li>VINS-Mono中提供了Mei模型，针孔相机模型，Scaramuzza模型和KB模型。其中的<code>CataCamera</code>就是Mei相机模型。</li><li>相比VINS-Mono，VINS-Fusion中的相机模型种类多了一种<code>PinholeFullCamera</code>模型。</li><li>高文良博士的camera_model更是多了<code>PolyFisheyeCarema</code>和<code>SplineCamera</code>。因此，如果只用相机模型，选择这个是最佳的。如果想用SLAM系统则选择其他repo。</li><li>而GVINS中还是使用了VINS-Mono中的相机模型种类。</li><li>OpenCV、Kalibr中关于Mei模型的实现也是基于LionelHeng博士的CamOdoCal基础上完成的。</li></ul><h3 id="鱼眼图像转换">鱼眼图像转换</h3><h4 id="鱼眼图像转普通框幅式图像">鱼眼图像转普通（框幅式）图像</h4><p>​一般的V-SLAM或者基于视觉的场景感知任务中使用的都是普通的单目相机，因此需要进行畸变矫正转成框幅式图像。</p><div data-align="center"><img src="/blogs/.io//fisheye2pinhole.png"></div><div data-align="center">鱼眼图像转框幅式图像，图源于<a href="https://epsavlc.github.io/2019/10/21/fisheye_calib.html#fn:1">这里</a></div><p>​转成框幅式图像，首先需要虚拟一个框幅式（小孔成像）相机的内参，然后通过归一化平面作为桥梁，构建鱼眼图像每个像素与框幅式图像每个像素之间的关系。步骤：</p><p>1.先确定虚拟相机的内参（<span class="math inline">\(f_x,f_y,c_x,c_y\)</span>）与相对于鱼眼相机的外参。</p><p>2.对于虚拟相机的每个像素点<span class="math inline">\(p_{pinhole}\)</span>，将像素点反投影到归一化平面，得到三维点<span class="math inline">\(\mathcal{X}_{s}\)</span>（z=1）。</p><p>3.将三维点根据鱼眼相机模型，投影到鱼眼相机上，得到鱼眼相机上的像素点<span class="math inline">\(p_{fisheye}\)</span>。</p><p>4.将鱼眼图像的对应位置像素赋给框幅式图像。</p><h5 id="细节补充">细节补充</h5><ul><li>虚拟相机的视场角是由虚拟相机内参(<span class="math inline">\(f_x,f_y\)</span>)控制的，<span class="math inline">\(f_x=width/2\)</span>时视场角刚好为90°。<span class="math inline">\(width\)</span>为图像的像素宽度。</li><li>映射关系可以先算出来做成Lookuptable，然后处理鱼眼图像时再直接查表即可。</li></ul><h4 id="全景图像转鱼眼图像">全景图像转鱼眼图像</h4><p>​与全景图像转成框幅式图像的原理类似。就是找到鱼眼图像上每个像素与全景图像上的对应映射关系即可，<a href="https://mp.weixin.qq.com/s/ygI6BC1JXcSP7QAwKa_Vqg">可见</a>。这里简单列一下要点：</p><p>1.以下图的全景图像为例，将其转换为右侧的鱼眼图像，鱼眼相机的中心指向天空，那么全景图像的底边宽<span class="math inline">\(W_c\)</span>对应了鱼眼相机圆形视角的周长，而顶边则压缩为了一个中心点，鱼眼图像的半径<span class="math inline">\(r_0\neq H_c\)</span>；</p><div data-align="center"><img src="/blogs/.io//panorama2fisheye_1.jpg"></div><p>2.因此鱼眼图像的半径只能通过全景图像的底边<span class="math inline">\(W_c\)</span>来计算，鱼眼图像的中心位置<span class="math inline">\(C_x,C_y\)</span>就知道了；</p><div data-align="center"><img src="/blogs/.io//panorama2fisheye_2.jpg"></div><p>3.全景与鱼眼图像像素映射关系是从鱼眼图像的坐标开始，找到每一个像素<span class="math inline">\(x_f,y_f\)</span>与全景图像上对应像素之间的关系<span class="math inline">\(x_c,y_c\)</span>，为了不产生空洞，因此是遍历鱼眼图像像素开始，找到对应的全景图像像素，赋值颜色即可。映射关系中有一个<span class="math inline">\(\theta\)</span>需要根据所处的鱼眼图像坐标象限来判断才能展开到<span class="math inline">\(2\pi\)</span>空间。</p><div data-align="center"><img src="/blogs/.io//panorama2fisheye_3.jpg"></div><h5 id="细节补充-1">细节补充</h5><p>​试验了一下发现部分全景图像转换的结果不是很好。尤其是第二章的鱼眼图像边缘不平滑。全景图像本身有问题的话，转出来的鱼眼图像也不好。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th style="text-align: center;">全景图像</th><th style="text-align: center;">鱼眼图像</th></tr></thead><tbody><tr><td style="text-align: center;"><img src="/blogs/.io//panorama2fisheye_src.jpg"></td><td style="text-align: center;"><img src="/blogs/.io//panorama2fisheye_tgt.jpg"></td></tr><tr><td style="text-align: center;"><img src="/blogs/.io//panorama2fisheye_src2.jpg"></td><td style="text-align: center;"><img src="/blogs/.io//panorama2fisheye_tgt2.jpg"></td></tr></tbody></table><h5 id="其他">其他</h5><ul><li><label><input type="checkbox">https://stackoverflow.com/questions/56901894/c-algorithm-to-convert-a-fisheye-image-to-an-equirectangular-image-with-opencv?rq=1</label></li><li>[ ]</li></ul><h2 id="可视化工具">可视化工具</h2><ul><li><a href="https://renderstuff.com/tools/360-panorama-web-viewer/">web端展示</a>，导入全景图像，输出可以360展示的VR视角图像。</li></ul><h2 id="相近名词解释">相近名词解释</h2><p><a href="https://en.wikipedia.org/wiki/Omnidirectional_(360-degree)_camera">omnidirectionalcamera</a>：在一个水平面有360度视野的相机，或视野能覆盖半个球或近似整个球的相机；</p><p>Panoramic camera：全景相机</p><p>spherical camera：球面相机</p><p>catadioptriccamera：结合了透镜和面镜的相机。广角相机的第二种类型。</p><p>fisheye camera：鱼眼相机</p><p>wide-angle camera：广角相机</p><h2 id="全景相机品牌">全景相机品牌</h2><p>GoPro Max、Insta360 （One X2，X3，RS 1-inch，RS Twin）、Ricoh Theta（X，Z1）、Trisio Lite2、Kandao QooCam 8K 360。</p><h2 id="参考资料">参考资料</h2><ul><li>https://mp.weixin.qq.com/s/0U4_jj1wrggVGY_1uvQXmw</li><li>https://mp.weixin.qq.com/s/aMJnwTvI87YrBKkmMaGQbQ（其中鱼眼相机2D到3D的变换公式存在错误）</li><li>https://mp.weixin.qq.com/s/TffJXlFjGwOKC1kIFs3sjQ</li><li>https://mp.weixin.qq.com/s/GwZ_NaG8u4q2odIS6sORAw</li><li>https://mp.weixin.qq.com/s/fo3CaWwtAvb6oUR3qt87Tw</li><li>https://mp.weixin.qq.com/s/zPvvAWFxWJxom6TJW7diIw</li><li>https://mp.weixin.qq.com/s/efiANlLdrcig6aDCrmeC4w</li><li>https://mp.weixin.qq.com/s/ygI6BC1JXcSP7QAwKa_Vqg</li><li>https://zhuanlan.zhihu.com/p/317673040</li><li>https://epsavlc.github.io/2019/10/21/fisheye_calib.html</li><li>https://jiangren.work/2019/09/13/%E9%B1%BC%E7%9C%BC%E9%95%9C%E5%A4%B4%E6%A8%A1%E5%9E%8B/</li><li>Mei的主页：https://www.robots.ox.ac.uk/~cmei/Toolbox.html</li><li>Omnidirectional DSO: Direct Sparse Odometry With FisheyeCameras</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鱼眼图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ALS数据采集成果制作要求</title>
      <link href="/blogs/2025/02/08/%E6%8E%A7%E5%88%B6%E7%82%B9%E6%A3%80%E6%A0%B8-ALS%E9%87%87%E9%9B%86%E7%B2%BE%E5%BA%A6%E8%A6%81%E6%B1%82/"/>
      <url>/blogs/2025/02/08/%E6%8E%A7%E5%88%B6%E7%82%B9%E6%A3%80%E6%A0%B8-ALS%E9%87%87%E9%9B%86%E7%B2%BE%E5%BA%A6%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li>根据规范：http://www.nrsis.org.cn/mnr_kfs/file/read/75d2c98b7b855b1b508b280ac53187ac机载点云数据高程中误差在不同比例尺上精度要求是不同的。</li></ul><p>最大允许中误差为中误差的2倍。</p><a id="more"></a><table><thead><tr><th>比例尺</th><th>地形类别</th><th>数字高程模型成果高程中误差</th><th>点云数据高程中误差</th></tr></thead><tbody><tr><td>1:500</td><td>平地</td><td>0.2</td><td>0.15</td></tr><tr><td></td><td>丘陵地</td><td>0.4</td><td>0.25</td></tr><tr><td></td><td>山地</td><td>0.5</td><td>0.35</td></tr><tr><td></td><td>高山地</td><td>0.7</td><td>0.50</td></tr><tr><td>1:1000</td><td>平地</td><td>0.2</td><td>0.15</td></tr><tr><td></td><td>丘陵地</td><td>0.5</td><td>0.35</td></tr><tr><td></td><td>山地</td><td>0.7</td><td>0.5</td></tr><tr><td></td><td>高山地</td><td>1.5</td><td>1.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 专业应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于控制点检核的一些思考</title>
      <link href="/blogs/2025/02/08/%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E7%82%B9%E6%A3%80%E6%A0%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/blogs/2025/02/08/%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E7%82%B9%E6%A3%80%E6%A0%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="使用地面控制点检核als点云精度">使用地面控制点检核ALS点云精度</h1><h2 id="任务描述">任务描述</h2><p>​使用地面布设的外业控制点GCP来检核ALS点云条带平差之后的绝对位置精度。如下图所示，红圈中的是GCP点，紫色和灰色是两个条带的ALS点云。图中显示了在<span class="math inline">\(z\)</span>方向上的偏差。</p><div data-align="center"><img src="/blogs/.io//practical_pos.png" width="100%" height="100%"></div><p>​通过观察，有一部分控制点是在平面区域采集的，有一些是在边缘比较锋利的区域采集的。</p><h2 id="目前存在的问题">目前存在的问题</h2><p>​本身ALS点云就比较稀疏，再加上GCP也是离散的布设的，导致很难找到对应同名关系，想要找到对应位置的值就只能通过内插来实现。</p><p>​内插方法有很多，但是直接在ALS里面内插不是很现实，可以考虑转成<strong>格网</strong>，mesh的形式，然后基于新的数据表达方式再内插。例如可以用arcgis生成DTM，DEM，内插到高分辨率，然后再采样点和GCP做计算。</p><h2 id="解决方案">解决方案</h2><p>最终论证，通过地面控制点应该是无法做到水平精度检核的，只能做到高程方向的检核。</p><a id="more"></a><h2 id="相关方法">相关方法</h2><h3 id="a-quantitative-assessment-of-lidar-data-accuracy1">AQuantitative Assessment of LIDAR DataAccuracy<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><p>​ 文章里面的高程和平面精度是分开计算的。</p><ul><li><p>对于高程精度首先只能选择平面上的控制点。GCP是有规律线性分布的方式布设的，因此作者就选择1m范围内的点作为领域点，然后拟合平面，计算高程方向上的偏差。</p></li><li><p>对于平面精度</p><p>由于对应关系不好确定，采用两个曲线先平移后相交的方式确定对应关系。首先找到地面控制点一定半径内的点作为候选对应同名点，然后绘制曲线，通过在东(北)方向以0.01<span class="math inline">\(m\)</span>平移曲线，找到和GCP最吻合的位置（好像是逐位置计算误差，找到误差最小的就以对应时刻的步长作为偏移量），就说明找到了ALS和GCP之间的同名关系。曲线绘制方式是，在东(北)方向和高程方向构成的平面中分别投影GCP和ALS点云，消除高度偏差之后，就可以得到两条大致重叠的曲线。</p></li><li><p>问题：</p><p>依然确实存在平面点不对应的问题，导致精度计算出现问题。</p><p>此外，要求GCP是线性分布的，不然没法计算曲线。对检核点的布设要求很高。</p></li></ul><h3 id="accuracy-of-ground-surface-interpolation-from-airborne-laser-scanning-als-data-in-dense-forest-cover2">Accuracyof ground surface interpolation from airborne laser scanning (ALS) datain dense forestcover<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><h4 id="简介">简介</h4><p>​DTM的精度取决于激光系统测量值的精度和准确度、点云滤波的精度（因为需要滤除地面点才能做DTM），以及需要内插来解决空洞问题。其中内插精度为影响DTM精度第二主要因素，因此文章主要是想在森林密集的区域，通过比较生成的DTM的精度来进一步验证9种内插方式的精度。涉及到的内插方式有：==反距离加权、最近邻、自然内插、Delauney三角网、多层-B-Spline、三次样条、Thin-PlateSpline、Thin-Plate Spline byTIN、克里金插值法==。对比方法为使用cross-validation的方式，将预测值与真值GT做差，计算偏差和RMSE。</p><table><colgroup><col style="width: 22%"><col style="width: 38%"><col style="width: 38%"></colgroup><thead><tr><th style="text-align: center;">方法</th><th style="text-align: center;">简介</th><th>方法实现</th></tr></thead><tbody><tr><td style="text-align: center;">IDW:反距离权重</td><td style="text-align: center;">距离越近的点，值越相近</td><td>ArcGIS</td></tr><tr><td style="text-align: center;">NeN:最近邻域</td><td style="text-align: center;">首先构建Thiessen多边形，直接将处于多边形内的点全部都赋予参考点的值</td><td><a href="https://github.com/OSGeo/gdal/blob/4c0b804f135650c1f432f9ee338fb5a167d31370/frmts/mbtiles/mbtilesdataset.cpp#L3128">GDAL</a></td></tr><tr><td style="text-align: center;">NN:自然邻域<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></td><td style="text-align: center;">首先构建Thiessen多边形，根据上采样点的位置更新多边形，用多边形的中心，后续每个点的插入进来更新多边形，动态变化</td><td></td></tr><tr><td style="text-align: center;">Delauney Triangulation:狄罗妮三角化</td><td style="text-align: center;">构建TIN，得益于三角网的构建，将落在三角网内的点，用线性内插或者是多项式内插的方式来采样值，base点是三角网的格网点</td><td>ArcGIS</td></tr><tr><td style="text-align: center;">MBA:多尺度-B-Spline<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></td><td style="text-align: center;">构建层级的B-Spline</td><td><a href="https://github.com/SINTEF-Geometry/MBA" title="Original and old version of C++ Implementation">SINTEF</a>,<a href="https://github.com/ddemidov/mba" title="With C++11 header-only and Python API">ddemidov</a></td></tr><tr><td style="text-align: center;">CubicSpline:三次样条<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></td><td style="text-align: center;">基于三次Spline函数实现表面近似</td><td>GDAL,[SAGA][]</td></tr><tr><td style="text-align: center;">Thin-PlateSpline<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></td><td style="text-align: center;">基于三次Spline的2D泛化形式</td><td><a href="https://github.com/OSGeo/gdal/blob/a632e3093d6dd34cdcf979a5b2a20529fe2df943/alg/thinplatespline.h">GDAL</a></td></tr><tr><td style="text-align: center;">Thin-Plate Spline by TIN</td><td style="text-align: center;">在TIN构建的三角网内构建TPS，实现内插</td><td>[SAGA][]</td></tr><tr><td style="text-align: center;">Kriging:克里金</td><td style="text-align: center;">构建semi-variogram，然后计算一些地理相关的参数，实现空间相关的内插</td><td>ArcGIS</td></tr></tbody></table><h4 id="结论"><strong>结论</strong></h4><p>​内插方法的精度和想要生成的DTM的分辨率有关，DTM分辨率越低，内插精度越差，但是不同内插方法之间的RMSE在点云密度、熵密度、地面坡度等因素下变化不明显。<strong>NN</strong>和<strong>Spline</strong>类的方法总体精度相近，但是NN的方法不需要额外的输入，而且效率要比样条线的高一些。其中：</p><ul><li><p>反距离权重的精度最低。同时NeN、克里金插值方法受到点密度和陡峭坡度地形影响大，精度会降低。</p></li><li><p>样条线类的方法得到的表面更加平滑，也接近真值，不同函数之间的RMSE均比较小，适用于崎岖的地形=坡度大、陡峭的地方。不同的样条基函数之间没有明显差异。反倒是越复杂计算时间越长。</p></li><li><p>只有克里金插值方法受熵密度的影响大，其他方法由于测试数据的问题，并不能得出很充分的相关关系。</p></li><li><p>NN，DT，Spline-based方法受到地面点密度、地面坡度变化的影响小。</p></li></ul><h3 id="scattered-data-interpolation-with-multilevel-b-splines4">Scattereddata interpolation with multilevelB-splines<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h3><h4 id="motivation">Motivation</h4><p>​ 目的是从离散点云中实现点云表面拟合B-spline approximation(<strong>BA</strong>)。现有方法也有用B-spline的，但是依然受限于平滑性，时间复杂性，限定范围内的数据分布等的限制。因此本文提出使用层级的bicubicB-spline修正方法来逼近直接拟合B-spline，并且实现了最小的内存占用。本文是从Imagemorphing中借鉴过来的。</p><h4 id="basic-idea">Basic Idea</h4><p>​ Let <span class="math inline">\(\Phi_{ij}\)</span> be the value ofthe <span class="math inline">\(ij\)</span>-th control point on lattice<span class="math inline">\(\Phi \in \Omega ^{(m+3) \times (n+3)},\Omega = \{ (x,y)| 0 \leq x &lt;m, 0 \leq y &lt; n \}\)</span>, locatedat <span class="math inline">\((i,j)\)</span> for $ i =-1,0,...,m+1$ and<span class="math inline">\(j =-1,0,...,m+1\)</span>. The==approximation function== <span class="math inline">\(f\)</span> isdefined in terms of these control points by: <span class="math display">\[f(x,y)=\Sigma_{k=0}^3\Sigma_{l=0}^3B_k(s)B_l(t)\sigma_{(i+k)(j+1)}\]</span> where <span class="math inline">\((x,y)\)</span> is ascattered point in <span class="math inline">\(\Omega\)</span>, <span class="math inline">\(i=\lfloor x \rfloor -1,i=\lfloor y \rfloor-1,s=x-\lfloor x \rfloor\)</span>, and <span class="math inline">\(t=y-\lfloor y \rfloor,t \in [0,1)\)</span>. <span class="math inline">\(B_k,B_l\)</span>是均匀三次B-spline函数. 即 <span class="math inline">\(f: \Omega \mapsto\mathbb{R}\)</span>表明了函数<span class="math inline">\(f\)</span>将平面domain的点映射为一个表面。</p><p>With this formulation, the problem of deriving function <span class="math inline">\(f\)</span> is reduced to solving for the controlpoints in <span class="math inline">\(\Phi\)</span> that bestapproximate the scattered data in <span class="math inline">\(P=\{(x_c,y_c,z_c)\}\)</span>.</p><h4 id="methodology">Methodology</h4><p>​本文通过多层B-spline来实现表面近似任务中平滑性和准确性之间的平衡。使用控制顶点的层级性得到一系列的函数，通过求和实现近似。coarse的顶点提供粗略的近似，使用finer的顶点构成的函数来优化精度。</p><p>​那么使用B-spline来做数据拟合最终调整的是什么呢？根据B-pline的定义和<a href="http://whu-lyh.github.io.com/2023/01/30/Spline/">另一篇博客</a>可知。近似的目的就是要不断调整样条曲线中控制点的权值，使得能够最大限度的拟合所给的离散数据。理解这个很重要。控制点的位置是固定分布在domain的，也就是随着knot的。表面拟合的结果和控制点的分辨率是有关系的。</p><ul><li><p>分辨率越低，越能覆盖到更多的数据点，大量的数据点会得到比较平滑的拟合结果。</p></li><li><p>分别率越低，因为指用到了局部的信息进行拟合，因此局部拟合的更好，但是全局来看不同区域之间的过渡不是也很好，有很多零的区域。</p></li></ul><p>​ 作者提出首先在<span class="math inline">\(\Omega\)</span>域内构建层级的控制点<span class="math inline">\(\Phi_0,\Phi_1,...,\Phi_h\)</span>。相邻层间控制点数量比为1:2，首先在coarest的控制点<span class="math inline">\(\Phi_0\)</span>上运行一次BA算法作为初始平滑近似<span class="math inline">\(f_0\)</span>。这样会在一些散点上有较大的偏差，例如在点<span class="math inline">\(P_1\{(x_1,y_1,z_1)\}\)</span>上存在较大的偏差<span class="math inline">\(\Delta^1z_c\)</span>(上标1表示是第一次近似得到的偏差)，用<span class="math inline">\(\Delta^1 z_c\)</span>替换<span class="math inline">\(z_1\)</span>，变成<span class="math inline">\(P_1\{(x_1,y_1,\Delta^1z_c)\}\)</span>。依次类推，用<span class="math inline">\(f_0+f_1\)</span>可以得到一个更小的偏差<span class="math inline">\(\Delta^2z_c=Z_c-f_0(x_c,y_c)-f_1(x_c,y_c)\)</span>。那么从coarest的<span class="math inline">\(\Phi_0\)</span>开始直到finer的控制点<span class="math inline">\(\Phi_h\)</span>，最终的近似结果可以表示为<span class="math inline">\(f=\Sigma_{k=0}^hf_k\)</span>，即一系列层级近似结果的叠加。只需要在全部的点上做一次分辨率低的近似就可以得到全局的形状。按照上述方案，就实现渐进式的平滑近似。时间复杂度是<span class="math inline">\(\mathcal{O}=hp+\frac{4}{3}mn\)</span>，空间复杂度是<span class="math inline">\(\mathcal{O}=p+\frac{4}{3}mn\)</span>，并且仍然可以实现<span class="math inline">\(C^2\)</span>的平滑性。<span class="math inline">\(mn\)</span>是domain的范围，是正整数。<span class="math inline">\(p\)</span>是3D点。</p><p>​由上可知，需要不断的计算B-Spline函数，导致计算效率下降，作者因此提出一种局部B-Spline精化方法实现计算效率的提升。此外作者还根据数据分布提出一种自适应的分层方法。这里就先略了。重点关注前面。</p><h4 id="相关实现">相关实现</h4><ul><li><a href="https://github.com/SINTEF-Geometry/MBA" title="Original and old version of C++ Implementation">SINTEF</a>，实现了文献<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>中的多尺度样条曲线表面拟合，但是代码比较老了，需要额外编译，除了代码框架复杂一些，编译不是问题。</li><li><a href="https://github.com/ddemidov/mba" title="With C++11 header-only and Python API">ddemidov</a>:基于C++11做了一个文献<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>新的版本，实现了adaptive的MBA，开发了python的API，并且是header-only的方式，方便使用。根据官方提供的jupyternotebook的测试显示，两个库对于相同数据的内插结果之间并没有很大的误差。</li></ul><h3 id="smooth-approximation-and-rendering-of-large-scattered-data-sets5">SmoothApproximation and Rendering of Large Scattered DataSets<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></h3><h4 id="motivation-1">Motivation</h4><p>​表面拟合任务要求：近似程度要高、可视质量要好、适用于大数据量、高效、数值计算稳定、自适应性好以及算法简单易实现等。基于spline的方法有很多，e.g.NURBS要求数据分布均匀，存在依赖矩形的分布空间，近似误差大等问题。其他spline的方法，依赖三角网，而且对数据分布要求较高，还需要全局最小二乘近似等。RelatedWork写的不错。</p><h4 id="methodology-1">Methodology</h4><p>​本文提出一种两阶段方法实现表面美观、属性好的表面拟合方法。<strong>Step1</strong>：仅使用==局部==少量的数据点计算离散的最小二乘多边形段discreteleast squares polynomial pieces，基于==SVD==构建了<span class="math inline">\(Bernstein-B \&#39;{e}zier\)</span>形式以根据实际点云分布空间初始多边形的次数。<strong>Step2</strong>：基于<span class="math inline">\(C^1\)</span>连续条件结合相邻的三角化<span class="math inline">\(Bezier\)</span>块直接得到剩余多边形段。算法不需要全局计算，不依赖三角网，不需要计算导数。</p><p>​ 基于<span class="math inline">\(C^1\)</span>连续的bivariate<strong>cubic</strong><strong>spline</strong>实现了大场景下散点的最优近似拟合。使用局部多边形最小二乘近似的方式来减少数据的局部差异和非均匀分布的问题。但是考虑到实际数据分布，算法使用的cubicspline的次数是自适应变化的。算法的复杂度是和点数成线性关系的。这里去掉了从数据生成三角网的过程，而算法在介绍的时候<em>依赖三角网</em>的生成。中间使用了LOD加速计算。</p><p>​ 最后使用了<span class="math inline">\(Bernstein-B \&#39;{e}zier\)</span>来评估和渲染spline。通过计算spline点和散点之间的单向<span class="math inline">\(Housdorff\)</span>距离来评估质量。</p><h4 id="结论-1">结论</h4><ul><li>点云越密，构建的多边形阶数越高。拟合误差最大为<span class="math inline">\(m\)</span>级。</li><li>在一块a Vpro/8 graphics board可以做到10FPS。</li></ul><h4 id="相关实现-1">相关实现</h4><ul><li>[SAGA][]：SAGA - System for Automated Geoscientific Analyses - is aGeographic Information System (GIS) software with immense capabilitiesfor geodata processing and analysis. SAGA is programmed in the objectoriented C++ language and supports the implementation of new functionswith a very effective Application Programming Interface (API). Functionsare organised as <strong>modules in framework independent ModuleLibraries</strong> and can be accessed via SAGA’s Graphical UserInterface (GUI) or various scripting environments (shell scripts,Python, R, ...).提供了编译好的可执行程序和源代码。针对内插方法，SAGA已经实现了<strong>B-splineApproximation、Cubic Spline Approximation、MultilevelB-Spline、Multilevel B-Spline (3D)、Multilevel B-Spline forCategories、Multilevel B-Spline form Grid Points、Thin PlateSpline、Thin Plate Spline (TIN)</strong>。包含了文章[^4]中提到的大部分算法。每种内插方法配有注释。简单测试之后发现确实和文章中提到的结论一致，起码效率方面表现相同。</li></ul><h3 id="approximate-thin-plate-spline-mappings6">Approximate thin platesplinemappings<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></h3><p>​ Thin plate spline是一种常见的使用基函数实现从<span class="math inline">\(\mathbb{R}^2\)</span>到<span class="math inline">\(\mathbb{R}^2\)</span>坐标映射的方法。本身TPS是cubicspline的2D泛化形式，TPS模型包含一个仿射模型作为一个特例。TPS模型需要对一个超大的密集矩阵<span class="math inline">\(p \times p\)</span>进行求逆，<span class="math inline">\(p\)</span>是点数。为了减少求逆的运算量，提出了很多的改进方法，包括使用局部对应点集来估计全部对应关系的方法，本文结合高斯径向基网络领域中的相关方法来讨论基于这个思路的近似方法的优缺点。指出借鉴径向基函数的方法不满足principalwarp分析<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>的要求，因此借助经典矩阵补全技术进行完善。最后，作者讨论了一种使用全部近似基函数来近似目标集数据的方法，即<span class="math inline">\(Nystor\ddot{o}m\)</span>近似法实现TPS映射。最后作者并总结了三种近似方法之间的优缺点：基于局部点采样并考虑全部目标集的方法的效果都不错，基于<span class="math inline">\(Nystor\ddot{o}m\)</span>近似的方法不但可以实现principalwarp分析，同时在子集采样结果不好时表现出最优的性能。并用实验突出了在图像编辑方面的优势。</p><ul><li>数学有点啃不动。详见文章6和8。</li></ul><h3 id="lr-b-spline">LR B-Spline</h3><p>​最新版书籍<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>中全面细致的总结了不同地形表面表达方式之间的区别，并肯定了localrefine B-Spline表达形式（其实是一类方法）的好处。</p><table style="width:100%;"><colgroup><col style="width: 7%"><col style="width: 23%"><col style="width: 23%"><col style="width: 22%"><col style="width: 23%"></colgroup><thead><tr><th>Surface type</th><th>Representation and data structure</th><th>Algorithm and control of accuracy</th><th>Surface smoothness</th><th>Restricting data volume</th></tr></thead><tbody><tr><td>Raster</td><td>Values on regular mesh</td><td>Spatial interpolation to define sample values. Accuracy checkedafter creation</td><td>Depends on interpolation method for evaluation between mesh</td><td>Pre-set mesh resolution defining data volume</td></tr><tr><td>B-spline surface</td><td>Piecewise polynomials on regular mesh, any bidegree</td><td>Coefficients calculated by local/global approximation. Accuracychecked after surface creation</td><td>Depends on polynomial bidegree and knot multiplicity</td><td>Pre-set mesh resolution defining data volume</td></tr><tr><td>TIN</td><td>Triangulation</td><td>Triangulate point cloud + thinning or adaptive triangulation.Accuracy can be checked during creation</td><td>Piecewise linear</td><td>Pre-set approximation tolerance and/or max allowed data volume</td></tr><tr><td>LR B-spline surface</td><td>Piecewise polynomials on LR axis-parallel mesh, any bidegree</td><td>Coefficients calculated by local/global approximation. Localadaption by checking accuracy during construction and refinement whereneeded.</td><td>Depends on polynomial bidegree and knot multiplicity</td><td>Pre-set approximation tolerance or restrictions in adaptivealgorithm</td></tr></tbody></table><h4 id="相关实现-2">相关实现</h4><p><a href="https://github.com/SINTEF-Geometry/MBA" title="Original and old version of C++ Implementation">SINTEF</a>下属的应用数学研究所开发的<a href="https://github.com/SINTEF-Geometry/GoTools">GoTools</a>，The coremodule contains generic tools and spline functionality. The additionalmodules contain functionality for intersections, approximativeimplicitization, parametrization, topology, and more. 包含NURBS和TIN模板库。</p><h2 id="references">References</h2>[SAGA]: https://sourceforge.net/projects/saga-gis/"Conrad,O.,Bechtel,B.,Bock,M.,Dietrich,H.,Fischer,E.,Gerlitz,L.,Wehberg,J.,Wichmann,V.,andBoehner,J.(2015):SystemforAutomatedGeoscientificAnalyses(SAGA)v.2.1.4.Geosci.ModelDev.,8,1991-2007,doi:10.5194/gmd-8-1991-2015."<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">Elaksher A, Ali T, Alharthy A. A Quantitative Assessment of LIDAR DataAccuracy[J]. Remote Sensing, 2023, 15(2):442.<a href="#fnref:1" rev="footnote"> ↩︎</a></li><li id="fn:2">Cățeanu M, Ciubotaru A. Accuracy of ground surface interpolation fromairborne laser scanning (ALS) data in dense forest cover[J]. ISPRSInternational Journal of Geo-Information, 2020, 9(4):224.<a href="#fnref:2" rev="footnote"> ↩︎</a></li><li id="fn:3">A brief description of natural neighbourinterpolation<a href="#fnref:3" rev="footnote"> ↩︎</a></li><li id="fn:4">Lee S, Wolberg G, Shin S Y. Scattered data interpolation with multilevelB-splines[J]. IEEE transactions on visualization and computer graphics,1997, 3(3): 228-244.<a href="#fnref:4" rev="footnote"> ↩︎</a></li><li id="fn:5">Haber J, Zeilfelder F, Davydov O, et al. Smooth approximation andrendering of large scattered data sets[C]//Proceedings Visualization,2001. VIS'01. IEEE, 2001: 341-571.<a href="#fnref:5" rev="footnote">↩︎</a></li><li id="fn:6">Donato G, Belongie S. Approximate thin plate splinemappings[C]//Computer Vision—ECCV 2002: 7th European Conference onComputer Vision Copenhagen, Denmark, May 28–31, 2002 Proceedings, PartIII 7. Springer Berlin Heidelberg, 2002:21-31.<a href="#fnref:6" rev="footnote"> ↩︎</a></li><li id="fn:7">Bookstein F L. Principal warps: Thin-plate splines and the decompositionof deformations[J]. IEEE Transactions on pattern analysis and machineintelligence, 1989, 11(6): 567-585.<a href="#fnref:7" rev="footnote">↩︎</a></li><li id="fn:8">Kermarrec G, Skytt V, Dokken T. Optimal Surface Fitting of Point CloudsUsing Local Refinement: Application to GIS Data[M]. Springer Nature,2023.<a href="#fnref:8" rev="footnote"> ↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 专业应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
            <tag> B-Spline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kinematic mapping trajectory estimation</title>
      <link href="/blogs/2025/02/08/TrajectoryEstimation/"/>
      <url>/blogs/2025/02/08/TrajectoryEstimation/</url>
      
        <content type="html"><![CDATA[<h2 id="integrated-trajectory-estimation-for-3d-kinematic-mapping-with-gnss-ins-and-imaging-sensors-a-framework-and-review1">Integratedtrajectory estimation for 3D kinematic mapping with GNSS, INS andimaging sensors: A framework andreview<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="方法分类">方法分类</h3><ol type="1"><li>多步方法。</li></ol><p>​ 流程：首先用Kalman filtering将GNSS和IMU融合到一起，如果轨迹足够准确，可以直接获得3D点云。也可以在后面加一个平差步骤，结合影像传感器的观测实现融合传感器定向，目的是：1）改正轨迹；2）传感器定向和标定；3）获取3D模型数据，e.g.点云。</p><p>​ 需要有一些假设：通常假设轨迹误差是由于缓慢变化的 GNSS误差或未补偿的惯性传感器漂移造成的，因此是低频的，而轨迹的较高频率分量相对准确。实际上，校正要么与飞行几何相关联，作为每条带的固定偏移，要么建模为缓慢时变。由于轨迹误差在带内也可能变化很大，因此这种调整在实践中通常需要高度灵活的校正模型，而这也是的模型有较高的过拟合风险，导致点云中出现全局的变形。</p><p>​ 这些问题是的在传感器层级进行统一的误差建模的方法开始流形。</p><a id="more"></a><ol start="2" type="1"><li>联合方法。</li></ol><p>​ 主要流行于多传感器融合。</p><p>​ 值得注意的是，根据最终应用的不同，对平台轨迹的要求也存在一些差异。出于导航目的，例如汽车导航或机器导航，人们通常对平滑的车辆轨迹感兴趣。对于测量，即传感器测量的地理配准，感兴趣的轨迹是成像传感器本身的轨迹，它可能相对于车架是刚性的，也可能不是刚性的。为此，任何振动都不应被视为噪声，因此不会被滤除，因为这些振动确实会影响测量。同样，地理配准的精度要求也很高。 标称激光测距精度约为 2厘米，但据报道，对于足够平坦的地形，毫米范围内的偏差已被报道。因此，轨迹精度通常是限制因素。由于机载遥感的高测量范围，方向误差（无论是轨迹误差还是扫描仪和 INS之间的未对准）占主导地位。</p><p>​ 可以按照耦合方式进行划分：</p><p>​松耦合是指轨迹级别的误差建模：来自不同传感器的位置和/或方向估计被组合成一个综合轨迹估计。以损失部分信息换来计算效率的提升，实现复杂度相较于紧耦合是比较小的。</p><p>​ 紧耦合是指误差在传感器级别建模；即测量以原始形式组合，并且只产生一个轨迹估计。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Trajectory-level.png"></td><td><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Sensor-level.png"></td></tr></tbody></table><h3 id="multi-sensor-platform">Multi-sensor platform</h3><p><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Multi-sensor-platform.png"></p><h3 id="taxonomy-of-filtering-methods.">Taxonomy of filteringmethods.</h3><p>在Kalman filter下面还可以加一个error state kalman filter。</p><p><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Filter-methods.png"></p><h3 id="建模框架">建模框架</h3><p>​轨迹估计需要对两个有些不同的方面进行建模：传感器测量的建模和轨迹本身的建模。虽然经典方法将轨迹（以及其他时变量）表示为状态变量的离散时间序列，但一些较新的公式使用连续表示。</p><p>​ 通常，有必要在成像传感器采样时间获得轨迹估计。如果此类测量的数量很大，则可能无法在所有这些时间明确估计轨迹，要求轨迹可以以某种方式由相对较少数量的参数表示，有两种方案：1）计算固定时间点的轨迹估计，并使用插值法得出所需的中间值，或2）使用可在需要时进行评估的显式连续时间表示。</p><p><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Trajectory_estimation_characterization.png"></p><h3 id="文献总结">文献总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Table2.png"></p><p>​ 这个Tong2013<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>中做了基于高斯过程的状态估计，Furgale2012<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>-2013做了基于Spline的状态估计。但是两种方法之间的区别和联系，以及又是是什么，尚不明确。Furgale使用的B-Spline的表示方法是Qin的方案。高斯过程的方案需要对运动有一个先验，一般使用的都是高斯白噪声。这样才能得到可逆的协方差矩阵，提升计算效率。</p><ul><li>连续轨迹表示在减少参数数量和轨迹保真度之间进行权衡。这种权衡通常会导致更高频率的平滑，这可能是理想的，也可能不是理想的，具体取决于应用。</li></ul><h3 id="讨论">讨论</h3><h4 id="趋势">趋势</h4><ul><li>From recursive filtering to batchoptimization：组合导航的解决方案以前基于递归估计，即卡尔曼滤波器类型的解决方案。最近，基于批量 MAP 估计的方法越来越受欢迎。存在增量或简化的解决方案，但主要是出于性能原因：尽管计算量大，但理论上更可取全批量处理方法。</li><li>From discrete to continuous trajectoryrepresentations：经典的过滤方法将位置和方向的演变参数化为一组离散的状态。由于包含多个可能异步采样的传感器需要以非常高的频率估计位置和方向，因此连续轨迹参数化已被证明是有用的并且被广泛使用，尤其是在机器人社区中。这允许在任意时间评估位置和方向。除了随机先验之外，还可以通过选择合适的轨迹表示来合并关于轨迹的额外“确定性”先验信息。另一方面，如果测量是同步的或线性插值就足够了，则连续公式的计算要求可能更高。应该提到的是，迄今为止还没有对所有不同的轨迹表示进行详尽的比较。</li><li>From trajectory level to sensor level errormodelling：轨迹级误差建模对于小误差或遵循某些特征的误差是有效的。然而，这种方法可能导致轨迹变形，随后导致 3D模型变形，因为忽略了基础测量（GNSS 和 IMU）。估计算法的进步以及可用的计算能力导致了整体多传感器估计方法的趋势，其中误差在传感器级别建模，即以紧密耦合的方式。</li><li>Towards mathematically rigorousmodelling：最近提出的方法采用了更复杂的数学技术。这以不同的方式表现出来：对于轨迹表示，越来越多的经典欧拉角表示受到批评，并被尊重底层李群结构的参数化方法所取代。以前，加权最小二乘法只是作为一种优化工具使用，但现在它主要用于概率框架内，因为对准确随机误差建模的需求变得更加明显。对于这些统计解释，所做的工作是为了合并具有不同的、可能是先验未知概率密度的误差。在计算可行的情况下，首选提供强大理论保证的估计器，无论是关于统计最优性还是数值性能。</li></ul><h4 id="挑战">挑战</h4><p>​从纯理论的角度来看，紧耦合的全批量估计没有缺点，其中同时考虑所有测量。与增量或松散耦合的方法相比，可以预期紧密耦合的全局方法在鲁棒性和准确性方面表现更好。然而，这种“完全紧耦合”方法的实用公式已被证明是难以捉摸的。在大多数情况下，进行简化以允许更有效的处理，或者传感器以松散的方式部分耦合以简化模型和必要的计算。在各种简化和不同的耦合组合中，还没有建立明显优越的方法。如果趋势是存在的，并且全局紧耦合是优越的，那么为什么在实践中没有体现出来呢？我们认为这主要是由于两个原因，概述如下:</p><ul><li>Modelcomplexity：虽然采用更紧密耦合的方法在实践中通常表现出更高的性能，但它需要付出巨大的努力。对于传感器级误差建模，需要深入了解传感器才能准确地对误差建模，而不会在估计中引入系统误差。为此，必须访问原始传感器数据。这对于受到出口限制并且通常不允许访问原始数据而仅提供集成导航解决方案的高质量IMU 来说尤其如此。 然而，对于 GNSS 数据，这个问题已经解决了：RINEX提供了一种标准化的、文档化的数据交换格式。然而，紧耦合需要同时估计所有相关参数和测量值。与松散耦合相比，这导致更高的处理和内存要求。更高效、可并行化的算法和更快的硬件将使进一步利用紧密的传感器耦合成为可能。</li><li>Lack of comparativestudies：上述所有方法都经过实验评估，但针对不同的传感器模式和应用，并且主要是基于个体，这些都没有比较过。Cioffi 针对不同的机器人场景将离散时间和基于样条的 SLAM 实现进行了比较。然而，不同方法之间的一般深入比较是困难的，<strong>一方面是由于缺乏高精度参考数据，另一方面是因为很少有实现是公开可用的</strong>，并且由于模型的复杂性而不会经常进行重新实现。第 5节中介绍的文献中提供了不同方法的示例应用，特别是不同轨迹表示的示例应用。在一些研究中，低级和高级硬件的组合用于测试关于参考轨迹的新方法更好的系统。 然而，评估更好系统的问题仍然存在。任何比较也必然限于特定用例：对轨迹解决方案的要求，以及对平台动力学、振动和传感器噪声等系统行为的假设，因应用而异。对于移动激光扫描，尤其是在城市环境中，<strong>由于 GNSS接收不良或多径效应导致的定位误差起着很大的作用</strong>。对于机载应用，GNSS通常没有问题，但需要高精度定位，因为由于测量范围较长，定位误差对地理参考数据有很大影响。</li><li>Challenges for kinematic mappingapplications：运动学映射应用中普遍的高精度和准确度要求提出了进一步的挑战。尽管在这方面已经做了大量工作来提高低成本传感器的精度，但许多测量应用程序仍然依赖于昂贵的高级硬件。由于需要对各种算法组件进行微调，可用的处理解决方案需要经验丰富的操作员。其他基于部分处理工作流程的商业黑盒解决方案，这些解决方案在报告的准确性方面往往过于乐观。</li></ul><h4 id="展望">展望</h4><p>​ 总而言之，许多不同领域的贡献取得了很大进展。几个明显的趋势已经确立。 然而，== 最佳解决方案仍不清楚==。因此，主要的挑战是允许对不同方法进行严格的评估和比较，这反过来又需要合适的基准数据。未来在这个方向上的工作将允许开发更准确、可靠和自动的轨迹估计方法，这反过来有利于所有与运动学映射相关的活动。</p><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">Pöppl F, Neuner H, Mandlburger G, et al. Integrated trajectoryestimation for 3D kinematic mapping with GNSS, INS and imaging sensors:A framework and review[J]. ISPRS Journal of Photogrammetry and RemoteSensing, 2023, 196: 287-305.<a href="#fnref:1" rev="footnote"> ↩︎</a></li><li id="fn:2">Tong C H, Furgale P, Barfoot T D. Gaussian process gauss–newton fornon-parametric simultaneous localization and mapping[J]. TheInternational Journal of Robotics Research, 2013, 32(5):507-525.<a href="#fnref:2" rev="footnote"> ↩︎</a></li><li id="fn:3">Furgale P, Barfoot T D, Sibley G. Continuous-time batch estimation usingtemporal basis functions[C]//2012 IEEE International Conference onRobotics and Automation. IEEE, 2012:2088-2095.<a href="#fnref:3" rev="footnote"> ↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiDAR_SLAM </tag>
            
            <tag> PaperReview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hdl_graph_slam论文及代码解析_回环检测</title>
      <link href="/blogs/2025/02/08/Hdl_graph_slam/"/>
      <url>/blogs/2025/02/08/Hdl_graph_slam/</url>
      
        <content type="html"><![CDATA[<h2 id="回环检测">回环检测</h2><p>​闭环的作用就不多说了，koide采用的闭环检测方法其实挺简单的，就是一般闭环检测的基础准则。</p><h3 id="候选准则">候选准则</h3><ul><li>候选帧不能离当前帧太近，场景变化不大的话，会引入过多的冗余匹配，对实时应用不合适；</li><li>候选帧和当前帧的位姿之间的距离要足够小，这个是前提，如果都不小，那说明大概率不是闭环了，但是也不排除前端飘得确实很厉害的情况；小范围内，这个条件还是可以满足的，室外更大的场景，这种就不行了，可能飘得很厉害，只能上特征了。</li></ul><a id="more"></a><h3 id="候选帧确认">候选帧确认</h3><p>​前面只是拿到了一堆可能是候选帧的集合（这里回环候选帧是从历史帧中拿到的），还需要进一步判断到底能不能作为闭环帧，这里判断的依据就是对候选帧<span class="math inline">\(lp_{candidate}\)</span>和当前新来的关键帧<span class="math inline">\(kf_{current}\)</span>做一次点云匹配，采用的就是他们组之前的工作FastGICP、NDT_OMP做两帧点云的匹配。计算一个sum of squared error得分score，如果这个score小于阈值，则说明可以接受其作为回环帧。具体点，利用从前端得到的两帧点云的位姿<code>g2o::VertexSE3* node</code>计算一个初始的相对位姿<span class="math inline">\(T_{candidate}^{current} =T_{candidate}^{-1}·T_{current}\)</span>，作为配准初始位姿开始配准，这么做是为了提升配准方法收敛的可能性。匹配完之后返回一个度量，依据这个度量做最终的判断。</p><h3 id="回环检测流程">回环检测流程</h3><p>​ 前端开始工作，得到序列化的关键帧<span class="math inline">\(kfs\)</span>，整个SLAM系统开启的同时回环检测线程就开始工作了，一直在不断的积累关键帧，一定程度（这里可能是延时开启，或者给定关键帧数量阈值）之后，开始做候选回环帧的检测。做回环检测是在新来一帧关键帧<span class="math inline">\(kf_{current}\)</span>之后就开始的（因为要同时进行局部位姿优化得到更加准确的当前帧的位姿），通过上述候选准则，与历史帧中的关键帧进行比较，从中删选出满足条件的关键帧作为当前关键帧<span class="math inline">\(kf_{current}\)</span>的回环候选帧<span class="math inline">\(lp_{candidate}\)</span>，因为候选回环帧可能不是一个，而是一系列组成集合<span class="math inline">\(LP_{candidate}\)</span>（场景变化不大时，都很像），从<span class="math inline">\(LP_{candidate}\)</span>中找到得分最高的候选帧作为最终的回环帧<span class="math inline">\(kf_{loop}\)</span>。</p><p>注：</p><ul><li><p>回环检测结果一定要鲁棒且正确，因为如果一旦引入一个错误的闭环，整个后端就崩掉了。当然现在大部分工作都是引入特征描述子了，不仅几何空间，在特征空间也同样进行检测，极大提升回环的召回率。这里就先不介绍了。</p></li><li><p>如果候选帧的筛查是在特征空间完成的（相对位姿可直接根据匹配对SVD分解得到），后面通常会跟一个几何验证模块，即又是一个点云匹配过程，类似于ICP或者NDT得到从几何角度拿到的相对位姿，与特征匹配得到的相对位姿进行对比，完成进一步确认。</p></li></ul><h2 id="闭环优化">闭环优化</h2><h3 id="误差来源">误差来源</h3><p>​ 每一个激光帧的位姿都是通过匹配（无论是scan2scan orscan2map）得到的，每一次匹配求位姿都存在偏差，因此检测到回环的时候肯定就互相对不上了，就存在观测值（匹配的T）与估计值（一步步叠加得到的T）之间的偏差。<span class="math display">\[e=(\check{T}_i^j)^{-1}T_{jw}^{-1}T_{iw}\]</span> ​这里的误差表示和视觉SLAM14讲中的PGO优化时采用的表达方式是一样的。<span class="math inline">\(T_{iw},T_{jw}\)</span>分别表示世界坐标系下两个激光关键帧的位姿，<span class="math inline">\(\check{T}_i^j\)</span>表示的是从i到j的相对位姿（也就是闭环检测估计出来的相对位姿，可以视为观测值）。<span class="math inline">\(T_{jw}^{-1}T_{iw}\)</span>表示的就是用这两个激光关键帧通过前端不断积累之后的位姿所表示的两帧之间的相对位姿。</p><ul><li>e对两个节点位姿的jacobian公式推导<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>TODO...</li></ul><h3 id="回环边的构建">回环边的构建</h3><p>​ 得到当前激光关键帧<span class="math inline">\(kf_{current}\)</span>的回环帧<span class="math inline">\(kf_{loop}\)</span>之后，就可以构建回环边了，引入回环约束，开始后端优化。</p><p>​检测出来的回环存储于Loop结构体中，其实光看Loop的定义，无法确定relative_pose描述的是谁到谁的变换，还需要实际看使用的时候的传入参数。hdl_graph_slam中采用的是<span class="math inline">\(T_{loop}^{current}\)</span>，检测到的回环帧<span class="math inline">\(kf_{loop}\)</span>到当前关键帧<span class="math inline">\(kf_{current}\)</span>的变换，也就是key2<span class="math inline">\(\Rightarrow\)</span>key1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Loop</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  EIGEN_MAKE_ALIGNED_OPERATOR_NEW<br>  <span class="hljs-keyword">using</span> Ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Loop&gt;;<br>  Loop(<span class="hljs-keyword">const</span> KeyFrame::Ptr&amp; key1, <span class="hljs-keyword">const</span> KeyFrame::Ptr&amp; key2, <span class="hljs-keyword">const</span> Eigen::Matrix4f&amp; relpose) <br>      : key1(key1), key2(key2), relative_pose(relpose) &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>  KeyFrame::Ptr key1;<br>  KeyFrame::Ptr key2;<br>  Eigen::Matrix4f relative_pose;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​ 回环边的构建如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">g2o::EdgeSE3* <span class="hljs-title">GraphSLAM::add_se3_edge</span><span class="hljs-params">(g2o::VertexSE3* v1, g2o::VertexSE3* v2, <span class="hljs-keyword">const</span> Eigen::Isometry3d&amp; relative_pose, <span class="hljs-keyword">const</span> Eigen::MatrixXd&amp; information_matrix)</span> </span>&#123;<br>  <span class="hljs-function">g2o::EdgeSE3* <span class="hljs-title">edge</span><span class="hljs-params">(<span class="hljs-keyword">new</span> g2o::EdgeSE3())</span></span>;<br>  edge-&gt;setMeasurement(relative_pose);<br>  edge-&gt;setInformation(information_matrix);<br>  edge-&gt;vertices()[<span class="hljs-number">0</span>] = v1;<br>  edge-&gt;vertices()[<span class="hljs-number">1</span>] = v2;<br>  graph-&gt;addEdge(edge);<br>  <span class="hljs-keyword">return</span> edge;<br>&#125;<br></code></pre></td></tr></table></figure><p>​回环边连接的两个顶点是用<code>g2o::SE3</code>表示的顶点，表示关键帧的位姿世界坐标系下，相对于第一帧的位姿。观测值是两个节点之间的相对位姿，采用<code>Eigen::Isometry3d</code>表示。构建的边的类型是用<code>g2o::EdgeSE3</code>表示的，计算的误差是一个6维的向量。g2o中的实现如下：</p><ul><li>VertexSE3，g2o中采用<code>Eigen::Isometry3</code>来描述当前帧的位姿</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * \brief 3D pose Vertex, represented as an Isometry3</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3D pose vertex, represented as an Isometry3, i.e., an affine transformation</span><br><span class="hljs-comment"> * which is constructed by only concatenating rotation and translation</span><br><span class="hljs-comment"> * matrices. Hence, no scaling or projection.  To avoid that the rotational</span><br><span class="hljs-comment"> * part of the Isometry3 gets numerically unstable we compute the nearest</span><br><span class="hljs-comment"> * orthogonal matrix after a large number of calls to the oplus method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * The parameterization for the increments constructed is a 6d vector</span><br><span class="hljs-comment"> * (x,y,z,qx,qy,qz) (note that we leave out the w part of the quaternion.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VertexSE3</span> :</span> <span class="hljs-keyword">public</span> BaseVertex&lt;<span class="hljs-number">6</span>, Isometry3&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>EdgeSE3，误差同样也是一个<code>VertexSE3</code>型的变量表示的，而<code>VertexSE3</code>实际上是<code>Isometry3</code>，<code>Isometry3</code>实际上又是（x,y,z,qx,qy,qz）不表示缩放。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EdgeSE3 : <span class="hljs-keyword">public</span> BaseBinaryEdge&lt;<span class="hljs-number">6</span>, Isometry3, VertexSE3, VertexSE3&gt;<br>&#123;<br>    ...<br>    <span class="hljs-comment">// 虽然代码中的注释写明，这个误差表示的是j到i节点的变换的，z^-1 * (x_i^-1 * x_j)误差应该是这样的，但是实际写的时候好像写反了</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EdgeSE3::computeError</span><span class="hljs-params">()</span> </span>&#123;<br>        VertexSE3 *from = <span class="hljs-keyword">static_cast</span>&lt;VertexSE3*&gt;(_vertices[<span class="hljs-number">0</span>]);<br>        VertexSE3 *to   = <span class="hljs-keyword">static_cast</span>&lt;VertexSE3*&gt;(_vertices[<span class="hljs-number">1</span>]);<br>        Isometry3 delta=_inverseMeasurement * from-&gt;estimate().inverse() * to-&gt;estimate();<br>        _error=internal::toVectorMQT(delta);<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">// 其中Isometry3转换为6维的误差</span><br><span class="hljs-function">Vector6 <span class="hljs-title">toVectorMQT</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Isometry3&amp; t)</span> </span>&#123;<br>    Vector6 v;<br>    <span class="hljs-comment">// 表示从变换矩阵t中提取旋转矩阵，再转为归一化的四元数，返回四元数的实部，放在返回向量的后三位</span><br>    v.block&lt;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>) = toCompactQuaternion(extractRotation(t));<br>    <span class="hljs-comment">// 下面表示直接将平移从t中提取出来放在返回向量的前三位</span><br>    v.block&lt;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) = t.translation();<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 加入到图中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// loop detection, should be false in first round of detection but it's correct</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Loop::Ptr&gt; loops = loop_detector-&gt;detect(keyframes, new_keyframes, *graph_slam);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; loop : loops) &#123;<br>      <span class="hljs-function">Eigen::Isometry3d <span class="hljs-title">relpose</span><span class="hljs-params">(loop-&gt;relative_pose.cast&lt;<span class="hljs-keyword">double</span>&gt;())</span></span>;<br>      <span class="hljs-comment">// calc_information_matrix is a reweight procedure</span><br>      Eigen::MatrixXd information_matrix = inf_calclator-&gt;calc_information_matrix(loop-&gt;key1-&gt;cloud, loop-&gt;key2-&gt;cloud, <br>                                                                                  relpose);<br>      <span class="hljs-keyword">auto</span> edge = graph_slam-&gt;add_se3_edge(loop-&gt;key1-&gt;node, loop-&gt;key2-&gt;node, relpose, information_matrix);<br>      graph_slam-&gt;add_robust_kernel(edge, private_nh.param&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"loop_closure_edge_robust_kernel"</span>, <span class="hljs-string">"NONE"</span>), <br>                                    private_nh.param&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">"loop_closure_edge_robust_kernel_size"</span>, <span class="hljs-number">1.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>个人觉着，将回环边加入到图中时，顶点的添加顺序应该和相对位姿的作用方向严格对应，假设1&amp;2节点互换，相对位姿也求逆就可以了。</li><li>有小伙伴说VertexSE3在g2o中的<a href="https://githubmemory.com/repo/RainerKuemmerle/g2o/issues/430">实现</a>是采用的右扰动，因此，和一般常见的左扰动不一致，就有点突然...也确实是这样的，亲测如此。</li></ul><h2 id="gps点约束">GPS点约束</h2><p>​hdl_graph_slam中GPS信号是不断接收的，因此会有一个时间戳，通过硬件同步之后，激光和GPS完成时间同步，就可以通过时间找到最近GPS点对应的激光帧的位置，从而构建关系。</p><ul><li>将一段滑窗内的gps点与攒起来的激光关键帧进行时间戳比较的时候，虽然找的是最近的，但是万一最近的gps点和某关键帧之间的时间差还是差很多，依然是无法建立关系的，需要及时剔除。</li><li>GPS点是<code>WGS84</code>坐标系下的，需要转成空间直角坐标系<code>UTM</code>下的北东高坐标才行。</li></ul><h3 id="误差方程">误差方程</h3><p><span class="math display">\[e=G(t)-p\]</span></p><p>这种表示方法，说明一个gps点只能控制位置，无法控制旋转，因此没有R什么事情。</p><h3 id="gps边的构建">gps边的构建</h3><p>​构建一元边，GPS节点是固定的。koide这里认为gps定位结果如果认为xyz都有效，则使用<code>add_se3_prior_xyz_edge</code>类型的边，如果只有平面左边有效，则使用<code>add_se3_prior_xy_edge</code>，信息矩阵的权重和观测精度有关。这里认为信息矩阵就是协方差的逆，协方差可以看成是在三个维度上观测值的方差。</p><p>​构建的一元边的类型分别是：<code>g2o::EdgeSE3PriorXY</code>和<code>g2o::EdgeSE3PriorXYZ</code>,都比较好理解。koide在使用时，误差采用的是估计值-观测值，和我的理解相反了，不过不影响结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeError</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> g2o::VertexSE3* v1 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> g2o::VertexSE3*&gt;(_vertices[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// only translation is used</span><br>    Eigen::Vector3d estimate = v1-&gt;estimate().translation();<br>    _error = estimate - _measurement;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 加入到图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::isnan(xyz.z())) &#123;<br>    Eigen::Matrix2d information_matrix = Eigen::Matrix2d::Identity() / gps_edge_stddev_xy;<br>    edge = graph_slam-&gt;add_se3_prior_xy_edge(keyframe-&gt;node, xyz.head&lt;<span class="hljs-number">2</span>&gt;(), information_matrix);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    Eigen::Matrix3d information_matrix = Eigen::Matrix3d::Identity();<br>    information_matrix.block&lt;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) /= gps_edge_stddev_xy;<br>    information_matrix(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) /= gps_edge_stddev_z;<br>    edge = graph_slam-&gt;add_se3_prior_xyz_edge(keyframe-&gt;node, xyz, information_matrix);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="imu观测">IMU观测</h2><h3 id="误差方程-1">误差方程</h3><p>TODO</p><h3 id="imu边的构建">IMU边的构建</h3><p>TODO</p><h2 id="整个后端优化流程">整个后端优化流程</h2><p>​ros环境下用roslaunch随便启动一个hdl_graph_slam的launch文件，都会启动如下四个节点：<code>prefiltering_nodelet</code>,<code>scan_matching_odometry_nodelet</code>，<code>floor_detection_nodelet</code>，<code>hdl_graph_slam_nodelet</code>，看名字就知道对应的功能是什么了。其实我对ros不熟悉，认为一个launch文件通过配置多个nodelet的方式同时启动多个节点就相当于实例化出多个对象，每个对象都可以开始做事情，之间可以快速的数据共享<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。这些节点都是nodelet的派生类。</p><p>​<code>prefiltering_nodelet</code>节点主要负责接收从硬件传回来的点云数据，完成去畸变，简单距离过滤等操作，然后将其逐帧发布为<code>/filtered_points</code>主题。</p><p>​<code>scan_matching_odometry_nodelet</code>负责前端匹配，发布里程计消息。它也订阅了<code>/filtered_points</code>话题，一旦检测到消息，就调用<code>cloud_callback()</code>，将传入的点云逐帧和之前的帧进行匹配，得到以前一帧点云为基准的相对位姿，并返回以全部帧中第一帧为基准的世界坐标下的位姿，核心是<code>matching()</code>函数。要随着激光帧的不断发布和接收，将newframe的位姿视为下一次前端匹配中的oldframe的位姿，并以当前的匹配估计值作为下一次匹配的先验，提升匹配成功的概率。<span class="math display">\[T_{source}=T_{new keyframe}^{w}\\T_{target}=T_{old frame}^{w}\\T_{source}^{target} = T_{new keyframe}^{old keyframe} =matching()\{ICP,NDT \quad liked \quad method\}\]</span> ​<code>hdl_graph_slam_nodelet</code>在一开始初始化的时候就自动订阅如下的主题，并开始循环接受其发出的消息：看名识功能</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/odom</span>;<br><span class="hljs-string">/filtered_points</span>;<br><span class="hljs-string">/gpsimu_driver/imu_data</span>;<br><span class="hljs-string">/floor_detection/floor_coeffs</span>;<br><span class="hljs-string">/gps/geopoint</span>;<br><span class="hljs-string">/gpsimu_driver/nmea_sentence</span>;<br><span class="hljs-string">/gps/navsat</span>，<br></code></pre></td></tr></table></figure><p>​<code>hdl_graph_slam_nodelet</code>在初始化时通过订阅<code>/odom</code>和<code>/filtered_points</code>的消息并调用<code>cloud_callback()</code>，将估计的里程计位姿和点云绑定在一起，并检查当前帧是否构成成为关键帧的条件，满足才会将关键帧留下来。</p><p>​<code>hdl_graph_slam_nodelet</code>还包含了成员<code>optimization_timer</code>和<code>map_publish_timer</code>，都是ros下的一个定时器<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>类型，且在其虚函数<code>onInit()</code>函数中做了初始化。这两个定时器分别表示每隔3s做一次优化和每隔10s发布一次地图点的两个不同操作。<code>optimization_timer_callback()</code>和<code>map_points_publish_timer_callback()</code>就是定时器到点了之后执行的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> graph_update_interval = private_nh.param&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">"graph_update_interval"</span>, <span class="hljs-number">3.0</span>);<br><span class="hljs-keyword">double</span> map_cloud_update_interval = private_nh.param&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">"map_cloud_update_interval"</span>, <span class="hljs-number">10.0</span>);<br>optimization_timer = mt_nh.createWallTimer(ros::WallDuration(graph_update_interval), <br>                                               &amp;HdlGraphSlamNodelet::optimization_timer_callback, <span class="hljs-keyword">this</span>);<br>map_publish_timer = mt_nh.createWallTimer(ros::WallDuration(map_cloud_update_interval), <br>                                              &amp;HdlGraphSlamNodelet::map_points_publish_timer_callback, <span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>​<code>optimization_timer_callback()</code>回调函数中，首先执行<code>flush_keyframe_queue()</code>判断是否有关键帧更新，并对已有的关键帧构建成图，包括添加节点，构建序列节点之间的边（观测就是相对位姿<span class="math inline">\(T_{curr}^{prev}=T_{curr}^{-1}·T_{prev}\)</span>，估计值就是各自的位姿）。关键帧更新成功之后，开始依次调用<code>flush_floor_queue()</code>,<code>flush_gps_queue()</code>和<code>flush_imu_queue()</code>，功能分别是：</p><ul><li><code>flush_floor_queue()</code>：首先需要知道<code>floor_detection_nodelet</code>在一开始系统启动的时候就存在了，同时该节点会自动订阅<code>/filtered_points</code>节点的消息，收到消息之后就会执行<code>cloud_callback()</code>回调函数（<code>onInit</code>函数中），立马针对接收到的点云提取平面，发布平面参数。<code>hdl_graph_slam_nodelet</code>通过订阅相应的主题，就可以拿到平面提取结果。所有的平面提取结果是通过时间戳的形式和每一个关键帧建立关系的。因此<code>flush_floor_queue()</code>就是要通过时间比对，找到对应关系，往图中添加平面节点。</li><li><code>flush_gps_queue()</code>：在<code>hdl_graph_slam_nodelet</code>的<code>onInit()</code>中设置了如果当前环境支持gps，就会自动分别从<code>"/gps/geopoint"</code>,<code>"/gpsimu_driver/nmea_sentence"</code>和<code>"/gps/navsat"</code>节点订阅消息，分别执行<code>gps_callback()</code>,<code>nmea_callback()</code>和<code>navsat_callback()</code>。<code>gps_callback()</code>负责将现有的gps数据存储下来到队列中，<code>nmea_callback()</code>和<code>navsat_callback()</code>一样都是用已经写好的驱动包读取（解析）GNSS数据然后调用<code>gps_callback()</code><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，这样就把需要的数据都接收完了。然后<code>flush_gps_queue()</code>主要是通过时间检查，关联gps点和关键帧，找到对应关系，往图中添加gps节点。</li><li><code>flush_imu_queue()</code>：TODO...</li></ul><p>​这些传感器的约束就通过这三个函数引入了，如果这三个全都没有，直接退出优化，没有额外的观测，无法平差。其中任意一个有的话就继续。</p><p>​接下来就开始回环检测，将检测到的回环帧们构建成回环约束加入到图中。用于回环检测的对象是，当前时刻之前攒下的局部滑动窗口中的关键帧和现存的关键帧集合，一开始是空的，隔一段时间之后才会有积累，因此第一次loopdetection肯定返回false的。然后将临时的关键帧拷贝到集合中。最后就开始图优化的过程了。LiDARSLAM的图优化这里没用什么技巧，就是正常的选择求解器，设定循环次数，开始优化就结束了。优化完之后每个节点的位姿通过<code>KeyFrameSnapshot</code>和<code>KeyFrame</code>的转换（内部构造函数）中直接将图的节点位姿传递给关键帧的位姿，用于保存。</p><p>​<code>map_points_publish_timer_callback()</code>就是将通过绑定的位姿将<code>optimization_timer_callback()</code>优化好的关键帧中的点云变换到统一的世界坐标系下，并抽稀，然后发布就完了。</p><h2 id="reference">Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">在最新版的g2o中已经变成了和ceres一样的自动求导了...<a href="#fnref:1" rev="footnote">↩︎</a></li><li id="fn:2">https://m.jb51.cc/xml/294932.html<a href="#fnref:2" rev="footnote">↩︎</a></li><li id="fn:3">https://www.ncnynl.com/archives/201702/1296.html<a href="#fnref:3" rev="footnote">↩︎</a></li><li id="fn:4">实际中可能IMU中也集成了一个GNSS，因此有两个<a href="#fnref:4" rev="footnote">↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
            <tag> LiDAR_SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hdl_graph_slam论文及代码解析_后端优化</title>
      <link href="/blogs/2025/02/08/Hdl_graph_slam2/"/>
      <url>/blogs/2025/02/08/Hdl_graph_slam2/</url>
      
        <content type="html"><![CDATA[<h2 id="针对性设计的平面提取方法">1. 针对性设计的平面提取方法</h2><p>​因为这里使用的传感器其实一个组装的VLP16型多线激光雷达+相机+imu的背包激光扫描仪，作者考虑到LiDAR有一定的安置误差(提前肯定标定了的，e.g.倾角)，而本文使用的又是室内场景平面，因此需要根据一个仪器安装的先验确定z轴方向指向哪里（默认传感器的坐标系为右前上，z轴指向天空）。得到这个倾角主要是为了修正LiDAR坐标系的z轴方向。这对后续的高度滤波和地面点判断都有一定的影响。</p><p>​在提取平面时，为了提升效率，首先基于扫描仪的高度，通过高度滤波将一定高度之外的点去掉，同时对剩下的点云计算法向量（通过提前性的点云剔除，可以提升这里的计算效率）进行过滤，和z方向进行比较，保留地面点（和z轴夹角小就说明方向近似），用RANSAC的方式拟合平面参数方程。这样就可以以较快的速度从单帧点云中提取出一个合适的平面。注意：原文中写的是直接用RANSAC提取平面的，这个非常的费时间，实际操作并不是这样子来的。</p><a id="more"></a><p>​ 平面参数方程采用一般形式进行表达： <span class="math display">\[\begin{align}\pi &amp;:= n_x*x+n_y*y+n_z*z+d=0 \\\pi &amp;:= [(n_x,n_y,n_z),d]\end{align}\]</span></p><h2 id="平面节点的构建以及优化">2. 平面节点的构建以及优化</h2><p>​平面参数拿到之后如何抽象成为图中的一个节点，并参与优。在优化时，其实并不是所有帧都提取平面的，作者每隔10s从一个关键LiDAR帧中提取一个平面，然后引入到PGO中。不然也算不过来。</p><h3 id="平面约束从何而来">平面约束从何而来</h3><p>​约束嘛，肯定得有参考，作者的实验场景是室内，提取的还是地面，可想而知，约束是通过__该平面__（<strong>提取平面</strong>）的参数与__世界坐标系下的xoy平面平行的一个平面__（<strong>参考平面</strong>）确定的。更具体地，假设在t时刻从当前LiDAR激光帧中提取的平面方程为<span class="math inline">\(\pi(t):[n_p,d_p]\)</span>(local坐标系下,这里省略了<span class="math inline">\(n_p(t),d_p(t)为n_p,d_p\)</span>)，而给定的世界坐标系(canonicalor world)下的参考平面方程为<span class="math inline">\(\pi(0):[n_b,d_b]\)</span>，也就是<span class="math inline">\(\pi(0):[(0,0,1),0]\)</span>(和其他方向的平面需要设置不同的法向量朝向)。即：<span class="math display">\[\begin{align}nx_p*x+ny_p*y+nz_p*z+d_p=0 \\ \\nx_b*x+ny_b*y+nz_b*z+d_b=0\end{align}\]</span> ​这两个平面之间的差，两个平面之间的差需要比较法向量和截距（排除平行的情况）：</p><ul><li>如果当前LiDAR帧的位姿估计的准确的话，提取得到的平面的法向量<span class="math inline">\(n_p\)</span>应该和<span class="math inline">\(n_b\)</span>是相近的，截距应该是相等的，排除沿着法向方向的平移现象：<ul><li>作者这里参照的其实是一个发表在ICRA2016上的文章Cpa-SLAM<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，中的方法完成了两个平面方程的参数化过程，</li></ul></li></ul><p><span class="math display">\[\pi := [(n_x,n_y,n_z),d]\quad \Longrightarrow\quad\tau(\pi)=[arctan(\frac{n_y}{n_x}),arctan(\frac{n_z}{|n|}),d]\]</span></p><p>​ <span class="math inline">\(arctan(\frac{n_y}{n_x}),arctan(\frac{n_z}{|n|})\)</span>分别表示的是球坐标系下的azimuth（方向角）和elevation（高度角）<span class="math inline">\(|n|\)</span>应该是在水平面内的投影。具体这么参数化的好处是啥呢，暂时还没有了解清楚，TODO...</p><p>​ 此外还需要注意的是注意：</p><ul><li>平面约束是如何与节点位姿建立关系呢？（这个是平面可以作为约束参与优化的基础）<ul><li>这里就涉及到一个坐标系转换的问题，一个是LiDAR点云帧的local系(因为点云就是从这个里面提取出来的)，一个是假定的canonical（world）系，两个需要在同一的坐标系下才能做运算，有两种思路，1）都变换到world下（koide采用的就是这种思路）；或者都同一变到canonical(world)坐标系下。这里就需要知道每一个LiDAR点云帧都保留了其在world坐标系下（相对于第一帧）的位姿<span class="math inline">\(T_{iw}\)</span>,通过<span class="math inline">\(T_{iw}\)</span>可以将平面<span class="math inline">\(\pi(0)\)</span>变换到<span class="math inline">\(\pi(t)\)</span>的坐标系下，实现统一。</li></ul></li><li>如何对一个平面进行变换？假设现在有了一个平面<span class="math inline">\(\pi\)</span>，在经过T变换之后，对应的平面参数<span class="math inline">\(\pi^{&#39;}\)</span>应该是什么呢？如下所示。<a href="https://community.khronos.org/t/clever-way-to-transform-plane-by-matrix/49570/3">证明参见</a></li></ul><p><span class="math display">\[\pi^{&#39;}=(T^{-1})^T·\pi=(T^T)^{-1}·\pi= \left[ \begin{array}{cc} R^{T} &amp; 0^{T} \\-R^{T}t &amp; 1\end{array} \right]·\left[ \begin{array}{cc} n \\ d \end{array} \right]= \left[ \begin{array}{cc} R^Tn \\ d- R^Ttn \end{array}\right]\]</span></p><ul><li>hdl_graph_slam中使用的参考平面为世界坐标系下的参考平面为<span class="math inline">\(\pi(0):[(0,0,1),0]\)</span>，而LiDAR激光帧的位姿<span class="math inline">\(T_{iw}\)</span>表示的就是世界坐标系下的坐标，只是相对于第一帧而言的，因此从local系提取得到的平面参数中法向量本身可以看成是和<span class="math inline">\([0,0,1]\)</span>的差，那么在计算误差时直接就可以将<span class="math inline">\(\tau(t)\)</span>看成是<span class="math inline">\(e\)</span>误差，只需要对截距t做变换<span class="math inline">\(T_{iw}\)</span>即可了，而这里使用的是地面，d=0，就省略了这一部分在实际代码中有所体现。（PS：更加复杂的情况需要修改g2o中的代码才行，不太行的样子...）</li></ul><h3 id="误差方程的构建">误差方程的构建</h3><p>误差=观测值-预测值（通常是这样的，如果反过来只会影响jacobian的方程，对结果没有影响）</p><p>这里将变换到当前LiDAR坐标系下的<span class="math inline">\(\pi(0)\)</span>作为了观测值，提取的平面作为了预测值（按照我的理解，和他正好是反的，但是对结果没有啥影响）<span class="math display">\[\begin{aligned}一直和z方向比:\quad e = \tau(\pi(0)^{&#39;}) - \tau(\pi(t))  \\和前一个提取的平面参数比:\quad e = \tau(\pi(t-1)^{&#39;}) - \tau(\pi(t))\end{aligned}\]</span> 最小二乘优化它的二次型即可。 <span class="math display">\[E = e^T \Omega e\]</span></p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th style="text-align: center;"><img src="/blogs/.io//The proposed pose graph structure.gif" style="zoom:80%;"></th><th style="text-align: center;"><img src="/blogs/.io//A representation of the azimuth and the elevation of the sun..jpg" style="zoom:80%;"></th></tr></thead><tbody><tr><td style="text-align: center;">a</td><td style="text-align: center;">b</td></tr></tbody></table><h3 id="平面参与优化过程">平面参与优化过程</h3><p>​hdl_graph_slam中平面检测和LiDAR关键帧是放在独立的deque中存储的，又通过消息的发布和接收进行数据共享。运行launch时，会自动开启好几个nodelet，e.g.HdlGraphSlamNodelet,floor_detection_nodelet, ScanMatchingOdometryNodelet,PrefilteringNodelet。这几个nodelet处于一个进程中，但是可以独立干自己的事情，通过消息的publish和subscribe进行完成消息共享。</p><p>​前端里程计在不断的完成关键帧的位姿估计，并存放在队列中，平面检测是每隔10s进行的（<strong>提取平面</strong>），也将估计结果存放在另一个队列中（1hz&lt;10hz的LiDAR帧率，而且LiDAR关键帧更低）。将选择得到的关键帧的与时间戳绑定，平面检测结果也和时间戳绑定，这样就可以通过时间上的对比完成两个数据之间的同步（或者称为数据关联）。完成平面提取结果和关键LiDAR帧的绑定之后，就可以构建平面约束了。引入图中的平面节点是canonical（world）坐标系下的平面（<strong>参考平面</strong>），也就是<span class="math inline">\(\pi(0):[(0,0,1),0]\)</span>,利用与之时间匹配的LiDAR的pose，将参考平面和提取平面坐标系统一起来，构建平面约束边，误差计算方法是：首先将参考平面通过当前LiDAR帧pose（local系，表示世界坐标系下相对于第一帧的位姿？）的逆，变换到LiDAR点云的local系，然后和估计RANSAC估计出来的平面（本身就在local系下）做差。这一套都完成之后就构建好了一条平面边，加入到图中。如上图a</p><h2 id="源码解析">3. 源码解析</h2><h3 id="平面提取">1. 平面提取</h3><p>​其实代码这部分和上述描述一致，注释好的代码见本仓库app/floor_detection_nodelet.cpp。</p><h3 id="引入平面节点的过程">2. 引入平面节点的过程</h3><p>​实际引入过程和上述描述一致，注释好的代码见本仓库app/HdlGraphSlamNodelet-&gt;optimization_timer_callback()-&gt;flush_floor_queue()。</p><h3 id="g2o已经实现好的平面节点以及边">3.g2o已经实现好的平面节点以及边</h3><ul><li>注意：这个EdgeSE3Plane是koide自己实现的，可能和原始g2o中的不太一样。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief plane edge, the error is stored as g2o::Plane3D(in fact is a vector3 but should be initialized by vector4(plane coefficient))</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeSE3Plane</span> :</span> <span class="hljs-keyword">public</span> g2o::BaseBinaryEdge&lt;<span class="hljs-number">3</span>, g2o::Plane3D, g2o::VertexSE3, g2o::VertexPlane&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  EIGEN_MAKE_ALIGNED_OPERATOR_NEW<br>  EdgeSE3Plane() : BaseBinaryEdge&lt;<span class="hljs-number">3</span>, g2o::Plane3D, g2o::VertexSE3, g2o::VertexPlane&gt;() &#123;&#125;<br>  <span class="hljs-comment">// error is 3d vector, azimuth, elevation, the length of intercept respectively</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeError</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// current node pose</span><br>    <span class="hljs-keyword">const</span> g2o::VertexSE3* v1 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> g2o::VertexSE3*&gt;(_vertices[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// plane node (canonical plane coeff is used here as observations)</span><br>    <span class="hljs-comment">// i believe the estimate plane here is both ok, but TODO figure out)</span><br>    <span class="hljs-keyword">const</span> g2o::VertexPlane* v2 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> g2o::VertexPlane*&gt;(_vertices[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// v1 is the pose in canonical(world) coordinate</span><br>    <span class="hljs-comment">// w2n represents the transformation from canonical(world) to local </span><br>    <span class="hljs-comment">// this pose should be understanded bind with whole plane node added to graph pipline</span><br>    Eigen::Isometry3d w2n = v1-&gt;estimate().inverse();<br>    <span class="hljs-comment">// transform the plane in canonical frame to current lidar coordinate</span><br>    Plane3D local_plane = w2n * v2-&gt;estimate();<br>    <span class="hljs-comment">// error should be measurement minus estimate value</span><br>    <span class="hljs-comment">// i believe here is inversed but no effect to the result, given the eTe model</span><br>    _error = local_plane.ominus(_measurement);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>g2o定义的Plane3D给出了平面边误差方程的计算实现代码，其中实现的挺好的，就一个成员是Eigen::Vector4d,包含了从一个平面参数中提取球坐标系下方向角azimuth，高度角elevation等过程，重点关注求差__ominus<strong>，运算符</strong>*__重载过程（和上述讲的平面变换的过程一致）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Plane3D&#123;<br>...<br><span class="hljs-comment">// update the current state, looks like its left-hand coordinate? BUGFIX</span><br><span class="hljs-comment">// the rotation of elevation is countclockwise</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oplus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Vector3&amp; v)</span></span>&#123;<br>      <span class="hljs-comment">// construct a normal from azimuth and evelation;</span><br>      <span class="hljs-comment">// this is from spherical coordinates to cartesian coordinate</span><br>      <span class="hljs-keyword">number_t</span> _azimuth=v[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">number_t</span> _elevation=v[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">number_t</span> s=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(_elevation), c=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(_elevation);<br>      <span class="hljs-function">Vector3 <span class="hljs-title">n</span> <span class="hljs-params">(c*<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(_azimuth), c*<span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(_azimuth), s)</span> </span>;      <br>      <span class="hljs-comment">// rotate the normal</span><br>      Matrix3 R=rotation(normal());<br>      <span class="hljs-keyword">number_t</span> d=distance()+v[<span class="hljs-number">2</span>];<br>      _coeffs.head&lt;<span class="hljs-number">3</span>&gt;() = R*n;<br>      <span class="hljs-comment">// the length of intercept is direct add but why negative?</span><br>      _coeffs(<span class="hljs-number">3</span>) = -d;<br>      normalize(_coeffs);<br>    &#125;    <br><span class="hljs-function"><span class="hljs-keyword">inline</span> Vector3 <span class="hljs-title">ominus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Plane3D&amp; plane)</span></span>&#123;<br>      <span class="hljs-comment">// construct the rotation that would bring the plane normal in (1 0 0)</span><br>      Matrix3 R=rotation(normal()).transpose();<br>      Vector3 n=R*plane.normal();<br>      <span class="hljs-keyword">number_t</span> d=distance()-plane.distance();<br>      <span class="hljs-keyword">return</span> Vector3(azimuth(n), elevation(n), d);<br>    &#125;<br>  &#125;;<br><span class="hljs-comment">// exactly same with the plane transform formula</span><br><span class="hljs-keyword">inline</span> Plane3D <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Isometry3&amp; t, <span class="hljs-keyword">const</span> Plane3D&amp; plane)&#123;<br>    Vector4 v=plane._coeffs;<br>    Vector4 v2;<br>    Matrix3 R=t.rotation();<br>    v2.head&lt;<span class="hljs-number">3</span>&gt;() = R*v.head&lt;<span class="hljs-number">3</span>&gt;();<br>    v2(<span class="hljs-number">3</span>)=v(<span class="hljs-number">3</span>) - t.translation().dot(v2.head&lt;<span class="hljs-number">3</span>&gt;());<br>    <span class="hljs-keyword">return</span> Plane3D(v2);<br>  &#125;;<br>Vector4 _coeffs; <span class="hljs-comment">// [n,d]</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference">4. Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">Ma L, Kerl C, Stückler J, et al. CPA-SLAM: Consistent plane-modelalignment for direct RGB-D SLAM[C]//2016 IEEE International Conferenceon Robotics and Automation (ICRA). IEEE, 2016:1285-1291.<a href="#fnref:1" rev="footnote"> ↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
            <tag> LiDAR_SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Spline探秘</title>
      <link href="/blogs/2025/02/08/B-Spline/"/>
      <url>/blogs/2025/02/08/B-Spline/</url>
      
        <content type="html"><![CDATA[<h2 id="b-splinebasic-spline">B-Spline（=Basic Spline）</h2><h3 id="需求">需求</h3><ul><li>需要利用样条函数拟合<a href="https://github.com/whu-lyh/PoseSpline">时相连续的数据</a>，e.g.IMU data。</li><li>利用样条函数拟合散点，做表面拟合，e.g.构建mesh或者其他光滑的表面。</li><li><a href="https://zhuanlan.zhihu.com/p/159192419">路径规划</a>中使用样条线对A*算法进行优化，得到更加平滑的路径。</li><li>多传感器融合任务中，e.g.<a href="https://github.com/ethz-asl/kalibr.git">多传感器标定</a>时，为了内插任意时刻的状态，实现多传感器的时间对齐，使用B-spline做内插。</li></ul><a id="more"></a><h3 id="相关术语123">相关术语<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h3><p>​大白话来说，B样条曲线其实就是分段多项式，每个分段内的函数又由每个分段内多个子函数（基函数）叠加而成，不同基函数之间有不同的占比。处于高阶的基函数又由相邻分段节点处的低阶基函数得到，由此形成一个不断传递（递归）的过程，直到全部的都计算完毕。B-spline曲线就是每个控制点乘以自己对应的权重系数函数（基函数），然后再求和，控制点是后期指定的，权重函数是预先定义好的，只跟阶数有关，与控制点无关。</p><table><colgroup><col style="width: 23%"><col style="width: 12%"><col style="width: 63%"></colgroup><thead><tr><th style="text-align: center;">Terminologies</th><th style="text-align: center;">Notation</th><th>Explanation</th></tr></thead><tbody><tr><td style="text-align: center;">Independent Variable</td><td style="text-align: center;"><span class="math inline">\(t\)</span></td><td>In state estimation, the independent variable is time <span class="math inline">\(t\)</span>. <span class="math inline">\(t\)</span>应该包含<span class="math inline">\(k\)</span>的范围的实数，而<span class="math inline">\(k\)</span>一定是正整数</td></tr><tr><td style="text-align: center;">Order（阶）</td><td style="text-align: center;"><span class="math inline">\(n\)</span></td><td>Same as the order of final polynomial, the highest exponent. Forinstance, <span class="math inline">\(f(x) = 3x^3\)</span> has an orderof 4.样条曲线的阶是样条曲线的次数加一。样条曲线的阶越高，控制点越多。二次样条的阶数是三，样条曲线段与三个控制点决定；三次样条的阶数是四，样条曲线段与四个控制点决定。</td></tr><tr><td style="text-align: center;">Degree（次）</td><td style="text-align: center;"><span class="math inline">\(p\)</span></td><td>Same as the degree of final polynomial, the highest exponent. Forinstance, <span class="math inline">\(f(x) = 3x^3\)</span> has an degreeof 3.所构成样条曲线的一段光滑参数曲线段，由控制多边形的相邻连续的几段折线段决定，就是几次样条，最常用的就是二次和三次样条。二次样条的某一曲线段只与相应的两段折线段，三个控制多边形顶点有关，改变其中一个顶点，将影响<strong>三段样条曲线段</strong>。同样的，对三次样条，某一曲线段由相应的三段折线段，四个控制点决定。</td></tr><tr><td style="text-align: center;">Segment Index</td><td style="text-align: center;"><span class="math inline">\(i\)</span></td><td>A B-Spline is combined with piecewise polynomial, each piece is asegment.样条曲线是由一组逼近控制多边形的光滑参数曲线段构成，这些曲线段就是样条曲线段。</td></tr><tr><td style="text-align: center;">Knot Vector</td><td style="text-align: center;"><span class="math inline">\(\mathbf{k}\)</span></td><td><span class="math inline">\(k_0 \leq k_1 \leq ... \leqk_{m-1}\)</span>, The connect knot, or joint, between every piece ofpolynomial segment. ==Knot vector lies in the axis of independentvariable <span class="math inline">\(t\)</span>==.knot是被提前设计好的，一般被设计成为一组非递减的正整数。</td></tr><tr><td style="text-align: center;">Basis Function</td><td style="text-align: center;"><span class="math inline">\(B_{i,p}(t)\)</span></td><td>In the expression, <span class="math inline">\(i\)</span> is theindex of polynomial segment, <span class="math inline">\(p\)</span> isthe degree of the basis function.</td></tr><tr><td style="text-align: center;">Control Points（数值）</td><td style="text-align: center;"><span class="math inline">\(C_i\)</span></td><td>Also named as ==coefficients==. Control points are used to describethe weight of each piece of polynomial segment.<del>构成特征多边形的各段折线的端点，就是特征多边形的顶点，也叫做控制多边形的控制点。只有在特殊情况下，样条曲线才能通过控制点</del>（如果从白赛尔曲线那边一直研究过来，这句话会好理解一些）。不同的控制点的值*各自定义域内的BasisFunction的值就=不同的B-Spline曲线。控制点的<span class="math inline">\(i\)</span>是和分段对<span class="math inline">\(i\)</span>应的，也就是不同的分段会对应不同的控制值，一旦定义好bspline的初始函数之后，其实在不同定义域内初始函数的响应值是一样的，但是被不同的控制值作用之后就不一样了。</td></tr></tbody></table><h3 id="直观图例">直观图例</h3><p>​下图很直观的表达了B样条曲线的形成过程。注意这里的示意图都是按照<em>Cox-deBoor recursionformula</em>来实现的，因此零次样条线表现出一个反脉冲的形式。</p><p>​ 以一般的基函数如<span class="math inline">\(B_{1,0}(t)\)</span>所示(蓝色)为例，为<strong>0次1阶基函数</strong>在第一段（属于[0,1)区间）的表达，基函数只有在<span class="math inline">\(K_0,K_1\)</span>处的相应为0.0，其他均为1.0。</p><div data-align="center"><img src="/blogs/.io//viz_basis_function.svg" width="100%" height="100%"></div><p>Figure.1 Iterative composition of basis functions. Each segment ofbasis function <span class="math inline">\(B_{i,p}(t)\)</span> iscomposed by its adjacent basis functions in lower degree, which are<span class="math inline">\(B_{i,p-1}(t)\)</span> and <span class="math inline">\(B_{i + 1,p-1}(t)\)</span>. While basis functionsin degree 0 are ==unit square wave signals==. <a href="./B-Spline/viz_basis_function.py">py_code</a></p><div data-align="center"><img src="/blogs/.io//viz_bspline.svg" width="100%" height="100%"></div><p>Figure.2 The point <span class="math inline">\(P_{0,2}\)</span> ofbasis function <span class="math inline">\(B_{0,2}(t)\)</span> (order3,degree 2 and segment 0), is evaluated by the weighted combination of<span class="math inline">\(B_{0,1}(t)\)</span> and <span class="math inline">\(B_{1,1}(t)\)</span>. The weight of each componentis defined by the distance between <span class="math inline">\(P_{0,2}\)</span> and its correspondent knot points(or equivalently linear interpolation). As shown in the figure, the knotvector is <span class="math inline">\([0, 3, 6, 9]^T\)</span>. <a href="./B-Spline/viz_bspline.py">py_code</a></p><div data-align="center"><img src="/blogs/.io//viz_ctrlpt.svg" width="100%" height="100%"></div><p>Figure.3 A B-Spline with degree 2, named <span class="math inline">\(S_2(t)\)</span> is generated by weightedcombinations of all its basis functions. The weight comes from controlpoints, which are <span class="math inline">\([1.2, 0.8, 1.1, 1.2,1.1]\)</span> in the figure. The brown dash lines show how control pointaffect the weight of basis function, these lines finally compose thebrown spline. The knot vector is <span class="math inline">\([0, 1, 2,3, 4, 5, 6, 7]^T\)</span>. <a href="./spline/ctrlpts.py">B-Spline</a></p><h3 id="严格数学定义cox-de-boor-recursion-formula">严格数学定义<em>Cox-deBoor recursion formula</em></h3><h4 id="中文表达">中文表达</h4><p>TODO</p><h4 id="英文表达">英文表达</h4><p>​ Let <span class="math inline">\(\mathbf{K}\)</span> be a set of<span class="math inline">\(m\)</span> non-decreasing numbers, <span class="math inline">\(k_0 \leq k_1 \leq ... \leq k_{m-1}\)</span>. The<span class="math inline">\(k_i\)</span>s are called knot vector, andthe ==half-open interval== [<span class="math inline">\(k_i,k_{i+1}\)</span>) the <span class="math inline">\(i\)</span>-th knot span. Note that since some<span class="math inline">\(k_i\)</span>s may be equal, some knot spans(knot span=<span class="math inline">\(k_i \sim k_{i+1}\)</span>) maynot exist. If the knots are ==equally spaced== (i.e. <span class="math inline">\(k_{i+1}-k_i\)</span> is a constant for <span class="math inline">\((0\leq  i  \leq m-1)\)</span>), the knot vector orthe knot sequence is said ==uniform==; otherwise, it is non-uniform. The<span class="math inline">\(i\)</span>-th B-spline basis function ofdegree <span class="math inline">\(p\)</span>, written as <span class="math inline">\(B_{i,p}(t)\)</span>, is defined recursively asfollows: <span class="math display">\[\begin{align}\label{Cox-de Boor Recursion Formula}B_{i,0}(t)&amp;= \left\{ \begin{array}{cc} 1 &amp; if \quad t_i \leq t\leq t_{i+1} \\\\0 &amp; otherwise \end{array} \right. \\B_{i,p}(t)&amp;=\frac{t-t_i}{t_{i+p}-t_i}B_{i,p-1}(t)+\frac{t_{i+p+1}-t}{t_{i+p+1}-t_{i+1}}B_{i+1,p-1}(t)\end{align}\]</span></p><p>where If the degree is zero (<em>i.e.</em>, <span class="math inline">\(p\)</span> = 0), these basis functions are all<em>step functions</em> <span class="math inline">\(\ref{Cox-de BoorRecursion Formula}\)</span>. Basis function <span class="math inline">\(B_{i,0}(t)\)</span> is 1 if <span class="math inline">\(t\)</span> in the <span class="math inline">\(i\)</span>-th knot span [<span class="math inline">\(k_i,k_{i+1}\)</span>).</p><p>With control points: <span class="math display">\[\begin{align}\label{Cox-de Boor Recursion Formula w gcp}N(t) = \Sigma_{i=0}^{n} P_{i}*B_{i,p}(t)\end{align}\]</span></p><h4 id="推导">推导</h4><p>​推导过程详见<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，通过三角形法则可以不断计算出更高次的基函数的值。虽然比较麻烦，但是思路挺简单的。</p><h3 id="广义矩阵表示">广义矩阵表示</h3><p>​文章<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>使用Toeplitz矩阵将B-spline和Bezier曲线表示为广义矩阵形式。这种表示形式的好处除了更加高效之外，还方便计算导数，方便次数增加和减少任务。</p><p>​ <a href="https://www.cnblogs.com/JingeTU/p/13513011.html">JingeTU</a>对这个文章做了进一步的介绍。但我依然看不懂...</p><h3 id="特性注意点">特性（注意点）</h3><ul><li><p>样条曲线是连续的，而且曲率变化均匀，B-spline在节点处一阶、二阶导数连续，CubicSpline在三阶处的导数也连续</p></li><li><p>the domain is subdivided by knots.整个分布空间定义域所处的domain被knot分割开</p></li><li><p>basis functions are not non-zero on the entire interval. In fact,each B-spline basis function is non-zero on a few adjacent subintervalsand, as a result, B-spline basis functions are quite "local" (<em>localsupport</em>).B-spline的基函数在局部subintervals是非零的，并不是一直有值，也就是k的定义域在1阶0次基函数中是在局部定义域内响应的</p></li><li><p><span class="math inline">\(u_i\)</span> is a <em>multipleknot</em> of <em>multiplicity</em> <em>k</em>, written as <span class="math inline">\(u_i(k)\)</span>. knot 是可以重复存在的，knotvector是全部knot组成的，knot其实是预先设定好的，在既定位置上存在的点。</p></li><li><p>Basic function <span class="math inline">\(B_{i,p}(t)\)</span> isnon-zero on [<span class="math inline">\(k_i,k_{i+p+1}\)</span>). Or,equivalently, <span class="math inline">\(B_{i,p}(t)\)</span> isnon-zero on <span class="math inline">\(p+1\)</span> knot spans.想要找到高次基函数所对应的非零区间，可以用三角形法则反向查找，所对应的区间加起来就是其所对应的非零区间<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，随着阶数的升高，k对应的定义域是在不断变化的，<span class="math inline">\(k \in \left[ k_i, k_{i+p+1}\right)\)</span>.</p></li><li><p>On any knot span [<span class="math inline">\(k_i,k_{i+1}\)</span>), at most <span class="math inline">\(p+1\)</span> degree <span class="math inline">\(p\)</span> basis functions are non-zero.可以根据subinterval区间找到哪些高次基函数是非零的</p></li><li><p>给定knot vector <span class="math inline">\(\mathbf{K}\)</span>和阶数<span class="math inline">\(n\)</span>，每段函数在knot节点处的连续性等于<span class="math inline">\(C^{n-2}\)</span></p></li><li><p>生成B-Spline时，所需knots的数量m和阶数n,以及控制点的数量有关。即<code>m=n+1+控制点数量</code></p></li><li><p>B-Spline 分为opened和clamped两种，区别在于是否是B-Spline通过起始点和终止点。前者否，后者是</p></li></ul><h3 id="可视化">可视化</h3><ul><li>一个直观的基于Web的Spline可视化<a href="https://spline.technology/demo/">界面</a>。手动选择knot可直接显示Spline，可以移动knot。</li><li>C++版基于OpenGL实现的Spline可视化<a href="https://github.com/arthurcgc/splines">代码</a>，但是没测试过。</li><li>医学图像领域基于TPS实现图片编辑的<a href="https://github.com/dg1an3/WarpTPS">vs工程</a>。</li><li>A tool for interactive interpolation of splines. Select any pointsand visualize how different splines are modelled. <a href="https://github.com/absdnd/Interactive_Interpolation">对比不同曲线之间的差异</a>。带界面，推荐。</li><li><a href="https://github.com/whu-lyh/B-spline-Curves-and-Surfaces">MATLAB版本</a>的绘制B-spline曲线和表面的。对于MATLAB用户来说非常好用。下面是两个实例结果，非常直观形象。就是拟合大数据的时候会比较慢。不过作为示意图够使用了。</li></ul><div data-align="center"><img src="/blogs/.io//B-spline Least Square Fitting.png" width="100%" height="100%"></div><div data-align="center">使用不同次数的基函数对数据进行最小二乘拟合的结果</div><div data-align="center"><img src="/blogs/.io//B-spline Least Square Fitting2.png" width="100%" height="100%"></div><div data-align="center">knot非均匀分布下分段多边形函数以及对应的B-Spline函数</div><ul><li>基于<a href="https://github.com/marlinilram/vtkFiltersBezier">VTK</a>实现的Spline可视化，包含TPS等样条曲线。</li><li>pySpline produces B-spline curves, surfaces, and volumes一个基于<a href="https://github.com/mdolab/pyspline">python</a>的，但是目前没有环境，没有测试。</li></ul><h2 id="references">References</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">https://xiaoxingchen.github.io/2020/03/02/bspline_in_so3/<a href="#fnref:1" rev="footnote">↩︎</a></li><li id="fn:2">样条曲线的次数和阶数分别是什么意思，能举例说明一下吗？ - potato的回答 -知乎https://www.zhihu.com/question/43028324/answer/399976433<a href="#fnref:2" rev="footnote">↩︎</a></li><li id="fn:3">https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-basis.html<a href="#fnref:3" rev="footnote">↩︎</a></li><li id="fn:4">Qin K. General matrix representations for B-splines[C]//ProceedingsPacific Graphics' 98. Sixth Pacific Conference on Computer Graphics andApplications (Cat. No. 98EX208). IEEE, 1998:37-43.<a href="#fnref:4" rev="footnote"> ↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> MathUtilities </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B-Spline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMU</title>
      <link href="/blogs/2025/01/15/IMU/"/>
      <url>/blogs/2025/01/15/IMU/</url>
      
        <content type="html"><![CDATA[<p>IMU主要由加速度计和陀螺仪构成，因此IMU中包含的原始数据是角速度和线加速度，包含timestampang_vel_x ang_vel_y ang_vel_z lin_acc_x lin_acc_ylin_acc_z，然后通过积分的方式得到__orientation__,<strong>position</strong>,__velocity__信息。</p><ul><li>3轴IMU即只有3轴陀螺仪的IMU，其因为只有一个3轴陀螺仪，所以只能感知载体roll、pitch、yawl共3个自由度的姿态信息。</li><li>6轴IMU在3轴IMU的基础上加装了3轴加速度计，因此在感知载体姿态的基础上，还能感知载体3个自由度上的加速度信息。</li><li>9轴IMU在6轴IMu的基础上加装了3轴磁强计，由于3轴陀螺仪只能估计载体自身的相对位姿变化（通过加速度计也可获得载体的绝对roll和pitch），单凭3轴陀螺仪无法获取载体的全部姿态信息，而通过3轴磁强计就可以，本质上磁强计的感知原理类似于指南针。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激光雷达传感器</title>
      <link href="/blogs/2025/01/15/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
      <url>/blogs/2025/01/15/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="记录几种常见的激光雷达类型">记录几种常见的激光雷达类型</h2><p>机械式、固态式、半固态、单线激光雷达</p><a id="more"></a><h3 id="禾赛pandar40">禾赛Pandar40</h3><p>从下图可以看出它的线束在纵向方向是不均匀分布的。</p><p><img src="/blogs/.io//Pandar40.png"></p><p>其基本参数如下所示：</p><p><img src="/blogs/.io//Pandar40_parameter.png"></p><h3 id="mid360">MID360</h3><p><video src="./激光雷达传感器/MID360.mp4" controls><a href="./激光雷达传感器/MID360.mp4">Video</a></video></p><h3 id="不同类型传感器获取的数据对比">不同类型传感器获取的数据对比</h3><p><img src="/blogs/.io//Livox-VLP-Comparsion%20Spherical%20projection%20results%20of%20different%20LiDARs%20within%200.1%20second%20integration%20time.jpg"></p><h3 id="单线激光雷达">单线激光雷达</h3><p><img src="/blogs/.io//RIEGL_VMQ-1HA.png"></p>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光雷达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>loss functions</title>
      <link href="/blogs/2023/12/27/loss-functions/"/>
      <url>/blogs/2023/12/27/loss-functions/</url>
      
        <content type="html"><![CDATA[<p>一些常见的损失函数调包就行，复杂的得自己写。损失函数中没有可训练的参数，因此通常直接使用<code>torch.nn.functional</code>中的函数即可。例如一些简单的损失函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br>cls_criterion = nn.CrossEntropyLoss()<br>dist_criterion = nn.MSELoss()  <span class="hljs-comment"># Use L2 loss function</span><br>hinge_criterion = nn.HingeEmbeddingLoss()<br></code></pre></td></tr></table></figure><p>还可以参照<a href="https://github.com/whu-lyh/pytorch-metric-learning">pytorch-metric-learning</a>这个库</p><a id="more"></a><h3 id="sigmoid">Sigmoid</h3><ul><li>准确的来说他不是损失函数，是激活函数，用来提升非线性的，但是后面常用，e.g.softmax中有，因此先学习一下。</li></ul><figure><img src="/blogs/.io//sigmoid_softmax.png" alt="Sigmoid数学公式"><figcaption aria-hidden="true">Sigmoid数学公式</figcaption></figure><figure><img src="/blogs/.io//sigmoid_softmax2.png" alt="Sigmoid2"><figcaption aria-hidden="true">Sigmoid2</figcaption></figure><h3 id="nll_loss">nll_loss</h3><p>负对数似然损失函数(Negtive Log Likehood)，对应多分类问题： <span class="math display">\[nll\_loss = -\frac{1}{N}\Sigma_{i=1}^N \mathcal{y}_i (logsoftmax)\]</span> 其中<span class="math inline">\(y_i\)</span>是==one_hot==编码后的数据标签，NLLLoss()得到的结果即是<span class="math inline">\(y_i\)</span>与logsoftmax()激活后的结果相乘再求均值再取反。（实际在用封装好的函数时,传入的标签无需进行one_hot编码）</p><ul class="task-list"><li><label><input type="checkbox" checked>==ont_hot==：在多分类(不是多标签分类)任务中，标签不在是二值量。需要将原来的一个标量，表示为向量，只有对应位置处的值为1，其他都是0，确保加和为1.</label></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">target = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>])<br>one_hot = F.one_hot(target).<span class="hljs-built_in">float</span>()<br>&gt;&gt;&gt; print(one_hot)<br>tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])<br></code></pre></td></tr></table></figure><h3 id="softmax">Softmax</h3><p>从<strong>argmax</strong>-&gt;<strong>softargmax</strong>-&gt;<strong>softmax</strong>而来，目的是为了找到一个数列中的最大值，在分类任务中找到概率做大的那个类就是分类的结果。softmax是指数标准化函数，又称为归一化指数函数，将多个神经元的输出，映射到(0,1)范围内的K维向量，并且归一化保证和为1，从而使得多分类的概率之和也刚好为1。<a href="https://www.zhihu.com/question/358069078/answer/912691444">数学原理</a>如下：<span class="math display">\[Softmax(\mathcal{z}_i)=\frac{\exp (\mathcal{z}_i)}{\Sigma_j \exp(\mathcal{z}_j)}\]</span> <span class="math inline">\(\mathcal{z}_j\)</span>非常大或者非常小的时候就会导致指数计算出现上溢出和下溢出的问题。那么就可以统一对z的取值进行修改，比如减去<span class="math inline">\(c=max(z)\)</span>，这样就不会上溢出了。但是还存在下溢出，通过数值计算中的等式变换避免下溢出的情况，即使用log函数进行变换。实际计算softmax的方式就变成如下<strong>logsoftmax</strong>形式，同时保证和为1.<span class="math display">\[\begin{align}Log(Softmax(\mathcal{z}_i))&amp;=Log (\frac{\exp(\mathcal{z}_i-c)}{\Sigma_j \exp (\mathcal{z}_j-c)}) \&amp;= (\mathcal{z}_i-c)-Log(\Sigma_j \exp(\mathcal{z}_j)-c)\end{align}\]</span></p><h3 id="binary-cross-entropy">Binary Cross-Entropy</h3><p><a href="http://t.csdn.cn/IWfMo">用于二分类任务，针对每个输入样本</a>，计算预测的概率和真实标签之间的不相关性。<code>torch.nn.BCELoss</code>。<span class="math display">\[L = -\left(y_{\text{true}} \cdot \log(y_{\text{pred}}) + (1 -y_{\text{true}}) \cdot \log(1 - y_{\text{pred}})\right)\]</span> <span class="math inline">\(y_{true}\)</span>表示真实二值标签，要么0要么1，<span class="math inline">\(y_{pred}\)</span>表示正确类的预测概率，可以先用sigmoid将每个神经元输出的logits值归一化到[0,1]区间成为概率，这里不保证所有的值加起来等于1。函数输入是(B,C)的向量矩阵，表示B个样本、C个类别和(B,C)个二值标签。</p><h3 id="cross-entropy-loss">Cross-Entropy loss</h3><p>交叉熵主要用于多分类任务。<code>torch.nn.CrossEntropyLoss()</code>。交叉熵公式表示如下：<span class="math display">\[H(p,q)=-\Sigma_i P(i)\log Q(i)\]</span> 发现<span class="math inline">\(H(p,q)\)</span>的计算不依赖于<span class="math inline">\(P\)</span>矩阵，而仅仅与<span class="math inline">\(P\)</span>的真实类别的index有关。</p><p><a href="https://zhuanlan.zhihu.com/p/159477597">当input满足一定条件时，nll_loss和torch.nn.CrossEntropyLoss()是等价的</a>。交叉熵是定义在两个one-hot向量之间的，更具体地说是定义在两个概率向量之间nll是定义在一个模型上的，取决于模型本身可以取不同的形式。<strong>步骤</strong>：1）将预测的值通过softmax进行归一化保证无上溢出问题；2）再log运算保证无下溢出问题；3）最后与真值计算负对数似然损失。</p><p>pytorch官网给出了很好的解释：</p><ul><li><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html">实际代码实现</a>中就是将nnl_loss和log_softmax（可以认为就是归一化得到0-1概率值的过程）的结果进行了结合。</p></li><li><p>不需要对输入的标签进行==one_hot==编码，只需要<a href="https://blog.csdn.net/wuliBob/article/details/104119616">输入对应的真实标签</a>==（标量）==，内部自动one_hot。</p></li><li><p>还可以在计算误差是对每个类别进行加权，只需要传入一个权重矩阵就行。</p></li><li><p>传入的logits值不需要进行<strong>归一化</strong>（<strong>但是实际使用来看，还是归一化比较好</strong>），也不需要是正数，或者加起来和为1。</p></li><li><p>输出的结果依据input来，如果是一个C，那么输出就是一个标量，如果传入的是一个batch的数据，那么输出就是B个值。其他见<a href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html">官方说明</a>。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>target = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment"># 标签 这里还有一个torch.tensor与torch.Tensor的知识点https://blog.csdn.net/weixin_40607008/article/details/107348254</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>one_hot = F.one_hot(target).float() <span class="hljs-comment"># 对标签进行one_hot编码</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>softmax = torch.exp(x)/torch.sum(torch.exp(x), dim = <span class="hljs-number">1</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>logsoftmax = torch.log(softmax)<br><span class="hljs-meta">&gt;&gt;&gt; </span>nllloss = -torch.sum(one_hot*logsoftmax)/target.shape[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>nllloss<br>tensor(<span class="hljs-number">1.8566</span>)<br><span class="hljs-comment">###下面用torch.nn.function实现一下以验证上述结果的正确性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>logsoftmax = F.log_softmax(x, dim = <span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>nllloss = F.nll_loss(logsoftmax, target) <span class="hljs-comment"># 无需对标签做one_hot编码</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>nllloss<br>tensor(<span class="hljs-number">1.8566</span>)<br><span class="hljs-comment">###最后我们直接用torch.nn.CrossEntropyLoss验证一下以上两种方法的正确性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cross_entropy = F.cross_entropy(x, target)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cross_entropy<br>tensor(<span class="hljs-number">1.8566</span>) <span class="hljs-comment">#发现是一样的</span><br></code></pre></td></tr></table></figure><h3 id="triplet-loss">Triplet loss</h3><p>公式详见点云定位的docx文档。<code>torch.nn.TripletMarginLoss</code>。</p><p>需要注意正负样本的选择，有不同的方式，比较常见的有两种:</p><ul><li><p>一种是off-line提前计算好，这种方式需要依赖数据集中的其他信息，例如坐标，因此还是属于有监督学习的范畴;</p></li><li><p>一种是online利用网络提取的特征进行动态分类，如困难样本挖掘，这种方式训练会耗时一些，但是性能是最最优的。</p></li><li><p>该函数支持多个负样本的计算，其实就是循环，如果把每个负样本的损失计算单独拎出来，结果是一样的。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">criterion = nn.TripletMarginLoss(margin=margin_value, p=<span class="hljs-number">2</span>, reduction=<span class="hljs-string">'sum'</span>)<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(negCount):<br> negIx = (torch.sum(negCounts[:i]) + n).item()<br> loss += criterion(anchor[i: i + <span class="hljs-number">1</span>], positives[i: i + <span class="hljs-number">1</span>], negatives[negIx:negIx + <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h3 id="infonce">InfoNCE</h3><p>全称：Information Noise-Contrastive Estimation。 是Noise-ContrastiveEstimation的改进版。最初是在MoCo一文中了解到的。因为MoCo将多模态学习表达为了字典查询问题，因此可以这么说InfoNCEloss can also be interpreted as a kind of classification, where you haveK-1 negative classes and 1 positive class</p><ul><li>目的是为了通过优化的方式最大化多模态特征之间的互信息，从而使得隐向量表达多个模态之间的公有表征。The。</li><li>相比NCE 损失，可以避免图像数量太多导致的softmax无法计算问题。</li><li>其使用mini-batch内的其他样本直接作为负样本。常见于对比学习的loss中，对比学习中假设一个anchor对应一个postive，那么这种方式就存在一些问题，比如恰好找到了相邻位置的正样本，使得所谓的负样本其实是正样本来的。因此有一些工作对此进行了改进，如CWCL。</li></ul><p>在多模态对比学习任务中，优化Info-NCE损失函数可以理解为最大化两个模态互信息的下界，使得隐藏层更能包含两个模态的共有信息。公式表达如下：<span class="math display">\[\mathcal{L}_{Info\_NCE}=-log \Large( \frac{\exp (q \cdot k ^+/\tau)}{\exp (q \cdot k ^+ /\tau)+\Sigma_{k^-}\exp (q \cdot k ^-/\tau)})\]</span> <span class="math inline">\(q,k^+,k^-\)</span>，分别表示query、positive，negative<strong>s</strong>的特征，负样本可有多个。特征向量之间的点乘表示两个特征之间的相似性。使用了softmax的思路进行标准化，实际使用时：就是准备好正负样本对之后，使用Cross-Entropy进行分类的。</p><h3 id="实际问题">实际问题</h3><ul class="task-list"><li><label><input type="checkbox" checked>loss波动很厉害是为什么呢？batch_size小的时候，波动厉害是正常的，还有一种情况就是学习率太高了，导致有问题。<strong>thetraining loss oscillates and fails to converge</strong>.</label></li><li><label><input type="checkbox" checked>可能需要固定一些tokenizar，不然训练会不稳定。</label></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLS position inconsistency correction</title>
      <link href="/blogs/2023/09/30/MLS-position-inconsistency-correction/"/>
      <url>/blogs/2023/09/30/MLS-position-inconsistency-correction/</url>
      
        <content type="html"><![CDATA[<p>Supplementary video of paper "MuCoGraph: A Multi-scale ConstraintEnhanced Pose Graph Framework for MLS Point Cloud InconsistencyCorrection", Accepted by Journal of Photogrammetry and Remote SensingSCI1-TOP, IF=12.7.</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=448787968&amp;bvid=BV1Lj411C7NV&amp;cid=1276019175&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" controls="controls" loop="loop"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 专业应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux BoostUp</title>
      <link href="/blogs/2023/09/25/Linux-BoostUp/"/>
      <url>/blogs/2023/09/25/Linux-BoostUp/</url>
      
        <content type="html"><![CDATA[<h1 id="common-product-tool">Common Product Tool</h1><h2 id="gpu-burn">GPU-Burn</h2><ul><li>GPU压力测试。</li></ul><h2 id="tmux">Tmux</h2><ul><li>Linux终端，一个好处是只需要开一个终端window就可以通过tmux开很多个pane这样，通过tab切换不同的应用程序，使用pane在一个窗口内切换不同的pane。</li><li>tmux可以在后台运行，即使关闭终端window，后台的程序也不会断开。</li></ul><h3 id="安装方法">安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install -y tmux<br></code></pre></td></tr></table></figure><h3 id="使用">使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个后台终端</span><br>tmux new -t <span class="hljs-string">"session name"</span><br><span class="hljs-comment"># 附加在现存的终端上</span><br>tmux attach -t <span class="hljs-string">"session name"</span><br><span class="hljs-comment"># 列出所有的session</span><br>tmux ls<br><span class="hljs-comment"># 关闭session</span><br>tmux <span class="hljs-built_in">kill</span>-session -t <span class="hljs-string">"session name"</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="其他快捷键">其他快捷键</h3><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr><th>key</th><th>what it does</th></tr></thead><tbody><tr><td>ctrl-b, %</td><td>split the screen in half from left to right</td></tr><tr><td>ctrl-b, "</td><td>split the screen in half from top to bottom</td></tr><tr><td>ctrl-b, x</td><td>kill the current pane</td></tr><tr><td>ctrl-b, <arrow key>上下键</arrow></td><td>switch to the pane in whichever direction you press</td></tr><tr><td>ctrl-b, d</td><td>detach from tmux, leaving everything running in the background</td></tr><tr><td>ctrl-b(按住), <arrow key>方向键</arrow></td><td>adjust the size of the pane</td></tr><tr><td>ctrl-b,[</td><td>make the mouse scrolling enable</td></tr></tbody></table><p>其他更多快捷键，参见<a href="https://gist.github.com/MohamedAlaa/2961058">github-tmux-cheatsheet</a>。</p><h3 id="一些小问题">一些小问题</h3><ul class="task-list"><li><label><input type="checkbox" checked>vscode远程连接服务器，总是提示断开。测试过的方案有：根据提示在ssh的config文件中添加如下，使得vscode每隔60s就像服务器发送一个信号，这样就不会断开了。(但是似乎没什么用？)</label></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ServerAliveInterval 60<br>ServerAliveCountMax 3<br></code></pre></td></tr></table></figure><p>正确的解决方案应该是，由于服务器采用本地集群的方式开放了一个公网端口，使用ssh连接非常容易出现断联的情况，因此应该使用<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">tmux</a>构建进程，使得进程在服务器本地运行，使得进程和本地窗口解除绑定，这样运行的程序就是在远端的本地进行的。</p><h2 id="top">TOP</h2><p>显示了系统总体的 CPU和内存使用情况，以及各个进程的资源使用情况。详情见<a href="https://www.seozen.top/linux-learning-top-command.html#:~:text=Linux%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8BTOP%E5%91%BD%E4%BB%A4%201%20%E4%BD%BF%E7%94%A8top%20%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E8%A6%81%E6%9F%A5%E7%9C%8B%E4%B8%8Btop%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E%EF%BC%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%BE%93%E5%85%A5%20top%20-v%20%E7%9C%8B%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84Linux%E5%AE%89%E8%A3%85%E7%9A%84TOP%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E7%89%88%E6%9C%AC%EF%BC%9A%20%5Broot%40SEOZEN,...%204%20TOP%E5%86%85%E7%9A%84%E6%93%8D%E4%BD%9C%20%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%20-%E9%80%9A%E8%BF%87%E9%94%AE%E7%9B%98%E4%B8%8A%E4%B8%8B%E7%AE%AD%E5%A4%B4%E6%9D%A5%E7%A7%BB%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82%20%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%20-%E9%80%9A%E8%BF%87%E9%94%AE%E7%9B%98%E5%B7%A6%E5%8F%B3%E7%AE%AD%E5%A4%B4%E6%9D%A5%E7%A7%BB%E5%8A%A8%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E5%88%97%E4%BF%A1%E6%81%AF%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E7%9A%84%E8%A1%8C%E6%98%BE%E7%A4%BA%E5%A4%AA%E9%95%BF%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%9F%A5%E7%9C%8B%E3%80%82%20">这里</a>。</p><p>不需要安装，默认Ubuntu自带。常见缩写， 涉及Linux cpu<a href="https://www.cnblogs.com/chenxiba/p/11311125.html">负载相关知识</a>：</p><blockquote><p><strong>Idle</strong>： 处于空闲状态，没有任务需要调度。</p><p><strong>id</strong>：空闲状态的时间占比。</p><p><strong>avg</strong>：？？</p><p><strong>sy</strong>：内核态代码的运行时间比，sy高说明内核占用太多资源，或者用户进程发起了太多的系统调用。</p><p><strong>ni</strong>：niceness不为0的进程代码运行时间比，默认情况下，进程的niceness值都为0，但可以通过命令nice来启动一个进程并指定其niceness值，niceness的取值范围是-20到19，值越小，表示优先级越高，越优先被内核调度。</p><p><strong>hi</strong>&amp;<strong>si</strong>：这两个值反映了CPU有多少时间花在了中断处理上，hi（hardwareinterrupts）是硬件中断，si(softirqs)是软件中断。硬件中断一般由I/O设备引起，如网卡、磁盘等，发生硬件中断后，CPU需要立即处理，当硬件中断中需要处理的事情很多时，内核会生成相应的软中断，然后将耗时且不需要立即处理完成的操作放在软中断中执行，比如当网卡收到网络包时，需要CPU立即把数据拷贝到内存中去，因为网卡自带的缓存较小，如果不及时处理的话后面的数据包就进不来，导致丢包，当数据拷贝到内存中之后，就不需要那么着急的处理了，这时候可以将处理数据包（协议栈）的代码放在软中断中执行。</p><p><strong>wa</strong>：处于I/O等待状态的时间占比。通常情况下，当CPU遇到一个I/O操作时，会先触发I/O操作，然后去干别的，等I/O操作完成后，CPU再接着继续工作，但如果这时系统比较空闲，CPU没有别的事情可以做，那么CPU将处于等待状态，这种处于等待状态的时间将会被统计进I/Owait，也就是说CPU处于I/Owait状态即CPU闲着没事干在等I/O操作结束，和idle几乎是一样的。这个值高说明CPU闲且I/O操作多或者I/O操作慢，但低并不能说明没有I/O操作或者I/O操作快，有可能是CPU在忙别的，所以这只是一个参考值，需要和其他的统计项一起来分析。</p></blockquote><h3 id="使用-1">使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br></code></pre></td></tr></table></figure><h2 id="htop">Htop</h2><ul><li>相比<a href="https://www.seozen.top/linux-learning-top-command.html#:~:text=Linux%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8BTOP%E5%91%BD%E4%BB%A4%201%20%E4%BD%BF%E7%94%A8top%20%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E8%A6%81%E6%9F%A5%E7%9C%8B%E4%B8%8Btop%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E%EF%BC%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%BE%93%E5%85%A5%20top%20-v%20%E7%9C%8B%E7%9C%8B%E8%87%AA%E5%B7%B1%E7%9A%84Linux%E5%AE%89%E8%A3%85%E7%9A%84TOP%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E7%89%88%E6%9C%AC%EF%BC%9A%20%5Broot%40SEOZEN,...%204%20TOP%E5%86%85%E7%9A%84%E6%93%8D%E4%BD%9C%20%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%20-%E9%80%9A%E8%BF%87%E9%94%AE%E7%9B%98%E4%B8%8A%E4%B8%8B%E7%AE%AD%E5%A4%B4%E6%9D%A5%E7%A7%BB%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%85%B6%E5%AE%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82%20%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%20-%E9%80%9A%E8%BF%87%E9%94%AE%E7%9B%98%E5%B7%A6%E5%8F%B3%E7%AE%AD%E5%A4%B4%E6%9D%A5%E7%A7%BB%E5%8A%A8%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E5%88%97%E4%BF%A1%E6%81%AF%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E7%9A%84%E8%A1%8C%E6%98%BE%E7%A4%BA%E5%A4%AA%E9%95%BF%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%9F%A5%E7%9C%8B%E3%80%82%20">top</a>，<a href="https://htop.dev/">htop</a>可以看到更加丰富的CPU信息。</li></ul><h3 id="安装方法-1">安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install htop<br></code></pre></td></tr></table></figure><h3 id="使用-2">使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">htop<br></code></pre></td></tr></table></figure><p>示例图如下所示：</p><p><img src="/blogs/.io//htop.jpg"></p><h3 id="其他快捷键-1">其他快捷键</h3><ul><li><p>通过F2可以实现进阶操作，比如修改配色，在F2之后的color界面，通过鼠标或者键盘上下键可以切换颜色，比如Brokengray就比默认颜色更好一些。</p></li><li><p>ESC可以退出编辑。在htop界面都有写。</p></li><li><p>查看硬盘IO，htop同样可以参考<a href="https://zhuanlan.zhihu.com/p/635742724">这里</a>可以实现。（本身top是可以的，此外有iotop这样的软件可以用）。</p><ul><li><p>F2-&gt;Setup-&gt;Display Option，点击空格选中“Detailed CPUtime”；</p></li><li><p>选择Setup-&gt;Meters，使用右箭头和上下箭头键，选中Availablemeters-&gt;CPU average计数器，添加到Right column；</p></li><li><p>在Rightcolumn中添加后，用上下箭头、回车调整位置，然后按空格，修改计数器类型为CPU(Text)。</p></li></ul></li></ul><p>之后在htop中就会出现如下所示的栏，表示硬盘io率。</p><figure><img src="/blogs/.io//htop-io.png" alt="image-20231009151319057"><figcaption aria-hidden="true">image-20231009151319057</figcaption></figure><ul><li>设置完之后还需要保存设置，才能在下一次打开htop时保持和之前一样的设置。但是我设置F10没有用。</li></ul><h2 id="ubuntu20.04自带的system-monitor">Ubuntu20.04自带的SystemMonitor</h2><ul><li>其实自带的就很好用，那些花里胡哨的反而比较麻烦。可以看系统，进程，和文件系统。</li></ul><p><img src="/blogs/.io//system_monitor.jpg"></p><h2 id="lm-sensors">lm-sensors</h2><ul><li>用于<a href="https://www.cyberciti.biz/faq/install-sensors-lm-sensors-on-ubuntu-debian-linux/">查看风扇温度</a>，比如新装了电脑如果CPU支持超频，那么打开CPU超频的话就会导致水冷风扇转速和降温效果达到最高，甚至有点异响。或者用于检查其他硬件是否有问题。</li></ul><h3 id="安装方法-2">安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install lm-sensors<br></code></pre></td></tr></table></figure><h3 id="使用-3">使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sensors<br></code></pre></td></tr></table></figure><p>就会得到如下的显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">coretemp-isa-0000 <span class="hljs-comment"># CPU内核温度</span><br>Adapter: ISA adapter<br>Package id 0:  +47.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 0:        +32.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 1:        +33.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 2:        +33.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 3:        +35.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 4:        +31.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 5:        +47.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 6:        +34.0°C  (high = +100.0°C, crit = +100.0°C)<br>Core 7:        +33.0°C  (high = +100.0°C, crit = +100.0°C)<br><br>acpitz-acpi-0<br>Adapter: ACPI interface<br>temp1:        +27.8°C  (crit = +105.0°C)<br><br>iwlwifi_1-virtual-0 <span class="hljs-comment">#Intel WiFi温度数据</span><br>Adapter: Virtual device<br>temp1:        +40.0°C  <br><br>nvme-pci-0500 <span class="hljs-comment"># GPU温度</span><br>Adapter: PCI adapter<br>Composite:    +41.9°C  (low  = -273.1°C, high = +81.8°C)<br>                       (crit = +84.8°C)<br>Sensor 1:     +41.9°C  (low  = -273.1°C, high = +65261.8°C)<br>Sensor 2:     +47.9°C  (low  = -273.1°C, high = +65261.8°C)<br></code></pre></td></tr></table></figure><h2 id="filezilla">Filezilla</h2><ul><li>往已知IP的远程服务器上传输大量的数据。</li></ul><h3 id="安装方法-3">安装方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install filezilla<br></code></pre></td></tr></table></figure><h3 id="使用方法">使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">filezilla<br></code></pre></td></tr></table></figure><ul><li>可以调整文件传输并行线程数。</li><li>不同平台的文件编码方式差异导致文件传输之后无法识别的问题。<ul><li>文本文件中出现很多空行，<a href="https://blog.csdn.net/zhang01457/article/details/103418071">解决方案</a>：传输的文件类型需要按照二进制的方式进行传输</li><li>sh文件无法识别，<a href="https://blog.csdn.net/JoeChao1003/article/details/82596244">解决方案</a>，<code>sed -i "s/\r//" *.sh</code></li></ul></li></ul><h2 id="putty">Putty</h2><ul class="task-list"><li><label><input type="checkbox" checked>除了使用filezilla还可以使用putty和服务器之间传输数据，也很方便，比如传文件<code>pscp -r 目录 用户名@LinuxIP:目录</code>，也可以有界面</label></li></ul><h2 id="vscode服务器连接">VSCode服务器连接</h2><ul class="task-list"><li><label><input type="checkbox" checked>服務器上輸出了loss等日誌，但是沒有開tensorboard的結構，如何通過ssh訪問呢？解決方案參考<a href="https://blog.yyliu.net/remote-tensorboard/">這裏</a>：</label></li></ul><p>在本地雞上使用<code>ssh -L 10008:127.0.0.1:10008 root@IP</code>將服務器的端口映射到本地，（windows不需要这一步就可以做到，直接vscode连接了之后就行）</p><p>在服務器上使用<code>tensorboard --logdir='/root/lyh/code/AE-CrossModal/log/checkpoints/May17_11_25_14_spherical' --port=10008</code>打開tensorboard。</p><p>這樣本地才能通過瀏覽器http://localhost:10008看到。</p><h2 id="fuser">fuser</h2><h2 id="git">Git</h2><p>出现代码没有修改，但是<code>git diff</code>提示很多改动。如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">old <span class="hljs-keyword">mode</span> <span class="hljs-number">100755</span>  <br><span class="hljs-keyword">new</span> <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span><br></code></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/1257592/how-do-i-remove-files-saying-old-mode-100755-new-mode-100644-from-unstaged-cha">解决方案</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config core.filemode false<br></code></pre></td></tr></table></figure><p>Git推送代码时出现问题，<a href="https://stackoverflow.com/questions/20168639/git-commit-get-fatal-error-fatal-crlf-would-be-replaced-by-lf-in">fatal:CRLF would be replaced by LF in</a>:</p><p>解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.autocrlf <span class="hljs-literal">false</span><br>git config --global core.safecrlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>Github中存储大量的数据，如何快速下载？</p><p>解决方案：因为大文件使用的是LFS，是Git Large FileStorage（LFS），因此需要在Git安装并配置好SSH密钥，连接到GitHub、huggingface或其他代码仓库。</p><ul><li>LINUX系统：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash<br>sudo apt-get install git-lfs<br>git lfs install<br></code></pre></td></tr></table></figure><p>也可以通过软件包管理器（如yum或apt）安装Git LFS。</p><ul><li>Windows系统：</li></ul><p>直接：<code>git lfs install</code>如果显示Git LFSinitialized说明已经OK。然后再git clone就行了。</p><h2 id="huggingface如何快速下载数据">HuggingFace如何快速下载数据</h2><p>使用官方huggingface_hub可以更加高效一些，然后在使用的时候再从本地加载。github一个下载加速的快捷工具<strong><a href="https://github.com/LetheSec/HuggingFace-Download-Accelerator">HuggingFace-Download-Accelerator</a></strong>。</p><p>首先安装huggingface_hub，但是这个安装的时候与网络有很大的关系，很容易出现网络错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -U huggingface_hub<br></code></pre></td></tr></table></figure><p>命令行下载：(比如下载CV-Cities数据集)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python hf_download.py --dataset gaoshuang98/CV-Cities --save_dir ../CV-Cities --use_mirror True --use_hf_transfer False<br></code></pre></td></tr></table></figure><ul><li>如果下载失败了之后，重新运行的话，还可以续下。</li></ul><p>如果是需要在代码中下载权重，那么在pythonxx.py之前添加<code>HF_ENDPOINT=https://hf-mirror.com</code>可以提升下载速度。然后再转到本地存储下来避免二次下载。</p><h2 id="pip库安装">pip库安装</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pip cache <span class="hljs-builtin-name">remove</span> *<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>删除下载文件时的缓存</label></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>使用国内的云服务，速度大大提升。</label></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ImportError: libGL.so.1: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked><a href="https://stackoverflow.com/questions/55313610/importerror-libgl-so-1-cannot-open-shared-object-file-no-such-file-or-directo">解决方案</a>：<code>apt-get install -y libgl1</code></label></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ImportError: libgthread-2.0.so.0: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked><a href="https://askubuntu.com/questions/1060903/importerror-libgthread-2-0-so-0-cannot-open-shared-object-file-no-such-file-o">解决方案</a>：<code>apt-get install -y libglib2.0-0</code></label></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">libX11.so.6: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>解决方案：<code>apt install -y 0</code></label></li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">ValueError: setting an<span class="hljs-built_in"> array </span>element with a sequence. The requested<span class="hljs-built_in"> array </span>has an inhomogeneous shape after 1 dimensions<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>降低numpy版本，可能是numpy的bug。numpy1.24.3有bug，1.21.6就无了。</label></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">RuntimeError:</span> cuDNN <span class="hljs-string">error:</span> CUDNN_STATUS_INTERNAL_ERROR<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>这个错误有可能是因为GPU显存不够了。调整网络结构或者减少batch_size才行。</label></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">RuntimeError: Ninja <span class="hljs-keyword">is</span> required <span class="hljs-keyword">to</span> <span class="hljs-keyword">load</span> C++ extensions<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>解决方案：<code>pip install ninja</code></label></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">libcudart.<span class="hljs-keyword">so</span>.12: cannot <span class="hljs-keyword">open</span> shared object <span class="hljs-keyword">file</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br></code></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked>解决方案：在对应路径下面找到相应的版本，替换就行。比如<code>sudo ldconfig /usr/local/cuda-10.2/lib64</code></label></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KL-divergence</title>
      <link href="/blogs/2023/09/21/KL%20Divergence/"/>
      <url>/blogs/2023/09/21/KL%20Divergence/</url>
      
        <content type="html"><![CDATA[<p>动量蒸馏中用到了</p><p>点云配准</p><p>Jenson-Shannon divergence</p>]]></content>
      
      
      <categories>
          
          <category> MathUtilities </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathemetics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker深度学习</title>
      <link href="/blogs/2023/04/17/Docker%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/blogs/2023/04/17/Docker%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ul><li>感谢卢指导！</li><li>安装出现错误<a href="https://jdhao.github.io/2022/05/05/nvidia-apt-repo-public-key-error-fix/">GPGErr</a>解决方案为：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm /etc/apt/sources.list.d/cuda.list<br>rm /etc/apt/sources.list.d/nvidia-ml.list<br>apt-key del 7fa2af80<br>apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/3bf863cc.pub<br>apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64/7fa2af80.pub<br></code></pre></td></tr></table></figure><h2 id="docker-安装">Docker 安装</h2><h3 id="docker-安装-1">1. Docker 安装</h3><h4 id="卸载旧版本">1.1 卸载旧版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove docker docker-engine docker.io<br></code></pre></td></tr></table></figure><h4 id="安装依赖项">1.2 安装依赖项</h4><p>由于 <code>apt</code> 源使用 HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS传输的软件包以及 CA 证书。 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> update<br>sudo apt-<span class="hljs-builtin-name">get</span> install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure></p><h4 id="添加源和密钥">1.3 添加源和密钥</h4><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code>密钥。</p><h5 id="设备未设置代理使用-aliyun-镜像">设备未设置代理：使用 aliyun镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>向 <code>sources.list</code> 添加 Docker 软件源</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span><span class="hljs-string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)  stable"</span><br></code></pre></td></tr></table></figure><h5 id="设置了代理使用官方源">设置了代理：使用官方源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>向 <code>sources.list</code> 添加 Docker 软件源</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span><span class="hljs-string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="安装-docker">1.4 安装 Docker</h4><p>更新apt并安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure></p><h4 id="启动-docker">1.5 启动 docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable docker<br>sudo systemctl start docke<br></code></pre></td></tr></table></figure><h4 id="设置-docker-用户组">1.6 设置 docker 用户组</h4><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo groupadd docker</span><br></code></pre></td></tr></table></figure> 将当前用户加入<code>docker</code> 组： <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure>退出当前终端并重新登录，进行如下测试。</p><h4 id="测试是否安装正确">1.7 测试是否安装正确</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> hello-world</span><br></code></pre></td></tr></table></figure><p>输出成功信息即可</p><h4 id="修改-docker-images-存储路径">1.8 修改 docker images存储路径</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/daemon.json</span><br></code></pre></td></tr></table></figure><p>添加 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">"data-root"</span>: <span class="hljs-string">"/data/docker/images"</span><br></code></pre></td></tr></table></figure> 重启生效</p><h3 id="安装-nvidia-docker">2. 安装 nvidia-docker</h3><p><strong>要求已经按照 nvidia 驱动</strong></p><h4 id="设置了代理通过-apt-安装">设置了代理，通过 apt 安装</h4><h5 id="配置-nvidia-docker-源">2.1 配置 nvidia docker 源</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -distribution=$(. /etc/os-release;<span class="hljs-attribute">echo</span> <span class="hljs-variable">$ID</span><span class="hljs-variable">$VERSION_ID</span>)<br>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list |  sudo tee /etc/apt/sources.list.d/nvidia-docker.list<br>sudo apt-get update<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -s -L https:<span class="hljs-regexp">//</span>nvidia.github.io<span class="hljs-regexp">/nvidia-docker/g</span>pgkey | sudo apt-key add -<br></code></pre></td></tr></table></figure><h5 id="安装-nvidia-docker2">2.2 安装 nvidia-docker2</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">sudo</span> <span class="hljs-string">apt-get install nvidia-docker2</span><br><span class="hljs-attr">sudo</span> <span class="hljs-string">pkill -SIGHUP dockerd</span><br></code></pre></td></tr></table></figure><h4 id="未设置代理离线安装">未设置代理，离线安装</h4><p>在<a href="https://github.com/NVIDIA/libnvidia-container/tree/gh-pages/stable/ubuntu18.04/amd64">官网</a>下载，ubuntu20.04 使用 18.04 的文件，下载下列文件： - libnvidia-container1<br>- libnvidia-container-tools - nvidia-container-toolkit-base -nvidia-container-toolkit<br>- nvidia-container-runtime<br>- nvidia-docker2</p><ul><li><strong>文件名会根据版本有所改变，但前部一致</strong>：</li><li><strong>严格按照以下顺序，因存在依赖关系</strong></li></ul><p>依次输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dpkg -<span class="hljs-built_in">i</span> libnvidia-container1  <br>dpkg -<span class="hljs-built_in">i</span> libnvidia-container-tools<br>dpkg -<span class="hljs-built_in">i</span> nvidia-container-toolkit-base<br>dpkg -<span class="hljs-built_in">i</span> nvidia-container-toolkit  <br>dpkg -<span class="hljs-built_in">i</span> nvidia-container-runtime  <br>dpkg -<span class="hljs-built_in">i</span> nvidia-docker2<br></code></pre></td></tr></table></figure><p>若无报错 ❌，则安装成功 ✅</p><h4 id="重启-docker">重启 docker</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart docker</span><br></code></pre></td></tr></table></figure><p>使用需要gpu的测试</p><p><strong><em>安装完成后，会覆盖 daemon.json，如果需要更改 image的存储位置，需要重新设置</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvidia Driver Installation</title>
      <link href="/blogs/2023/04/17/NVIDIA-Driver-Installer/"/>
      <url>/blogs/2023/04/17/NVIDIA-Driver-Installer/</url>
      
        <content type="html"><![CDATA[<h3 id="初始教程">初始教程</h3><ol start="0" type="1"><li>查看系统显卡 <code>lspci | grep -i vga</code>，会弹出设备编号，在<a href="https://admin.pci-ids.ucw.cz/mods/PC/10de/2208">这里</a>找到对应的型号，然后在这里<a href="https://www.nvidia.cn/download/driverResults.aspx/209273/cn/">下载</a>。</li><li>下载对应驱动位于Downloads路径下的NVIDIA-Linux-x86_64-450.80.02.run</li></ol><ul><li>tips: 检查cuda版本和显卡驱动的<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">对应关系</a>.</li></ul><ol start="2" type="1"><li>卸载之前的显卡驱动<code>sudo apt-get automove --purge nvidia-×</code></li><li>给.run文件权限 <code>sudo chmod a+x xxx.run</code></li><li>关闭图形界面 ctrl+alt+f1</li><li>关闭lightdm服务 <code>sudo service lightdm stop</code></li><li>安装驱动<code>sudo xxx.run -no-x-check -no-nouveau-check -no-opengl-files</code></li><li>打开lightdm <code>sudo service lightdm start</code></li><li>如果没反应，再试试 <code>sudo syetemctl start gdm.service</code> or<code>sudo syetemctl enable gdm.service</code></li><li>打开图形化界面 <code>ctrl+alt+f7</code></li><li>重启</li></ol><h3 id="最近更新">最近更新</h3><ul><li><p>Ubuntu22.04似乎不用这么麻烦了，直接重装完之后就有显卡驱动了，试图卸载过，但是重装失败，还不如直接用预先安装好的。</p></li><li><p>ubuntu电脑自动开启SecurityBoot之后显卡驱动会挂掉，需要进入bios，在Security 中找到SecurityBoot，调整成为Disable，然后显卡驱动就又好了。</p></li></ul><p>SecureBoot本来是个好事，但是在linux下面似乎不太行，尤其是那种独立带界面的主机。参考<a href="https://www.cnblogs.com/harrymore/p/17653991.html">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudCompare源代码学习</title>
      <link href="/blogs/2023/03/13/CloudCompare%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/blogs/2023/03/13/CloudCompare%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="目的">目的</h3><p>想使用一下CloudCompare自带的八叉树，替换掉nanoflann。nanoflann在某些特殊场景下返回的结果是有问题的，导致程序出现异常。</p><a id="more"></a><h2 id="nanoflann返回值出现异常">nanoflann返回值出现异常</h2><p>​用于最邻近搜索，在radiussearch下，如果能找到最近点，那么确实找到的是最近点，如果找不到最近点，那么就会出现问题，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">nanoflann::KdTreeFLANN&lt;PB::pmPointXYZ&gt;::Ptr kdtree = <span class="hljs-built_in">std</span>::make_shared&lt;nanoflann::KdTreeFLANN&lt;PB::pmPointXYZ&gt;&gt;();<br><span class="hljs-keyword">if</span> (!kdtree) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"KD tree build failed!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>kdtree-&gt;setInputCloud(cloud);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; checkcorrs.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; searchIndexes;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;SCALAR_TYPE&gt; distances;<br>    SCALAR_TYPE *search_pt = <span class="hljs-keyword">new</span> SCALAR_TYPE[<span class="hljs-number">3</span>];<br>    search_pt[<span class="hljs-number">0</span>] = checkcorrs[i].x;<br>    search_pt[<span class="hljs-number">1</span>] = checkcorrs[i].y;<br>    search_pt[<span class="hljs-number">2</span>] = checkcorrs[i].z;<br>    kdtree-&gt;radiusSearch(search_pt, <span class="hljs-number">2.0</span>, searchIndexes, distances);<br>&#125;<br></code></pre></td></tr></table></figure><p>​在for循环中，每次更新query的点坐标，然后试图从点云中返回其最近的2.0m范围内的点，如果query点周围没有符合条件的点，那么就会返回上一次for循环的值。详见<a href="https://github.com/jlblancoc/nanoflann/issues/196">issue</a>。</p><h2 id="使用cloudcompare自带的octree">使用CloudCompare自带的Octree</h2><ul><li>核心为直接接入cc内部的octree实现最近点的索引，位于<code>#include &lt;DgmOctree.h&gt;</code>，这样检索速度大大加快。过程如下：</li></ul><ol type="1"><li>首先找到当前选中哪些entity，此时需要引用主窗口的头文件并获取全局静态变量<code>#include &lt;mainwindow.h&gt;</code>；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> ccHObject::Container &amp;selectedEntities = MainWindow::TheInstance()-&gt;getSelectedEntities();<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>遍历每个选中的entity，并将其转换为点云类型，需要<code>#include &lt;ccHObjectCaster.h&gt;</code>头文件；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (ccHObject* ent : selectedEntities)<br>&#123;<br>ccPointCloud* pc = ccHObjectCaster::ToPointCloud(ent);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>获取ccPointCloud点云类中的八叉树索引，如果未构建，则重新构建；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">ccOctree::Shared octree = pc-&gt;getOctree();<br><span class="hljs-keyword">if</span> (!octree)<br>&#123;<br>    octree = pc-&gt;computeOctree();<br>    <span class="hljs-keyword">if</span> (!octree)<br>    &#123;<br>    ccLog::LogMessage(QString::fromLocal8Bit(<span class="hljs-string">"索引构建失败，"</span>) + ent-&gt;getName(), ccLog::LOG_ERROR);<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>开始索引，测试了有两种方式，一种是使用<code>DgmOctree</code>的<code>findNeighborsInASphereStartingFromCell</code>，另一种是使用<code>DgmOctree</code>的<code>getPointsInSphericalNeighbourhood</code>。这里的<code>PointCoordinateType</code>是cc内部定义的数值变量的类型，默认为float型。检索出来的邻域点存放在<code>CCLib::DgmOctree::NeighboursSet</code>中，通过源码可以看出就是描述点信息的vector向量。需要注意的是，这两个方式都需要提前知道八叉树的层级，通过<code>octree-&gt;findBestLevelForAGivenNeighbourhoodSizeExtraction</code>得到当前半径下需要在哪一层level做检索。<code>NearestNeighboursSphericalSearchStruct</code>中的参数设置没搞明白，就先不用了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">PointCoordinateType search_radius = <span class="hljs-number">1.0</span>;<br><span class="hljs-comment">// @1</span><br><span class="hljs-comment">//CCLib::DgmOctree::NearestNeighboursSphericalSearchStruct nnsss;</span><br><span class="hljs-comment">//nnsss.queryPoint = search_pt;</span><br><span class="hljs-comment">//CCLib::DgmOctree::NeighboursSet neighbour_pts = nnsss.pointsInNeighbourhood;</span><br><span class="hljs-comment">//int ret_pt_num = octree-&gt;findNeighborsInASphereStartingFromCell(nnsss, search_radius, true);</span><br><span class="hljs-comment">// @2</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> level = octree-&gt;findBestLevelForAGivenNeighbourhoodSizeExtraction(search_radius);<br>CCVector3 search_pt = CCVector3(checkcorrs[i].ctrl_pt.x + global_offset.x,checkcorrs[i].ctrl_pt.y + global_offset.y, checkcorrs[i].ctrl_pt.z + global_offset.z);<br>CCLib::DgmOctree::NeighboursSet neighbour_pts;         <br><span class="hljs-keyword">int</span> ret_pt_num = octree-&gt;getPointsInSphericalNeighbourhood(search_pt, search_radius, neighbour_pts, level);<br></code></pre></td></tr></table></figure><p>​使用cc自带的八叉树之后，发现检索速度非常快（由于八叉树cell分区的原因，虽然返回的值可能不准确，但足够用了）。部分核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// qCC_db</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ccHObjectCaster.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ccPointCloud.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;DgmOctree.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mainwindow.h&gt;</span></span><br><span class="hljs-comment">// 控制点类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ControlPoint</span> :</span> <span class="hljs-keyword">public</span> CCVector3d<br>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> gcp_name; <span class="hljs-comment">// gcp name</span><br>    <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// gcp index</span><br>    <span class="hljs-comment">// operator &lt;&lt; overwrite</span><br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> ControlPoint &amp;pt) &#123;<br>        os &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"gcp_name: "</span> &lt;&lt; pt.gcp_name<br>            &lt;&lt; <span class="hljs-string">", x = "</span> &lt;&lt; pt.x &lt;&lt; <span class="hljs-string">" , y = "</span> &lt;&lt; pt.y &lt;&lt; <span class="hljs-string">" , z = "</span> &lt;&lt; pt.z;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ControlPoint&gt; ControlPointVec;<br><span class="hljs-comment">// 同名点类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HomonymPoint</span> :</span> <span class="hljs-keyword">public</span> CCVector3d<br>&#123;<br>    <span class="hljs-keyword">double</span> gps_time; <span class="hljs-comment">// gpstime from origin las point cloud file</span><br>    HomonymPoint() :CCVector3d(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>), gps_time(<span class="hljs-number">0.0</span>) &#123;&#125;<br>    <span class="hljs-comment">// container stores the nearest points located inside a certain radius for coordinate interpolation</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;P2M::BaseType::Point3D&gt; nearest_pts;<br>    HomonymPoint(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> x_, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> y_, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> z_)<br>        :CCVector3d(x_, y_, z_), gps_time(<span class="hljs-number">0.0</span>)<br>    &#123;&#125;<br>    <span class="hljs-comment">// operator &lt;&lt; overwrite</span><br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> HomonymPoint &amp;pt)<br>    &#123;<br>        os &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"Correspondence point gps time stamp: "</span> &lt;&lt; pt.gps_time<br>            &lt;&lt; <span class="hljs-string">", x = "</span> &lt;&lt; pt.x &lt;&lt; <span class="hljs-string">" , y = "</span> &lt;&lt; pt.y &lt;&lt; <span class="hljs-string">" , z = "</span> &lt;&lt; pt.z;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;HomonymPoint&gt; HomonymPointVec;<br><span class="hljs-comment">// 对应关系类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">checkCorrespondence</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    ControlPoint ctrl_pt;<br>    HomonymPoint corr_pt;<br>    <span class="hljs-keyword">bool</span> isChecked;<br>    <span class="hljs-comment">// for point cloud surface fitting, Coordinates of data points.</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;mba::<span class="hljs-built_in">point</span>&lt;2&gt;&gt; coo;<br>    <span class="hljs-comment">// Data values.</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; val;<br>    <span class="hljs-comment">// statistic info</span><br>    <span class="hljs-keyword">float</span> dist;<br>    <span class="hljs-keyword">float</span> dist_x;<br>    <span class="hljs-keyword">float</span> dist_y;<br>    <span class="hljs-keyword">float</span> dist_z;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;checkCorrespondence&gt; checkCorrespondences;<br><span class="hljs-comment">// get local part of ALS point cloud</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">getCorrespondPoints</span><span class="hljs-params">(checkCorrespondences &amp;checkcorrs, CCVector3d &amp;global_offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> ccHObject::Container &amp;selectedEntities = MainWindow::TheInstance()-&gt;getSelectedEntities();<br>    <span class="hljs-keyword">if</span> (selectedEntities.empty())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// global shift check, note that offset may be incorrected</span><br>    <span class="hljs-keyword">const</span> ccShiftedObject* shifted = ccHObjectCaster::ToShifted(selectedEntities[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (shifted)<br>    &#123;<br>        global_offset = shifted-&gt;getGlobalShift();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (ccHObject* ent : selectedEntities)<br>    &#123;<br>        ccPointCloud* pc = ccHObjectCaster::ToPointCloud(ent);<br>        <span class="hljs-keyword">if</span> (!pc)<br>        &#123;<br>            ccLog::LogMessage(QString::fromLocal8Bit(<span class="hljs-string">"未选中有效点云，"</span>) + ent-&gt;getName(), ccLog::LOG_ERROR);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        ccOctree::Shared octree = pc-&gt;getOctree();<br>        <span class="hljs-keyword">if</span> (!octree)<br>        &#123;<br>            octree = pc-&gt;computeOctree();<br>            <span class="hljs-keyword">if</span> (!octree)<br>            &#123;<br>                ccLog::LogMessage(QString::fromLocal8Bit(<span class="hljs-string">"索引构建失败，"</span>) + ent-&gt;getName(), ccLog::LOG_ERROR);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        Q_ASSERT(octree != <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-comment">//CCLib::DgmOctree::NearestNeighboursSphericalSearchStruct nnsss;</span><br>        PointCoordinateType search_radius = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> level = octree-&gt;findBestLevelForAGivenNeighbourhoodSizeExtraction(search_radius);<br>        <span class="hljs-comment">// find correspondence and calculate</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; checkcorrs.<span class="hljs-built_in">size</span>(); ++i) <br>        &#123;<br>            CCVector3 search_pt = CCVector3(checkcorrs[i].ctrl_pt.x + global_offset.x,<br>                checkcorrs[i].ctrl_pt.y + global_offset.y, checkcorrs[i].ctrl_pt.z + global_offset.z);<br>            <span class="hljs-comment">//nnsss.queryPoint = search_pt;</span><br>            <span class="hljs-comment">//int ret_pt_num = octree-&gt;findNeighborsInASphereStartingFromCell(nnsss, search_radius, true);</span><br>            <span class="hljs-comment">//CCLib::DgmOctree::NeighboursSet neighbour_pts = nnsss.pointsInNeighbourhood;</span><br>            CCLib::DgmOctree::NeighboursSet neighbour_pts;         <br>            <span class="hljs-keyword">int</span> ret_pt_num = octree-&gt;getPointsInSphericalNeighbourhood(search_pt, search_radius, neighbour_pts, level);<br>            <span class="hljs-keyword">if</span> (ret_pt_num &lt; <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// get the nearest point</span><br>            <span class="hljs-keyword">if</span> (neighbour_pts[<span class="hljs-number">0</span>].squareDistd &lt; checkcorrs[i].dist)<br>            &#123;<br>                <span class="hljs-keyword">const</span> CCVector3 *ret_pt0 = neighbour_pts[<span class="hljs-number">0</span>].<span class="hljs-built_in">point</span>;<br>                checkcorrs[i].corr_pt = HomonymPoint(ret_pt0-&gt;x - global_offset.x, ret_pt0-&gt;y - global_offset.y, ret_pt0-&gt;z - global_offset.z);<br>            &#125;<br>            <span class="hljs-comment">// get the set of neighbour pts</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pt: neighbour_pts)<br>            &#123;<br>                checkcorrs[i].isChecked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">const</span> CCVector3 *ret_pt = pt.<span class="hljs-built_in">point</span>;              <br>                <span class="hljs-comment">// copy to fitting data container</span><br>                checkcorrs[i].coo.push_back(mba::<span class="hljs-built_in">point</span>&lt;<span class="hljs-number">2</span>&gt;&#123;ret_pt-&gt;x, ret_pt-&gt;y&#125;);<br>                checkcorrs[i].val.emplace_back(ret_pt-&gt;z);<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// interpolate the height value based on nearest points</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interpolateCoordinate</span><span class="hljs-params">(checkCorrespondence &amp;corr, <span class="hljs-keyword">const</span> CCVector3d &amp;global_offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// get coarse boundary</span><br>    <span class="hljs-keyword">double</span> minx = <span class="hljs-number">0.0</span>, maxx = <span class="hljs-number">0.0</span>, miny = <span class="hljs-number">0.0</span>, maxy = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pt : corr.coo)<br>    &#123;<br>        minx = (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>)(minx, pt[<span class="hljs-number">0</span>]);<br>        maxx = (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>)(maxx, pt[<span class="hljs-number">0</span>]);<br>        miny = (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>)(miny, pt[<span class="hljs-number">1</span>]);<br>        maxy = (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>)(maxy, pt[<span class="hljs-number">1</span>]);<br>    &#125;<br>    mba::<span class="hljs-built_in">point</span>&lt;<span class="hljs-number">2</span>&gt; lo = &#123; minx - <span class="hljs-number">3.0</span>, miny - <span class="hljs-number">3.0</span> &#125;;<br>    mba::<span class="hljs-built_in">point</span>&lt;<span class="hljs-number">2</span>&gt; hi = &#123; maxx + <span class="hljs-number">3.0</span>, maxy + <span class="hljs-number">3.0</span> &#125;;<br>    <span class="hljs-comment">// Initial grid size.</span><br>    mba::index&lt;<span class="hljs-number">2</span>&gt; grid = &#123; <span class="hljs-number">5</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-function">mba::MBA&lt;2&gt; <span class="hljs-title">interp</span><span class="hljs-params">(lo, hi, grid, corr.coo, corr.val)</span></span>;<br>    <span class="hljs-comment">// residual between gt and measurement</span><br>    corr.corr_pt.z = interp(mba::<span class="hljs-built_in">point</span>&lt;<span class="hljs-number">2</span>&gt;&#123;corr.ctrl_pt.x + global_offset.x, corr.ctrl_pt.y + global_offset.y&#125;);<br>    corr.dist_z = corr.ctrl_pt.z - corr.corr_pt.z;<br>&#125;<br><span class="hljs-comment">// for interpolating the position of target gcp points</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">qualityCheck</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;gcp_path, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;output_path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">namespace</span> PB = P2M::BaseType;<br>    <span class="hljs-comment">// load gcps</span><br>    <span class="hljs-keyword">if</span> (!P2M::Util::FileUtility::FileExist(output_path)) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Output Path: "</span> &lt;&lt; output_path &lt;&lt; <span class="hljs-string">" doesn't exist!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    checkCorrespondences checkcorrs;<br>    <span class="hljs-function">CCVector3d <span class="hljs-title">global_offset</span><span class="hljs-params">(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>)</span></span>;<br>    <span class="hljs-comment">// load check gcp points</span><br>    loadGcpFile(gcp_path, checkcorrs, global_offset);<br>    <span class="hljs-comment">// get loca part of ALS point clouds</span><br>    getCorrespondPoints(checkcorrs, global_offset);<br>    <span class="hljs-comment">// get height difference based on surface fitting</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;checkcorr : checkcorrs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (checkcorr.isChecked)<br>        &#123;<br>            interpolateCoordinate(checkcorr, global_offset);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudCompare </tag>
            
            <tag> Point Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zotero食用指南</title>
      <link href="/blogs/2023/03/06/Zotero/"/>
      <url>/blogs/2023/03/06/Zotero/</url>
      
        <content type="html"><![CDATA[<h2 id="初衷">初衷</h2><p>​文献管理其实是一项需要在最开始就把工作流做好的，事半功倍。之前使用了如下的方案进行文献管理：</p><ul><li><p>EndNote，写文章插入citation很好用，各种标签功能也挺好用，但是云盘空间太小，无法和pdf联动，而我喜欢把笔记写在pdf上，EndNote似乎无法直接把pdf导入，只能管理基本的文献元数据，没达到我想的那种方式。后面也就只在写文章需要添加引用的时候用了。中文比较友好。奈何我需要先写SCI。</p></li><li><p>Mendeley，英文非常好，但是多平台同步太慢了，经常卡死，而且后面客户端也不更新了。无法使用。用起来很气人。</p></li><li><p>NoteExpress一开始不好用，结果后面变好用了之后也没注意到。似乎写中文毕业论文也比较好用。主要是简单。</p></li><li><p>Zotero在多年前用过，当时一系列插件还不是很健全，用起来不是很美。就没用了。</p></li></ul><p>​导致现状就是：笔记写在了pdf文件上，采用本地文件夹管理的方式，文件多了+时间长了+ipad联动等需求激增，想好好管理一下，发现一时间竟然没有合适的方案。</p><h2 id="方案">方案</h2><p><strong>zotero+坚果云</strong></p><p>​zotero安装和坚果云申请就不说了。网上一大堆。虽然坚果云每个月上传下载有流量限制，但是忍过最初的几个月之后，剩下的时候不需要全部更新，应该也能顶住。</p><a id="more"></a><h2 id="插件">插件</h2><h3 id="zotfile"><a href="http://zotfile.com/index.html#renaming-rules">ZotFile</a></h3><p><img src="/blogs/.io//zotfile.png"></p><p>Source Folder for Attaching NewFiles:存放由zotero管理文件时，pdf等文件的位置，storage下是采用一种zotero默认8位数字和字母的组合的编码方式存储的文件，以.zip方式存储，根本无法和pdf文件名字对应。无法直接使用。</p><p>Location ofFiles:自定义的文件统一存放路径，可以根据设置好的文件/文件夹重命名方式将导入的文献重新按照统一的格式移动到这个路径中。（也就是说如果是本地文件导入了之后，这里会重新生成一个新的换了名字的相同文件，旧的就可以删掉了，每个新增的文件都需要手动移动一下位置，可以批量操作）。</p><ul><li>use subfolder defined by<strong>/%c</strong>（%T是按照文献类别来分），这里设置的是按照我在zotero中分类的条目进行的文章归纳，这样带来的好处是，分享到其他地方仍然可以看到简单的分档归纳，问题是，文章如果想给多个分类条目，就会导致文章重复出现，因此需要在zotero中使用tag进行管理。</li></ul><p><img src="/blogs/.io//zotfile3.png"></p><p>这里选择的文件重命名方式是“期刊简写_年份_文章名字”的方式。因为文章良莠不齐，根据期刊名字可以迅速筛掉一部分文献，根据年限可以找到最近的文章，最后才看名字，如果不相关的肯定不会下载。这种方式非常适合将pdf导出的时候，没有zotero这一套，只有pdf文件也可以进行学习。</p><h4 id="工作流">工作流</h4><p>移动端负责的是文献阅读与标注，在 Zotero完成文献的管理后，将想看的文献发送到 iPad 上进行阅读，完成 ZotFile的设置后，对于我们想要发送到 iPad 上的文献，右键单击，依次选择「ManageAttachments 」-&gt;「Send to subfolders ontablet」，就能够将文献按照其在 Zotero自定义分类中的情况，创建相应的子文件夹，发送到先前设定到的目标位置。</p><p>这里其实还有一个选项，直接就是「Send to tablet」，这个选项只会将 PDF文件发送过去，而不会创建子文件夹，对于一些临时看的文献可以选择该选项。我选择将文献发送到iCloud 的一个文件夹中，便于在 iPad 上进行访问。发送完成后，可以在 Zotero的侧边栏发现新增了两个分类，分别为「Tablet Files」和「Tablet Files(modified)」，前者里面放的就是我们发送到平板上的所有文件（其实这也是类似于打标签）。</p><p>发送到 iPad 后，就可以利用各种 PDF阅读器对文献进行标注。自带的「文件」能够进行简单的批注，实际上手时也发现足够自己使用了，但是有一个我个人不太喜欢的问题，就是「文件」会挡住文献的右边缘，不利于充分利用空间。为了尽可能模拟在纸张上阅读文献的感觉，我找到了一个叫做「PDFViewer」的免费软件，解决了边缘空白无法利用的问题。</p><p>在 iPad 上完成文献的阅读后，进入 Zotero，在「TabletFiles」分类中找到想要取回的文献，右键单击，依次选择「Manage Attachments」-&gt;「Get from Tablet」，就可以将标注后的 PDF 文件重新取回到 Zotero的文件存储位置，并覆盖原来的文件，使得标注的内容得以同步。标注后的 PDF文件体积通常会变大不少。</p><h4 id="参考">参考</h4><ul><li>http://zotfile.com/index.html#renaming-rules</li><li>https://www.zhihu.com/question/23572825</li><li>https://andyluojj.github.io/post/zotero-kua-she-bei-wen-xian-guan-li/</li><li>https://blog.csdn.net/haoji007/article/details/127623641</li></ul><h3 id="jaseminum">jaseminum</h3><p>管理中文文献的。</p><h3 id="if">IF</h3><p>这个插件似乎没啥用。</p><h3 id="zotero-better-notes">Zotero-Better-Notes</h3><p>官方笔记见<a href="https://zotero.yuque.com/staff-gkhviy/better-notes/biigg4?">这里</a>。</p><h3 id="chartero">Chartero</h3><p>浏览阅读的历史记录，可以看出本月看了多少文章。</p><p>创建的Chartero文件不要删掉，不然会丢掉之前的阅读记录。官方文档见<a href="https://gitee.com/const_volatile/chartero/tree/js_overlay/">这里</a>。</p><p>阅读文章的时候，想随时翻译。</p><p><strong>Q</strong> I want to translate manually. <strong>A</strong>Go to <code>Edit-&gt;Preferences-&gt;PDF Translate-&gt;General</code>,uncheck the <code>Automatic Translation</code>. Click the<code>translate</code> button on the popup or sidebar to translate.</p><p><strong>Q</strong> I want a translate shortcut. <strong>A</strong>Press shortcut <code>Ctrl+T</code> after you selected some text. If youare in the collection view, the titles' translation will show/hide.</p><h3 id="zotero-tag">Zotero-Tag</h3><p>官方文档在<a href="https://www.zotero.org/support/collections_and_tags#colored_tags">这里</a>。可以给文章打上颜色标签，阅读的时候更容易找到想要的那个标签。</p><h2 id="多平台同步">多平台同步</h2><p>多平台同步的思路和流程见这里：</p><div data-align="center"><img src="https://cdn.sspai.com/2020/12/30/b377db1c9a3cb04a944d91f990d91c2b.png"></div><p>如果想换电脑了，而坚果云有限制（下载限制一个周期内3G）。那么可以直接把存放文件库的那个文件夹直接全部拷贝到新的电脑上，然后按照下面的设置新的路径：</p><div data-align="center"><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Zotero_multi_platform_%20synchronize.png"></div><p>然后在新电脑上就可以直接打开啦，官方文档参见<a href="https://www.zotero.org/support/preferences/advanced#linked_attachment_base_directory">这里</a>。坚果云会自动进行同步，将旧有的文件信息不动（不会耗费流量），修改的进行同步。</p><ul><li>注意：不要手贱删掉zotero云端的文章，不然同步的时候，本地的文件也就没有了。</li></ul><h3 id="参考-1">参考</h3><ul><li>https://sspai.com/post/64283</li></ul><h2 id="其他">其他</h2><h3 id="pdf全文索引">PDF全文索引</h3><p>​如果发现之前的文章找不到对应的文章了，只剩下一个假索引说明，是动了zotero的原始文件存储的位置，需要重新生成一下索引就可以了。一般来说默认新导入的文章是会自动更新索引的。Zotero空闲时会自动对PDF进行索引。但是如果发现打不开pdf了，手动更新一下就行。</p><h3 id="文献导入后不同图标的含义">文献导入后不同图标的含义</h3><p>​ 这些都是zotero自动识别出来的，可以修改。</p><blockquote><p>白色+横道：期刊</p><p>白色+横道+两个小人：会议</p><p>白色+黄色铅笔：arxiv</p></blockquote><ul><li>如果发现导入的pdf自动检索不出来，可以手动更新，找到这个bibtex文件，然后导入的时候选择从剪贴板导入，然后和之前那个错误的合并一下就行。</li></ul><h3 id="文献导入">文献导入</h3><p>​ 导入一篇文献需要完成三步操作：拖入 PDF文献，等待元数据检索完成并检查（或先导入元数据再拖入 PDF文件），最后右键选择 Rename Attachments。</p><p>​ 或者直接在浏览器端，使用zoteroconnector将文件导入。这种平时浏览的话比较方便。</p><h3 id="文献删除">文献删除</h3><p>​一般来说导入的文章会存成软链接的方式，因此直接在zotero删除条目时，只会删掉软链接，文章还是不动的，可以在工具-&gt;管理附件-&gt;转换已链接文件为已存储文件。这样就一下子都可以把文件都删掉。</p><h3 id="文献元数据更新">文献元数据更新</h3><p>​由于某些文献发表时间太久了，或者是发表在某个野鸡期刊上的，可能找不到doi号，进而也无法更新元数据。这种类型的pdf就不管了，文章水平也不怎么样，可以看，但是引用意义不大。</p><h4 id="更新方式">更新方式</h4><ol type="1"><li>选中文献，然后在工具中选择抓取DOI，如果能找到，那么恭喜，可以选择更新元数据，条目信息就更新了，文章也可以继续被更新；</li><li>如果找不到，那么在<a href="https://search.crossref.org/?q=&amp;from_ui=yes">crossref</a>上搜一下，找不到就没办法了。</li></ol><p>https://formlesslab.top/2021/10/13/%E5%AD%A6%E6%9C%AF/Zotero/Zotero-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%85%83%E6%95%B0%E6%8D%AE/</p><h3 id="信息中各个label中的意义">信息中各个label中的意义</h3><p>因为添加了Zotero IF ProMax破解版（原版好像有问题）等插件，因此会有一些额外的bonus的数据给出来。</p><p>馆藏目录表示的是影响因子，但是不知道是加了哪个插件，现在影响因子和期刊标签，引用量都可以显示出来了。</p><p>存档位置表示的是引用量</p><p>索书号：对应JCR分区，只对SCI有效</p><p>只有使用了zotero自带的pdf阅读器才能记录有zoterostyle和chatero的进度条信息产生，但是pdf的注释需要手动导出才能将注释记录到pdf中。</p><h2 id="参考链接">参考链接</h2><ul><li>http://zotfile.com/index.html#renaming-rules</li><li>https://zhuanlan.zhihu.com/p/31453719</li><li>https://zhuanlan.zhihu.com/p/108366072</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zotero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo进阶</title>
      <link href="/blogs/2023/02/25/Hexo%E8%BF%9B%E9%98%B6/"/>
      <url>/blogs/2023/02/25/Hexo%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>关于Hexo如何制作博客主页详见<a href="http://whu-lyh.github.io/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/">这里</a>。</li></ul><h2 id="现象描述">现象描述</h2><p>​ 按照<a href="http://whu-lyh.github.io/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/">hexo+githubpages的博客搭建部署流程</a>，hexo的<strong>博客主页</strong>会部署在<code>https://yourgithubname.github.io/</code>。本来没什么问题的，但是后面我想做一个<strong>个人主页（学术主页）</strong>，按照<a href="https://github.com/academicpages/academicpages.github.io">academicpages/academicpages.github.io</a>或者<a href="RayeRen/acad-homepage.github.io">RayeRen/acad-homepage.github.io</a>的方案，使用的也是<code>https://yourgithubname.github.io/</code>。这时候就有问题了，博客和个人主页的域名不就冲突了？</p><ul><li>我的目的是实现下面功能的东西。</li></ul><blockquote><p>从yourgithubname.github.io进入，访问的是我的个人主页。通过个人主页可以跳转到博客、建立页面。</p><p>从yourgithubname.github.io/blogs进入，访问的是我的博客，就是用hexo搭建好的。</p><p>从yourgithubname.github.io/resume进入，访问的就是我的一个个人简历。</p></blockquote><ul><li>本人菜鸡，完全不懂前端。尝试了几种不同的方案，包括切换repo分支的谜之操作，都试了，都不行。最后发现原来是对Hexo进行部署了解的不够细致。</li></ul><a id="more"></a><h3 id="hexo部署过程">Hexo部署过程</h3><p>​ 按照之前介绍Hexo搭建个人博客中的流程做好如下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://yourgithubname.github.io</span> <span class="hljs-comment"># 注意这里的url就是能够通过外网访问的博客主页链接，也就是Hexo将博客主页的内容放在了这个对应的同名仓库</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing 'index.html' from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing '.html' from permalinks</span><br>  <br>  <span class="hljs-string">...</span><br>  <span class="hljs-string">...</span><br>  <br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:yourgithubname/yourgithubname.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>​然后执行<code>hexo d</code>，这样通过上面的url：http://yourgithubname.github.io就可以看到部署好的博客页面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Mode                 LastWriteTime         Length Name<br>----                 -------------         ------ ----<br>d-----      2023-02-25  上午 11:45                .deploy_git<br>d-----      2023-02-06  上午 11:48                node_modules<br>d-----      2023-02-25  上午 11:44                public<br>d-----      2023-02-01  上午 11:08                scaffolds<br>d-----      2023-02-25  上午 09:24                <span class="hljs-built_in">source</span><br>d-----      2020-02-23  下午 04:10                themes<br>-a----      2020-02-23  下午 03:24             71 .gitignore<br>-a----      2023-02-25  上午 11:44         951152 db.json<br>-a----      2023-02-06  上午 11:48         138563 package-lock.json<br>-a----      2023-02-06  上午 11:48            678 package.json<br>-a----      2023-02-25  上午 11:56            203 README.md<br>-a----      2023-02-25  上午 11:44           3532 _config.yml<br></code></pre></td></tr></table></figure><ul><li>同时我在这个路径下初始化一个私有的仓库Blog，利用git管理这些写好的文件，防止丢失。也方便在不同的电脑端进行再次搭建。私有Blog仓库不会被别人访问到。别人只能看到yourgithubname.github.io这个仓库中的内容，但是这里面是经过处理的内容，无法逆向解析，我做不到。。。</li></ul><h3 id="github-pages">Github Pages</h3><p>​ <strong><a href="https://pages.github.com/">GitHubPages</a></strong>是GitHub提供的一个网页寄存服务，于2008年推出。可以用于存放<strong>静态网页</strong>，包括博客、项目文档甚至整本书。<a href="https://zh.wikipedia.org/wiki/Jekyll_(軟件)">Jekyll软件</a>可以用于将文档转换成静态网页，该软件提供了将网页上传到GitHubPages的功能。一般GitHubPages的网站使用github.io的<strong>子域名</strong>，但是用户也可以<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site">使用第三方域名</a>。</p><p>​按照Hexo博客部署的教程，我之前相当于开了一个yourgithubname.github.io的公有仓库，通过Pages的设置中的Buildanddeployment中激活了yourgithubname.github.io这个github上的次级域名。这个域名外网可以访问到。</p><p>​那么部署是在做什么呢：简单来说就是在本地构建一个静态网页，然后发到特定的域名的过程。比如这里Hexo搭建的时候，通过Node.js帮我们搞了很多事情，利用Hexo提供的模板做了静态网页，然后用githubpages蹭了一个域名，通过Hexo将网页信息部署到了https://yourgithubname.github.io<strong>主页</strong>的过程。部署时的内容生成到了yourgithubname.github.io这个仓库。（别人只能访问Hexo部署之后生成的文件）</p><ul><li>理论上来说可以在github构建无限的公有仓库，都设置次级域名，都可以通过xxx访问了。</li></ul><h2 id="解决方案">解决方案</h2><ol type="1"><li>新建一个blogs公开仓库（私有是不行的，和yourgithubname.github.io仓库同理），在仓库Settings中找到Pages,在Buildanddeployment中的<strong>Branch</strong>上设置main分支，/root路径，然后save。（中间可能会等一会，githubpages响应一下）会发现在上方的GitHubPages处，已经显示<code>Your site is live at https://yourgithubname.github.io/blogs/</code>了。（激活了新的次次级域名）</li><li>然后在Hexo的根目录下的_config.yml设置url和root如下：（调整网站部署的域名地址）</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://whu-lyh.github.io/blogs</span> <span class="hljs-comment"># 这个域名是新的已经更新的博客的主页地址，与blogs仓库同名</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/blogs</span> <span class="hljs-comment"># 这里按照要求也要修改</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing 'index.html' from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing '.html' from permalinks</span><br>  <br>  <span class="hljs-string">...</span><br>  <span class="hljs-string">...</span><br>  <br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:whu-lyh/blogs.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>重新<code>hexo clean -g</code>, <code>hexo g</code>,<code>hexo d</code>。</li><li>然后就成了。从<code>https://yourgithubname.github.io/blogs</code>访问博客页面了。</li></ol><p>再说一下错误的方案：</p><ul><li>github仓库的setting中的Pages下面有个Customdomain，这个域名是要重新买的，搞一个CNAME，然后绑定到这里。就可以实现自定义域名访问了。</li><li>之前还试过调整yourgithubname.github.io这个仓库下面的分支，还以为调整分支能实现我的目的，结果发现完全不对。</li></ul><h3 id="个人主页">个人主页</h3><p>​ fork一个academicpages.github.io，然后按照<a href="https://zhenggao.io/blog/2019/12/10/Jekyll-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/">这个</a>改一下，每次只需要修改内容之后push到对应的仓库，等待一会就自动部署到github.io上，即可看到页面更新了。如果不在本地预览，那么修改完主页内容之后，直接push到github.io的仓库就行，github pages会重新自动部署。</p><ul><li>但是后面发现这个主页非常的臃肿，里面很多不需要的冗余内容，因此换成了<a href="https://github.com/RayeRen/acad-homepage.github.io">这个</a>。操作同理。</li></ul><h3 id="个人简历">个人简历</h3><p>​resume可以用类似的方式搞一个repo，然后找一些简历模板，css的。本地可以编辑好，采用和blogs相同的步骤部署就行。</p><ul><li>也可以使用<span class="math inline">\(\LaTeX\)</span>来写，比如<a href="https://github.com/whu-lyh/resume">这里</a>。直接在overleaf上面就能修改。</li></ul><h2 id="参考资料">参考资料</h2><ul><li>https://blog.csdn.net/xuedan1992/article/details/83445756</li><li>https://goddywu.github.io/2018/02/24/%E4%BD%BF%E7%94%A8github%E5%AD%90%E7%9B%AE%E5%BD%95%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</li><li>https://docs.github.com/en/pages/quickstart</li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-spline Interpolation</title>
      <link href="/blogs/2023/02/09/B-spline-Interpolation/"/>
      <url>/blogs/2023/02/09/B-spline-Interpolation/</url>
      
        <content type="html"><![CDATA[<h1 id="kalibr">Kalibr</h1><p>Kalibr中使用了B-spline实现位姿的内插，进而完成相机和IMU之间的时间同步标定。</p><a id="more"></a><p>PoseSpline</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B-Spline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rotation Average</title>
      <link href="/blogs/2023/02/09/Rotation-Average/"/>
      <url>/blogs/2023/02/09/Rotation-Average/</url>
      
        <content type="html"><![CDATA[<h2 id="what-is-rotation-averaging">What is Rotation Averaging?</h2><h3 id="problem1">Problem<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><p>Given a set of rotation matrices <span class="math inline">\(C_i,i=\{1,2,...,n\}\)</span>, the average of them is ? <strong>RotationAveraging</strong> is to calculate the average of a set of rotationmatrices. Averaging is to get the <strong>best estimate</strong> of allrotations. (Single rotation averaging)</p><p>Or equivalently, <strong>Rotation Averaging</strong> is the problemof estimating a set of <span class="math inline">\(n\)</span> unknownorientations <span class="math inline">\(R_1,...,R_n \in SO(d)\)</span>from noisy measurements <span class="math inline">\(\bar{R} \inSO(d)\)</span> of the relative rotations <span class="math inline">\(R_i^{-1}R_j\)</span> between them. (Multi rotationaveraging)</p><p>In practical the rotation averaging problem could be categoried into: Single rotation averaging、Multi rotation averaging and Conjugaterotation averaging.</p><a id="more"></a><ul><li>Single rotation averaging: for instance,</li></ul><blockquote><p>used in the case where <strong>several measurements of a singlerotation R are given</strong>. These may be for instance measurements ofthe orientation of an object, derived from measurements taken withdifferent cameras in a <strong>calibrated network</strong>. If themeasurements are noisy, they can be <strong>averaged to find amean</strong>.</p></blockquote><ul><li>Multi rotation averaging: for instance,</li></ul><blockquote><p>estimate the rotation of camera in <strong>SFM</strong>. Morepractical applications in OpenMVG.</p></blockquote><ul><li>conjugate rotation averaging: for instance,</li></ul><blockquote><p><strong>hand-eye coordinate problem</strong>, that is, consider arobot manipulating some object, which is also observed by a stationarycamera. The orientation of the object can be computed at each momentthrough knowledge of the geometry of the robot (for instance, jointangles). At the same time, the orientation of the object can be computedfrom the images taken from the camera. This gives two separate estimatesof the orientation of the object (expressed as a rotation), but theseare in <strong>different coordinate frames</strong>. By solving theconjugate rotation problem, one can compute the<strong>relationship</strong> between the robot and camera frames.</p></blockquote><p>For all these problems, <strong>Rotation Averaging</strong> is tofind provably optimal and convergent solutions.</p><h2 id="rotation-averaging12">RotationAveraging<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h2><p>Assume the average rotation matrix is <span class="math inline">\(\bar{C}\)</span>, The angle <span class="math inline">\(\Delta \delta_i\)</span> between <span class="math inline">\(\bar{C}\)</span> and <span class="math inline">\(C_i\)</span> , <span class="math inline">\(C_i\mbox{ and }\bar{C} \in SO(3)\)</span>, could be calculated asfollowings: <span class="math display">\[\Delta C_i=\bar{C}^TC_i\]</span> The cosine value of <span class="math inline">\(\Delta\delta_i\)</span> is: <span class="math display">\[\begin{align}cos \Delta \delta_i &amp;= \frac{tr(\Delta C_i)-1}{2} \\&amp;=\frac{tr(\bar{C}^TC_i)-1}{2} \\\end{align}\]</span> The sum of all cosine value of <span class="math inline">\(\Delta \delta\)</span>, also known as <span class="math inline">\(Karcher\)</span> mean: <span class="math display">\[\begin{align}\Sigma_i^n cos \Delta \delta_i &amp;=\Sigma_i^n\frac{1}{2}(tr(\bar{C}^TC_i)-1) \\&amp;=\frac{1}{2} \Sigma_i^ntr(\bar{C}^TC_i)-\frac{n}{2}\end{align}\]</span> Minimize the sum of angles between <span class="math inline">\(\bar{C}\)</span> and <span class="math inline">\(C_i\)</span> is to maximize <span class="math inline">\(\Sigma_i^ntr(\bar{C}^TC_i)\)</span>. ==??? whyminimize??? to get the best estimate== <span class="math display">\[\begin{align}\Sigma_i^ntr(\bar{C}^TC_i) &amp;= tr(\Sigma_i^n \bar{C}^TC_i) \\&amp;=tr( \bar{C}^T \Sigma_i^nC_i) \mbox{ // trace operator} \\&amp;=tr( \bar{C}^T U\Sigma V^T)  \mbox{ // why?}\\&amp;=tr(  V^T\bar{C}^T U\Sigma) \mbox{ // trace operator}\end{align}\]</span> where <span class="math inline">\(V^T,U,\bar{C}^T\)</span> areorthogonal matrices[^ 3].</p><p>Then set <span class="math inline">\(O=tr(V^T \bar{C}^T U)\)</span>，it is also orthogonal matrix. <span class="math display">\[\begin{align}tr(V^T\bar{C}^T U\Sigma) &amp;= tr(O \Sigma) \\&amp;= tr( \left[\begin{array}{ccc}O_{11} &amp; O_{12} &amp; O_{13} \\O_{21} &amp; O_{22} &amp; O_{23} \\O_{31} &amp; O_{32} &amp; O_{33}\end{array}\right]\left[\begin{array}{ccc}\delta_{11} &amp;  &amp;  \\&amp; \delta_{22} &amp; \\&amp;  &amp; \delta_{33}\end{array}\right]) \\&amp;= O_{11} \delta_1 + O_{22} \delta_2 + O_{33} \delta_3\end{align}\]</span> where <span class="math inline">\(O\)</span> is orthogonalmatrix, means <span class="math inline">\(\Sigma_{j=1}^3 O_{jk}^2=1,\mbox{ for} \quad k=1,2,3\)</span>. And the <span class="math inline">\(O_{11} \leq 1,O_{22} \leq 1,O_{33} \leq1\)</span>.</p><p>Let <span class="math inline">\(O_{11} = 1,O_{22} = 1,O_{33} =1\)</span>, Then <span class="math display">\[O=\left[\begin{array}{ccc}1 &amp;  &amp;  \\&amp; 1 &amp; \\&amp;  &amp; 1\end{array}\right]=I\]</span> then $V^T {C}^T U=I {C}<sup>T=VU</sup>T {C} =UV^T $.</p><p>Then check the determinant of <span class="math inline">\(UV^T\)</span>, which should be 1. <span class="math display">\[\bar{C}=U \left[\begin{array}{ccc}1 &amp;  &amp;  \\&amp; 1 &amp; \\&amp;  &amp; det(UV^T)\end{array}\right] V^T \mbox{ // why?}\]</span></p><h3 id="code">Code</h3><p><a href="https://github.com/openMVG/openMVG/blob/08ac7746d2b98318e9308fb4e6bb81509d7cd1b0/src/openMVG/multiview/rotation_averaging_test.cpp">OpenMVG</a>&amp; Ceres for LM optimization.</p><p>Simplest toy code test:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Rotation averaging in a triplet:</span><br><span class="hljs-comment">// 0_______2</span><br><span class="hljs-comment">//  \     /</span><br><span class="hljs-comment">//   \   /</span><br><span class="hljs-comment">//    \ /</span><br><span class="hljs-comment">//     1</span><br>TEST (rotation_averaging, RotationLeastSquare_3_Camera)<br>&#123;<br>  <span class="hljs-comment">//--</span><br>  <span class="hljs-comment">// Setup 3 camera that have a relative orientation of 120 degree</span><br>  <span class="hljs-comment">// Set Z axis as UP Vector for the rotation</span><br>  <span class="hljs-comment">// They are in the same plane and looking in O=&#123;0,0,0&#125;</span><br>  <span class="hljs-comment">//--</span><br>  <span class="hljs-keyword">const</span> Mat3 R01 = RotationAroundZ(<span class="hljs-number">2.</span>*M_PI/<span class="hljs-number">3.0</span>); <span class="hljs-comment">//120 degree</span><br>  <span class="hljs-keyword">const</span> Mat3 R12 = RotationAroundZ(<span class="hljs-number">2.</span>*M_PI/<span class="hljs-number">3.0</span>); <span class="hljs-comment">//120 degree</span><br>  <span class="hljs-keyword">const</span> Mat3 R20 = RotationAroundZ(<span class="hljs-number">2.</span>*M_PI/<span class="hljs-number">3.0</span>); <span class="hljs-comment">//120 degree</span><br><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;RelativeRotation&gt; vec_relativeRotEstimate;<br>  vec_relativeRotEstimate.push_back(RelativeRotation(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, R01));<br>  vec_relativeRotEstimate.push_back(RelativeRotation(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, R12));<br>  vec_relativeRotEstimate.push_back(RelativeRotation(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>, R20));<br><br>  <span class="hljs-comment">//- Solve the global rotation estimation problem :</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Mat3&gt; vec_globalR;<br>  <span class="hljs-comment">// More in header file</span><br>  L2RotationAveraging(<span class="hljs-number">3</span>, vec_relativeRotEstimate, vec_globalR);<br>  EXPECT_EQ(<span class="hljs-number">3</span>, vec_globalR.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-comment">// Check that the loop is closing</span><br>  EXPECT_MATRIX_NEAR(Mat3::Identity(), (vec_globalR[<span class="hljs-number">0</span>]*vec_globalR[<span class="hljs-number">1</span>]*vec_globalR[<span class="hljs-number">2</span>]), <span class="hljs-number">1e-8</span>);<br><br>  <span class="hljs-comment">//--</span><br>  <span class="hljs-comment">// Check that the found relative rotation matrix give the expected rotation.</span><br>  <span class="hljs-comment">//  -&gt; the started relative rotation (used in the action matrix).</span><br>  <span class="hljs-comment">//// /!\ Translations are not checked they are 0 by default.</span><br>  <span class="hljs-comment">//--</span><br>  Mat3 R;<br>  Vec3 t, t0 = Vec3::Zero(), t1 = Vec3::Zero();<br>  RelativeCameraMotion(vec_globalR[<span class="hljs-number">0</span>], t0, vec_globalR[<span class="hljs-number">1</span>], t1, &amp;R, &amp;t);<br>  EXPECT_NEAR(<span class="hljs-number">0</span>, FrobeniusDistance( R01, R), <span class="hljs-number">1e-2</span>);<br><br>  RelativeCameraMotion(vec_globalR[<span class="hljs-number">1</span>], t0, vec_globalR[<span class="hljs-number">2</span>], t1, &amp;R, &amp;t);<br>  EXPECT_NEAR(<span class="hljs-number">0</span>, FrobeniusDistance( R12, R), <span class="hljs-number">1e-2</span>);<br><br>  RelativeCameraMotion(vec_globalR[<span class="hljs-number">2</span>], t0, vec_globalR[<span class="hljs-number">0</span>], t1, &amp;R, &amp;t);<br>  EXPECT_NEAR(<span class="hljs-number">0</span>, FrobeniusDistance( R20, R), <span class="hljs-number">1e-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shonan-rotation-averaging4">Shonan RotationAveraging<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h2><p>This is a fast, simple, and elegant rotation averaging algorithm thatis guaranteed to recover globally optimal solutions under mildassumptions on the measurement noise. The method employs semidefiniterelaxation in order to recover provably globally optimal solutions ofthe rotation averaging problem.</p><h3 id="code-1">Code</h3><p>Already inside GTSAM-4.1</p><h2 id="rcd-rotation-coordinate-descent5">RCD: Rotation CoordinateDescent<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></h2><p>RCD is a fast rotation averaging algorithm that achieves globaloptimality under mild noise conditions on the noise level of themeasurements.</p><h3 id="code-2">Code</h3><p><a href="https://github.com/sfchng/Rotation_Coordinate_Descent">RCD</a></p><h2 id="hybrid-rotation-averaging-a-fast-and-robust-rotation-averaging-approach7">HybridRotation Averaging: A Fast and Robust Rotation AveragingApproach<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></h2><h3 id="code-3">Code</h3><p><a href="https://github.com/whu-lyh/GraphOptim">Graph Optimizer</a>:This library contains not only rotation averaging solvers, but also somepopular methods in 3D vision, such as translation averaging, clustering,etc. The library is designed to deal with large scale optimizationproblems, and is easy to extend.</p><h2 id="irotavg6">iRotAvg<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></h2><p>incrementally solves rotation averaging.</p><h3 id="code-4">Code</h3><p><a href="https://github.com/ajparra/iRotAvg">iRotAvg</a></p><h2 id="diff">Diff</h2><p>What is the difference between rotation averaging and SLAM ? Orstatus estimation? SLAM tries to estimate both translation androtation,while rotation averaging estimate the optimal rotationonly.</p><h2 id="others">Others</h2><p>rotation averaging used by Fast Point Transformer, is a post-processoptimization scheme? Perhaps yes.</p><h2 id="reference">Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">Hartley R, Trumpf J, Dai Y, et al. Rotation averaging[J]. Internationaljournal of computer vision, 2013, 103:267-305.<a href="#fnref:1" rev="footnote"> ↩︎</a></li><li id="fn:2">https://www.cnblogs.com/JingeTU/p/16818609.html<a href="#fnref:2" rev="footnote">↩︎</a></li><li id="fn:3">https://en.wikipedia.org/wiki/Orthogonal_matrix<a href="#fnref:3" rev="footnote">↩︎</a></li><li id="fn:4">Shonan Rotation Averaging: Global Optimality by Surfing <span class="math inline">\(SO(p)^n\)</span>, ECCV2020<a href="#fnref:4" rev="footnote"> ↩︎</a></li><li id="fn:5">Rotation Coordinate Descent for Fast Globally Optimal RotationAveraging, CVPR 2021<a href="#fnref:5" rev="footnote"> ↩︎</a></li><li id="fn:6">Visual SLAM: Why bundle adjust?, ICRA2019<a href="#fnref:6" rev="footnote"> ↩︎</a></li><li id="fn:7">Hybrid Rotation Averaging: A Fast and Robust Rotation AveragingApproach, CVPR 2021<a href="#fnref:7" rev="footnote"> ↩︎</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> MathUtilities </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS basic usage and manager</title>
      <link href="/blogs/2023/01/16/ROS%20basic%20manager/"/>
      <url>/blogs/2023/01/16/ROS%20basic%20manager/</url>
      
        <content type="html"><![CDATA[<h3 id="ros编译">ROS编译</h3><ul><li>catkin_make是cmake，make的进一步封装。路径位于workspace下，src之上使用:<code>catkin_make</code>ros会自己找到src下面的源代码，并开始build，如果src下面有好几个源代码，就通过DCATKIN_WHITELIST_PACKAGES指定一个就行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_make -DCATKIN_WHITELIST_PACKAGES=<span class="hljs-string">"package1;package2"</span><br></code></pre></td></tr></table></figure><ul><li><p>安装则<code>catkin_make install</code>,使用<code>catkin_make -DCMAKE_INSTALL_PREFIX=/opt/ros/groovy install</code>指定要安装在哪里。</p></li><li><p>清理安装文件<code>catkin_make clean</code>。</p><a id="more"></a></li></ul><h3 id="环境配置">环境配置</h3><ul><li><p>如果发现ros依赖的python2和conda使用的python3版本出现冲突，需要使用<code>catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3</code>来手动选择版本，但是一味的设置python3，会导致ros本身出现不小的问题。</p></li><li><p>按照opencv_contrib官网的命令，找到对应版本的opencv和opencv_contrib（3.4.19），重新编译了带有opencv_contrib的opencv（之前版本是3.2.0），中间由于版本问题，搞错了很多次。最终opencv安装于：/usr/local/include/opencv2，/usr/local/bin/和/usr/local/lib</p></li></ul><h3 id="常见操作">常见操作</h3><ul><li>查看ros版本</li></ul><p><code>rosversion -d</code>，或者<code>rosparam get /rosdistro</code></p><ul><li>查看某个软件的版本</li></ul><p><code>pkg-config --modversion ***</code></p><p>​ pkg-config 是通过.pc文件查找看有那些库文件的。</p><p>​ 默认情况下，会去 prefix/lib/pkgconfig/ 路径下查找，具体到 Linux系统，就是 /usr/lib/pkgconfig/ 目录，若找不到，则会去 PKG_CONFIG_PATH环境变量指定的路径下查找。因此，如果我们安装的库文件不在系统环境变量中，需要将其添加到PKG_CONFIG_PATH 中.</p><p>​ 如果实在是找不到，那么可以根据这个<a href="https://blog.csdn.net/PecoHe/article/details/97476135">教程</a>手动创建一个。</p><blockquote><p>e.g. 查看opencv的版本</p><p><code>pkg-config --modversion opencv</code></p><p>3.2.0</p><p><code>pkg-config --cflags opencv</code></p><p>-I/usr/include/opencv</p><p><code>pkg-config --cflags --libs opencv</code></p><p>-I/usr/include/opencv -lopencv_shape -lopencv_stitching-lopencv_superres -lopencv_videostab -lopencv_aruco -lopencv_bgsegm-lopencv_bioinspired -lopencv_ccalib -lopencv_datasets -lopencv_dpm-lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf-lopencv_line_descriptor -lopencv_optflow -lopencv_video -lopencv_plot-lopencv_reg -lopencv_saliency -lopencv_stereo -lopencv_structured_light-lopencv_phase_unwrapping -lopencv_rgbd -lopencv_viz-lopencv_surface_matching -lopencv_text -lopencv_ximgproc-lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_xobjdetect-lopencv_objdetect -lopencv_ml -lopencv_xphoto -lopencv_highgui-lopencv_videoio -lopencv_imgcodecs -lopencv_photo -lopencv_imgproc-lopencv_core</p><p><code>sudo find / -iname ``"*opencv*"</code>查看ubuntu中有那些地方包含了opencv</p><p>找到当前仓库中的opencv.pc的路径是在/usr/lib/x86_64-linux-gnu/pkgconfig/opencv.pc。猜测其他的pc可能在镜像制作的时候，也是被放在这里。</p></blockquote><ul><li>刷新当前环境，有时候找不到ros命令就需要刷新环境了。</li></ul><p><code>source ./devel/setup.bash</code></p><ul><li>查看bag中的信息</li></ul><p><code>rosbag info -y outdoor.bag</code></p><ul><li>运行bag文件</li></ul><p><code>rosbag play ourdoor.bag</code></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker用法进阶</title>
      <link href="/blogs/2021/01/18/Docker%E7%94%A8%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
      <url>/blogs/2021/01/18/Docker%E7%94%A8%E6%B3%95%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>泡泡机器人SLAM与你一同成长<font color="green">❤</font></p><p>使用之前先看看本地都有哪些镜像和容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker ps -a<br></code></pre></td></tr></table></figure><p>查看现有容器以及状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONTAINER ID   IMAGE                                              COMMAND                  CREATED         STATUS                   PORTS                                       NAMES<br>0ac8c062fa10   pointclouddl:segmentation                          <span class="hljs-string">"/bin/sh -c 'service…"</span>   8 minutes ago   Up 8 minutes             6006/tcp, 50051/tcp, 0.0.0.0:2224-&gt;22/tcp   brave_kilby<br>cd8b9c9c5b07   stereolabs/zed:3.0-gl-devel-cuda10.0-ubuntu18.04   <span class="hljs-string">"/bin/bash"</span>              4 weeks ago     Exited (0) 5 hours ago                                               jolly_feynman<br>af07110a5157   stereolabs/kalibr                                  <span class="hljs-string">"/ros_entrypoint.sh …"</span>   4 weeks ago     Exited (0) 4 weeks ago                                               modest_leakey<br></code></pre></td></tr></table></figure><p>e.g.现有用于laser slam的镜像,设置了界面，ssh，基于amazinghao/ubuntu:graph_slam_clean镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONTAINER ID   IMAGE                                COMMAND          CREATED         STATUS         PORTS                            NAMES<br>fe7323d95d8f   amazinghao/ubuntu:graph_slam_clean   <span class="hljs-string">"./startup.sh"</span>   9 seconds ago   Up 7 seconds   22/tcp, 0.0.0.0:5900-&gt;5900/tcp   laser_slam_env<br></code></pre></td></tr></table></figure><p>一些容器内部设置必须在创建的时候就设置好，不然就只能重新创建。比如端口映射，文件夹挂载，设置别名，虚拟内存设置，时区设置等。</p><a id="more"></a><h2 id="使用进阶"><strong>使用进阶</strong></h2><h3 id="端口映射"><strong>端口映射</strong></h3><blockquote><p>列举几个需要用到网络端口的情况：</p><ol type="1"><li>使用Docker环境进行深度学习网络训练时，需要将对应的Pytorch日志通过浏览器的方式打开查看，但是Docker是没有图形化界面的，因此需要通过端口映射的方式将Docker环境中的端口映射到本地。在本地打开浏览器查看。</li><li>使用Docker环境使用ROS运行程序，需要RVIZ进行可视化。</li><li>使用Marsim等仿真环境，需要一个可视化界面进行渲染。</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -it -p 5900:5900 paopaorobot/ubuntu-xfce-vnc<br></code></pre></td></tr></table></figure><ul><li><code>-p</code>，容器内部的 5900 端口映射到本地主机的 5900端口上。访问本地的</li><li>可以同时开启多个端口映射。</li><li>容器内的网络是隔离的，其中的<code>127.0.0.1</code>指向容器本身。也可以通过指定<code>--network-host</code>共用宿主机网络。</li></ul><h4 id="查看端口映射">查看端口映射</h4><blockquote><p>查看一个容器中已经映射的端口</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port containerId<br></code></pre></td></tr></table></figure><ul><li>即可查看容器端口映射情况。</li></ul><h3 id="文件夹挂载"><strong>文件夹挂载</strong></h3><blockquote><p>Docker中是固定了环境的，其中不包含数据和代码，避免容器关闭时代码和数据丢失。容器中修改相关的代码，在本地同时会被更新。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -i -t -v /Data:/data amazinghao/ubuntu<br></code></pre></td></tr></table></figure><ul><li><code>-v</code>，将本地的Data路径挂载到容器中的/data路径下。</li><li>同样可以同时挂载多个路径。</li></ul><h3 id="拷贝文件"><strong>拷贝文件</strong></h3><blockquote><p>这里不建议拷贝数据或者代码到容器中，Docker设计时是环境和代码分离的，代码和数据可以放在本地。容器只负责环境管理。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker cp host_path containerID:container_path<br></code></pre></td></tr></table></figure><ul><li>从主机复制到容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker cp containerID:container_path host_path<br></code></pre></td></tr></table></figure><ul><li>从容器复制到主机</li></ul><h3 id="容器打包成镜像"><strong>容器打包成镜像</strong></h3><blockquote><p>将现有容器环境打包成镜像，方便后续使用或跨平台使用</p><p>Note that the code file and data file should <strong>not</strong> bepackaged into the image and only environment should be in there</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker commit -a <span class="hljs-string">"amazinghao"</span> -m <span class="hljs-string">"for point cloud deep learning environment"</span> dc1e2f6fcf8d pointclouddl:segmentation<br></code></pre></td></tr></table></figure><ul><li>-a, author info</li><li>-m, commit message</li><li>dc1e2f6fcf8d, container id, which is unique</li><li>the last parameter is the new image name and its tag. The new imagename should be lowercase</li></ul><p>在推送到云端时，需要和云端仓库中的镜像名字保持一致。那么可能就会用到<code>tag</code>命令。例如:将462f5c932e5c重命名为amazinghao/ubuntu:dev</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag 462f5c932e5c amazinghao/ubuntu:dev<br></code></pre></td></tr></table></figure><ul><li>dev即为新的标签，这样做将会创建一个新的镜像。</li></ul><p>也可以将<code>hdl_graph_slam:graph_slam_updated</code>重命名为<code>amazinghao/ubuntu:graph_slam_updated</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag hdl_graph_slam:graph_slam_updated amazinghao/ubuntu:graph_slam_updated<br></code></pre></td></tr></table></figure><p>再开始推送即可。</p><h3 id="设置别名"><strong>设置别名</strong></h3><blockquote><p>设置容器的别名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --name=laser_slam_env<br></code></pre></td></tr></table></figure><ul><li>注意别名的设置尽量放置在命令行中靠前的位置。</li></ul><h3 id="环境变量设置">环境变量设置</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-builtin-name">run</span> -i -t -e <span class="hljs-attribute">TZ</span>=<span class="hljs-string">"Asia/Shanghai"</span> -e <span class="hljs-attribute">SSHPW</span>=xxx amazinghao/ubuntu bin/bash<br></code></pre></td></tr></table></figure><ul><li><code>-e TZ="Asia/Shanghai"</code>，设置时区，使得容器内部的时间和宿主机时间保持一致，提升日志的可读性。</li><li><code>-e SSHPW=xxx</code>，设置密码。</li><li><code>bin/bash</code>，这个表示容器启动时执行的命令，必须有<code>-it</code>才能生效。这样容器在退出时容器转为后台运行。</li></ul><h3 id="虚拟内存设置">虚拟内存设置</h3><blockquote><p>常见的情况是，在深度学习环境Pytorch的Dataloader中<code>num_works</code>设置较大时，太多数据加载到内存中时就会报错。e.g.</p><p>RuntimeError: DataLoader worker (pid 43257) is killed by signal: Buserror. It is possible that dataloader's workers are out of sharedmemory. Please try to raise your shared memory limit.</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-builtin-name">run</span> -i -t <span class="hljs-attribute">-shm_size</span>=32g amazinghao/ubuntu<br></code></pre></td></tr></table></figure><ul><li><code>-shm_size=32g</code></li></ul><h3 id="检查镜像"><strong>检查镜像</strong></h3><blockquote><p>检查镜像中的现有环境，包括镜像生成时的一些设置等</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker image inspect pointclouddl:segmentaton<br></code></pre></td></tr></table></figure><h3 id="检查容器"><strong>检查容器</strong></h3><blockquote><p>同理检查容器的内部细节</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">docker inspect containerID<br></code></pre></td></tr></table></figure><ul><li>它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</li></ul><h3 id="导出镜像"><strong>导出镜像</strong></h3><h4 id="export-import">export &amp; import</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"># ex<span class="hljs-keyword">port</span> current image<br><span class="hljs-title">docker</span> ex<span class="hljs-keyword">port</span> image_id &gt; current.tar<br># <span class="hljs-keyword">import</span> current image<br><span class="hljs-title">docker</span> <span class="hljs-keyword">import</span> image_name &lt; current.tar<br></code></pre></td></tr></table></figure><h4 id="save-load">save &amp; load</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">save</span> 0<span class="hljs-selector-tag">fdf2b4c26d3</span> &gt; <span class="hljs-selector-tag">hangge_server</span><span class="hljs-selector-class">.tar</span><br><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">save</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">images</span><span class="hljs-selector-class">.tar</span> <span class="hljs-selector-tag">postgres</span><span class="hljs-selector-pseudo">:9.6</span> <span class="hljs-selector-tag">mongo</span><span class="hljs-selector-pseudo">:3.4</span><br><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">load</span> &lt; <span class="hljs-selector-tag">hangge_server</span><span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure><p>​ Differences from image sizes, image rename, multiple-containers intoone single image, application scenarios, more detail could be seen at <a href="https://www.hangge.com/blog/cache/detail_2411.html">here</a></p><h3 id="使用dockerfile构建进行">使用Dockerfile构建进行</h3><p>可以先参考<a href="https://blog.kamino.link/2022/10/17/docker%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">这里</a>，我一般都用官方镜像，然后手动创建。主要涉及到Dockerfile内部的一些命令的使用，可以配合xfce的相关内容构建，又可可视化又可深度学习的环境。</p><hr><h2 id="使用实例"><strong>使用实例</strong></h2><h3 id="new-a-container-for-slam">New a container for SLAM</h3><p>The images for SLAM are mostly built from the<strong>paopaorobot/ros-vnc</strong>, so the visualization module isembedded into the image. Any thing related to the visualization could beset as you wish.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># open a new container using the xfce&amp;vnc for visualization, host port is 5900, host mount dir is /Data, extra setting is the resolution which is 1080P</span><br>sudo docker run -i -t -p 5900:5900 -v /Data:/data -e RESOLUTION=1920x1080 paopaorobot/ubuntu-xfce-vnc<br><span class="hljs-comment"># similar to the upper one, amazinghao/ubuntu is build based on the ros-vnc image</span><br>sudo docker run -i -t -p 5900:5900 -v /Data:/data -e RESOLUTION=1920x1080 amazinghao/ubuntu<br><span class="hljs-comment"># similar to the upper two</span><br>sudo docker run -i -t -p 5900:5900 -v /Data:/data -e RESOLUTION=1920x1080 paopaorobot/ros-vnc:latest<br><span class="hljs-comment"># windows docker container creation commond</span><br><span class="hljs-comment"># Note that the alias name should be placed frontier and the dir mount should be carefully set</span><br>docker run -itd --name=laser_slam_env -p 5900:5900 -e SSHPW=usmn9a -v /D/data/Publicdatasets/:/data -v /E/Vs15WorkSpace/catkin_ws_lidar:/workspsace_slam  -e RESOLUTION=1920x1080 amazinghao/ubuntu:graph_slam_clean<br></code></pre></td></tr></table></figure><h3 id="new-a-container-for-deep-learning-with-cuda">New a container forDeep learning with CUDA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -itd --gpus all --privileged=<span class="hljs-literal">true</span> -v /home/amazinghao/Data:/data-lyh -v /home/amazinghao/PointSeg:/pointcloud_seg_code -p 2224:22 -e SSHPW=xxx pointclouddl:segmentation<br></code></pre></td></tr></table></figure><ul><li><strong>--gpus all</strong> , only this the Nvidia driver could beaccessed, check <a href="https://github.com/traveller59/spconv/issues/185#issuecomment-655975873">this</a></li><li><strong>--privileged=true</strong> , to obtain the 'real' permissionto mount file or others. <strong>This one is veryimportant</strong></li><li><strong>-v</strong> , mount the host dir or file to the container.The dir should begin with '/' and connected by ':'</li><li><strong>-e SSHPW</strong> , set the ssh connect password</li><li><strong>-p</strong> , two ports are opened for both ssh orvisualize. Only if the visualization module is activated, the VNC-Vieweris available.</li><li>-<strong>d</strong> , the container should be closed manually, andthe local command will not convert to the container.</li></ul><h3 id="after-using-run-to-new-container">After using <code>run</code>to new container</h3><p>Using "run" to new a new container and once you quit the container,the container will immediately be closed. The container that you newright now will stay started and STATUS will be like: <strong>Up 8minutes</strong>. Only thing you should do, if you are using VNC-Viewerfor visualization, is as followings:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker start 0ac8c062fa10<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">amazinghao@xixi-ubuntu:~$ sudo docker attach 0ac8c062fa10<br>root@0ac8c062fa10:~<span class="hljs-comment"># nvidia-smi</span><br>Mon Jan 18 04:55:55 2021       <br>+-----------------------------------------------------------------------------+<br>| NVIDIA-SMI 450.80.02    Driver Version: 450.80.02    CUDA Version: 11.0     |<br>|-------------------------------+----------------------+----------------------+<br>| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |<br>|                               |                      |               MIG M. |<br>|===============================+======================+======================|<br>|   0  GeForce GTX 108...  Off  | 00000000:01:00.0  On |                  N/A |<br>| 24%   46C    P5    18W / 250W |    271MiB / 11175MiB |      0%      Default |<br>|                               |                      |                  N/A |<br>+-------------------------------+----------------------+----------------------+<br>                                                                               <br>+-----------------------------------------------------------------------------+<br>| Processes:                                                                  |<br>|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |<br>|        ID   ID                                                   Usage      |<br>|=============================================================================|<br>+-----------------------------------------------------------------------------+<br>root@0ac8c062fa10:~<span class="hljs-comment"># nvcc -V</span><br>nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) 2005-2019 NVIDIA Corporation<br>Built on Sun_Jul_28_19:07:16_PDT_2019<br>Cuda compilation tools, release 10.1, V10.1.243<br></code></pre></td></tr></table></figure><p>When you exit the container, the correspond container's STATUS willbe some thing like: <strong>Exited (0) 4 seconds ago</strong>. But ifyou only close vscode (connnet by Remote Container), the container willnot be closed.</p><h3 id="also-you-can-using-exec-to-new-a-container">Also you can using<code>exec</code> to new a container</h3><blockquote><p>The container will not be stopped, while <code>exec</code>command.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it af07110a5157 /bin/bash<br>docker attach previous_container_id<br></code></pre></td></tr></table></figure><h3 id="new-a-container-for-zed-sdk">New a container for zed sdk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Open a container for zed stereo camera. The image contains a visualization module using "X11"</span><br>sudo docker run --gpus all -it --privileged --network=host stereolabs/zed:3.0-runtime-cuda10.0-ubuntu18.04<br></code></pre></td></tr></table></figure><h3 id="zed-docker-display-support">ZED docker display support</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhost +si:localuser:root<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run --gpus all -it --privileged -e DISPLAY=<span class="hljs-variable">$DISPLAY</span> -v /tmp/.X11-unix:/tmp/.X11-unix stereolabs/zed:3.0-gl-devel-cuda10.0-ubuntu18.04<br>sudo docker attach containerID<br></code></pre></td></tr></table></figure><ul><li>The camera connection can be verified using lsusb:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsusb -d 2b03: -vvv<br></code></pre></td></tr></table></figure><ul><li>in case of replug/hotplug, mount all the dev folder</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --gpus all -it -v /dev:/dev --privileged stereolabs/zed:3.0-runtime-cuda10.0-ubuntu18.04<br></code></pre></td></tr></table></figure><h4 id="problem">problem</h4><ul><li>the ZED_Depth_Viewer didn't work somehow.</li></ul><h3 id="zed_ros_wapper-cuda-for-a-ros-bag">zed_ros_wapper &amp; cuda fora ros bag</h3><p>add a ros melodic to zed-sdk and build the zed_ros_wapper in itID:cd8b9c9c5b07</p><p>stereolabs/zed:3.0-gl-devel-cuda10.0-ubuntu18.04</p><h3 id="new-a-container-for-kalibr">New a container for kalibr</h3><p>container ID:af07110a5157 is the one which rebuild theros_kalibr_system ubuntu version:16.04 ros version:kinetic</p><p><code>--show-extraction</code></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS开发Tricks</title>
      <link href="/blogs/2021/01/17/VS%E5%BC%80%E5%8F%91Tricks/"/>
      <url>/blogs/2021/01/17/VS%E5%BC%80%E5%8F%91Tricks/</url>
      
        <content type="html"><![CDATA[<h4 id="用户宏">用户宏</h4><p>  由于在开发时不可避免的会遇到多个环境，在不同环境之间进行切换是一个很麻烦的事情，因此使用用户宏可以很好的帮助我们进行环境切换和别名替换，便于多人协同开发。<br>在属性管理器中选中任意配置环境中的<code>Microsoft.Cpp.x64.user</code>，弹出如下页面： <img src="/blogs/.io//用户宏.png" alt="用户宏"><a id="more"></a> 用一个你知道的缩写来作为名字，e.g.ThirdParty，对应的本地路径作为值即可。<br>在后续其他工程使用时可以使用$(ThirdParty)来表示该本地路径。非常方便。</p><h6 id="tips">Tips</h6><p>也可以选择将其设置为开发环境，即在代码编译过程中会使用你定义好的路径中的环境进行链接。<br>##### 生成事件  本地开发前或者后，很可能需要自定义生成的可执行文件的路径，但是又不想修改系统默认生成的路径<code>$(SolutionDir)$(Platform)\$(Configuration)\</code><br>那么可以通过两种方式做到上述操作：<br>-使用Cmake管理工程项目；（这里已经使用VS管理了，就先不介绍这种方法啊，具体可以参考CMake-practice这个文档）- 可以尝试使用 <strong>生成事件</strong>, 如下图所示：<br><img src="/blogs/.io//生成事件.jpg" alt="生成事件"><br>其实这里生成事件使用的就是Windows自带的DOS控制台<a href="https://whu-lyh.github.io/2020/03/21/WindowBat/">WindowsBat</a>的命令。<br>1.例如你要将本工程中的.h文件拷贝到上述自定义宏路径<code>$(ThirdParty)\include</code>下。<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">XCOPY <span class="hljs-string">"..\$(ProjectName).h"</span> <span class="hljs-string">"$(ThirdParty)\include"</span> <span class="hljs-string">/D</span> <span class="hljs-string">/R</span> <span class="hljs-string">/Y</span><br></code></pre></td></tr></table></figure> 2.再例如你要将本工程中生成的lib和dll文件分别拷贝到自定义的<span class="math inline">\((ThirdParty)\bin`和`\)</span>(ThirdParty)`下<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">XCOPY <span class="hljs-string">"..\x64\$(ProjectName).dll"</span> <span class="hljs-string">"$(ThirdParty)\bin"</span> <span class="hljs-string">/D</span> <span class="hljs-string">/R</span> <span class="hljs-string">/Y</span> &amp; XCOPY <span class="hljs-string">"..\x64\$(ProjectName).lib"</span> <span class="hljs-string">"$(ThirdParty)\lib"</span> <span class="hljs-string">/D</span> <span class="hljs-string">/R</span> <span class="hljs-string">/Y</span><br>XCOPY <span class="hljs-string">"..\x64\$(ProjectName)_d.dll"</span> <span class="hljs-string">"$(ThirdParty)\bin"</span> <span class="hljs-string">/D</span> <span class="hljs-string">/R</span> <span class="hljs-string">/Y</span> &amp; XCOPY <span class="hljs-string">"..\x64\$(ProjectName)_d.lib"</span> <span class="hljs-string">"$(ThirdParty)\lib"</span> <span class="hljs-string">/D</span> <span class="hljs-string">/R</span> <span class="hljs-string">/Y</span><br></code></pre></td></tr></table></figure> ###### Tips 注意DOS命令如果写错会导致项目生成失败；<br>当你命令中路径出现错误，或者待处理的文件不存在时，也会导致生成失败；<br>当你的工程项目没有生成（源代码没有修改）时，上述生成事件命令也不会执行。<br>##### 调试 - 调用堆栈</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker可视化界面</title>
      <link href="/blogs/2020/07/11/Docker%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
      <url>/blogs/2020/07/11/Docker%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>泡泡机器人SLAM与你一同成长<font color="green">❤</font></p><h3 id="可视化"><strong>可视化</strong></h3><p>其实关键就是添加一个可视化的应用，如X11 apps (and GL), is the key fordisplay inside the docker，e.g.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># This file is covered by the LICENSE file in the root of this project.</span><br>docker build -t api --build-arg uid=$(id -g) --build-arg gid=$(id -g) .<br>docker run --privileged \<br>       -ti --rm -e DISPLAY=<span class="hljs-variable">$DISPLAY</span> \<br>       -v /tmp/.X11-unix:/tmp/.X11-unix \<br>       -v <span class="hljs-variable">$1</span>:/home/data/ \<br>       api<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --privileged -ti --rm -e DISPLAY=<span class="hljs-variable">$DISPLAY</span> -v /tmp/.X11-unix:/tmp/.X11-unix -v /home/amazinghao/Data:/home/data/ api<br></code></pre></td></tr></table></figure><ul><li><p><code>-e DISPLAY=$DISPLAY</code>，after this the gui inside thedocker will show in the host machine</p></li><li><p><code>--privileged</code>，will make all extend equippmentavailable for the docker</p></li></ul><a id="more"></a><h4 id="打开界面"><strong>打开界面</strong></h4><p>有几种方式可以在Docker中设置界面，openbox，vnc等。这里选择的是ros-vnc来进行可视化界面的，vnc其实是一个功能，ubuntu自带的某些软件也有这个功能,VNC-Viewer免费版即可。比如直接启动如下容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 5900:5900 paopaorobot/ros-vnc<br></code></pre></td></tr></table></figure><p><strong>调整分辨率</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 5900:5900 -e RESOLUTION=1980x1200 paopaorobot/ros-vnc<br></code></pre></td></tr></table></figure><p><strong>通过ssh连接</strong></p><p>打开本机控制台，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 2222:22 paopaorobot/ros-vnc<br></code></pre></td></tr></table></figure><p><code>ssh -o 'UserKnownHostsFile=/dev/null' root@localhost -p [port]</code>port表示端口号，保持和开启镜像时映射的端口一致。在控制台使用下述ssh链接打开的容器：<strong><code>ssh root@localhost -p 2222</code></strong></p><p>也可以设置自定义的ssh密码,如asc123</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 2222:22 -e SSHPW=asc123 paopaorobot/ros-vnc<br></code></pre></td></tr></table></figure><p>也可以随机选择端口号，P会系统自动给一个端口，可以避免端口冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -P paopaorobot/ros-vnc<br></code></pre></td></tr></table></figure><p>通过<code>docker port</code>查看当前开了哪些端口，然后找到想要的端口</p><h4 id="同时使用ssh和可视化界面"><strong>同时使用ssh和可视化界面</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">docker run -it -p <span class="hljs-number">5900</span>:<span class="hljs-number">5900</span> -p <span class="hljs-number">2222</span>:<span class="hljs-number">22</span> paopaorobot/ros-vnc<br>docker run -itd -p <span class="hljs-number">5900</span>:<span class="hljs-number">5900</span> -e SSHPW=usmn9a  -e RESOLUTION=<span class="hljs-number">1920</span>x1280 -v /d/data:/data -p <span class="hljs-number">2222</span>:<span class="hljs-number">22</span> amazinghao/ubuntu:graph_slam_updated<br></code></pre></td></tr></table></figure><ul><li><p><code>-p</code>将本地5900端口映射到容器，服务于vnc进行可视化</p></li><li><p><code>-e</code> SSHPW= 设置ssh连接的密码为xxx</p></li><li><p><code>-p</code>将本地2222端口映射到容器，服务于ssh进行连接</p></li><li><p><code>-e RESOLUTION=1920x1280</code> 设置分辨率为1080p</p></li><li><p><code>-v</code>表示将本地D:/data路径挂在到容器对应的/data下，amazinghao/ubuntu:graph_slam_updated为镜像名。</p></li></ul><h4 id="退出之后再打开"><strong>退出之后再打开</strong></h4><ul><li>按照前述方法用vnc或者ssh打开Docker的一个镜像并生成容器之后，通过exit退出当前容器，若是后续还想再进去，此时如果通过run命令就会再次产生一个容器，而你在之前的容器中所做的操作就不会保留。<br></li><li>因此这时需要通过start，打开之前操作过现在状态是exit的容器，用attach建立连接，此时如果通过<code>docker ps -a</code>可以发现之前的容器又可以打开了,并且端口号是可用的。<br></li><li>另外如果想要在exit容器时，容器不退出，应该使用exec命令打开镜像<code>docker exec -it 24d1106f11b8 /bin/bash</code>,此时也会发现容器时可用的了。</li></ul><h3 id="深度学习环境的界面可视化">深度学习环境的界面可视化</h3><p>在使用3D GaussianSplatting进行场景重建时，有一个可视化界面需要使用，因此需要直接能够从Docker容器中打开，在容器初始化时需要做一些额外的配置，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --name=3dgs -e TZ=<span class="hljs-string">"Asia/Shanghai"</span>--shm-size=32g --gpus <span class="hljs-string">'all,"capabilities=compute,utility,graphics"'</span> --privileged=<span class="hljs-literal">true</span> -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix<span class="hljs-variable">$DISPLAY</span> -v /home/amazinghao/Data:/public -v /home/amazinghao:/workspace pytorch/pytorch:2.1.2-cuda12.1-cudnn8-devel /bin/bash<br></code></pre></td></tr></table></figure><ul><li>既有了cuda支持，又有了可视化界面。</li></ul><h3 id="docker远程debug"><strong>Docker远程Debug</strong></h3><p>首先代码是在本地，以文件夹挂载的方式挂载到容器中。</p><h4 id="python文件的debug"><strong>Python文件的Debug</strong></h4><p>这里借助的是vscode来实现代码Debug。首先通过Remote-Container/Remote-SSH插件连接到容器中，点击运行-&gt;打开配置，即如下类似的文件settings.json（位于本地.vscode路径下）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>    <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>    <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>    <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.2.0"</span>,<br>    <span class="hljs-string">"configurations"</span>: [<br>        &#123;<br>            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Python: 当前文件"</span>,<br>            <span class="hljs-string">"type"</span>: <span class="hljs-string">"python"</span>,<br>            <span class="hljs-string">"request"</span>: <span class="hljs-string">"launch"</span>,<br>            <span class="hljs-string">"program"</span>: <span class="hljs-string">"main.py"</span>, <span class="hljs-comment"># 主函数入口</span><br>            <span class="hljs-string">"console"</span>: <span class="hljs-string">"integratedTerminal"</span>,<br>            <span class="hljs-string">"justMyCode"</span>: true,<br>            <span class="hljs-string">"args"</span>: [ <span class="hljs-regexp">//</span>在这里写命令行的参数，如下<br>                <span class="hljs-string">"--dataset"</span>, <span class="hljs-string">"ETH"</span>,<br>                <span class="hljs-string">"--estimator"</span>, <span class="hljs-string">"4DOF"</span>,<br>                <span class="hljs-string">"--topk"</span>, <span class="hljs-string">"6"</span>,<br>                <span class="hljs-string">"--inlierd"</span>, <span class="hljs-string">"0.2"</span>,<br>                <span class="hljs-string">"--tau_2"</span>, <span class="hljs-string">"0.5"</span>,<br>                <span class="hljs-string">"--rr"</span><br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>设置好之后可以F5开启调试了，打断点和单步调试都可以用。</p><h4 id="c的debug"><strong>C++的Debug</strong></h4><p>TODO</p><h3 id="其他问题"><strong>其他问题</strong></h3><p>vnc首次可以连接成功，但是再次连接时失败，打开vnc5900时提示，connectedclosed unxepectedly。</p><p><font color="red"><strong>解决方案：</strong></font>这是需要使用start将上次的docker容器打开就可以了，连接失败的原因可能是因为端口被占用了。</p><iframe src="//player.bilibili.com/player.html?aid=882822967&amp;bvid=BV1uK4y1k7Q1&amp;cid=180178150&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pcl中的体素滤波</title>
      <link href="/blogs/2020/06/11/pcl%E4%B8%AD%E7%9A%84%E4%BD%93%E7%B4%A0%E6%BB%A4%E6%B3%A2/"/>
      <url>/blogs/2020/06/11/pcl%E4%B8%AD%E7%9A%84%E4%BD%93%E7%B4%A0%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="体素滤波">体素滤波</h3><p>  Voxel滤波作为一种很常见的滤波方法，但是其PCL内部代码却值得学习，因此今天转载一篇关于pcl中实现的体素滤波的方法。<br>基本上参考博客：https://blog.csdn.net/u013630299/article/details/105661194<a id="more"></a> #### Voxel_grid.h  需要添加头文件：<code>#include &lt;pcl/filters/voxel_grid.h&gt;</code><img src="/blogs/.io//voxel_grid.png" alt="voxelgrid"><br><img src="https://img-blog.csdnimg.cn/20200421162454452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM2MzAyOTk=,size_16,color_FFFFFF,t_70" style="width: 1118px;">  必须保证Dx&gt;hx，Dy&gt;hy(这两个条件是必须)，第四步的时候是计算voxel空间索引.准确降采样就是在每个voxel索引里面取中值，或者随机取一个点，然后输出的点云就是降采样后的点云.也就是说，下采样后的点云还是原始点云中的点？<font color="red"><strong>❤</strong></font></p><h4 id="approximate_voxel_grid.h">Approximate_voxel_grid.h</h4><p>  需要添加头文件：<code>#include &lt;pcl/filters/approximate_voxel_grid.h&gt;</code>核心源码也比较短，还有待研究。 <img src="/blogs/.io//approximate_voxel_grid.png" alt="approximatevoxelgrid"><img alt height="397" src="https://img-blog.csdnimg.cn/20200421163734565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM2MzAyOTk=,size_16,color_FFFFFF,t_70" width="586">  和exact downsampling的前四步一样，先算出voxel的空间索引，然后通过<strong>哈希函数</strong>映射到对应的容器里面，这里假设有100个容器，按照图里面给的例子，以h%container作为hash函数映射的值，放到对应的容器里面，这样的话会出现什么情况呢，16,116对应的容器是一样的，而两个h对应的hx，hy，hz是不一样的，这就是哈希冲突。怎么处理哈希冲突呢？<br><img src="/blogs/.io//hash_conflict.png" alt="voxelgrid"><br><img alt height="173" src="https://img-blog.csdnimg.cn/20200421170651371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM2MzAyOTk=,size_16,color_FFFFFF,t_70" width="579">  把原来容器里面的点全都取出来，清空，随机取其中的一个点作为输出，然后把新的点放进来，继续填容器的操作。相当于是拿了100个容器，一直从一堆点里面淘点，10000个点放到100个容器里面必然会有索引的冲突，一有冲突就把之前放进去的点拿出来，随机取一个点作为输出，清空，再往里面放新的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PointT&gt; <span class="hljs-keyword">void</span><br>pcl::ApproximateVoxelGrid&lt;PointT&gt;::applyFilter (PointCloud &amp;output)<br>&#123;<br>  <span class="hljs-keyword">int</span> centroid_size = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">if</span> (downsample_all_data_)<br>    centroid_size = boost::mpl::<span class="hljs-built_in">size</span>&lt;FieldList&gt;::value;<br><br>  <span class="hljs-comment">// ---[ RGB special case</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;pcl::PCLPointField&gt; fields;<br>  <span class="hljs-keyword">int</span> rgba_index = <span class="hljs-number">-1</span>;<br>  rgba_index = pcl::getFieldIndex (*input_, <span class="hljs-string">"rgb"</span>, fields);<br>  <span class="hljs-keyword">if</span> (rgba_index == <span class="hljs-number">-1</span>)<br>    rgba_index = pcl::getFieldIndex (*input_, <span class="hljs-string">"rgba"</span>, fields);<br>  <span class="hljs-keyword">if</span> (rgba_index &gt;= <span class="hljs-number">0</span>)<br>  &#123;<br>    rgba_index = fields[rgba_index].offset;<br>    centroid_size += <span class="hljs-number">3</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; histsize_; i++) <br>  &#123;<br>    history_[i].count = <span class="hljs-number">0</span>;<br>    history_[i].centroid = Eigen::VectorXf::Zero (centroid_size);<br>  &#125;<br>  Eigen::VectorXf scratch = Eigen::VectorXf::Zero (centroid_size);<br><br>  output.points.resize (input_-&gt;points.<span class="hljs-built_in">size</span> ());   <span class="hljs-comment">// size output for worst case</span><br>  <span class="hljs-keyword">size_t</span> op = <span class="hljs-number">0</span>;    <span class="hljs-comment">// output pointer</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> cp = <span class="hljs-number">0</span>; cp &lt; input_-&gt;points.<span class="hljs-built_in">size</span> (); ++cp) <br>  &#123;<br>    <span class="hljs-keyword">int</span> ix = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt; (<span class="hljs-built_in">floor</span> (input_-&gt;points[cp].x * inverse_leaf_size_[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">int</span> iy = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt; (<span class="hljs-built_in">floor</span> (input_-&gt;points[cp].y * inverse_leaf_size_[<span class="hljs-number">1</span>]));<br>    <span class="hljs-keyword">int</span> iz = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt; (<span class="hljs-built_in">floor</span> (input_-&gt;points[cp].z * inverse_leaf_size_[<span class="hljs-number">2</span>]));<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hash = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; ((ix * <span class="hljs-number">7171</span> + iy * <span class="hljs-number">3079</span> + iz * <span class="hljs-number">4231</span>) &amp; (histsize_ - <span class="hljs-number">1</span>));<br>    he *hhe = &amp;history_[hash];<br>    <span class="hljs-keyword">if</span> (hhe-&gt;count &amp;&amp; ((ix != hhe-&gt;ix) || (iy != hhe-&gt;iy) || (iz != hhe-&gt;iz))) <br>    &#123;<br>      <span class="hljs-built_in">flush</span> (output, op++, hhe, rgba_index, centroid_size);<br>      hhe-&gt;count = <span class="hljs-number">0</span>;<br>      hhe-&gt;centroid.setZero ();<span class="hljs-comment">// = Eigen::VectorXf::Zero (centroid_size);</span><br>    &#125;<br>    hhe-&gt;ix = ix;<br>    hhe-&gt;iy = iy;<br>    hhe-&gt;iz = iz;<br>    hhe-&gt;count++;<br><br>    <span class="hljs-comment">// Unpack the point into scratch, then accumulate</span><br>    <span class="hljs-comment">// ---[ RGB special case</span><br>    <span class="hljs-keyword">if</span> (rgba_index &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-comment">// fill r/g/b data</span><br>      pcl::RGB rgb;<br>      <span class="hljs-built_in">memcpy</span> (&amp;rgb, (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *&gt; (&amp;input_-&gt;points[cp])) + rgba_index, <span class="hljs-keyword">sizeof</span> (RGB));<br>      scratch[centroid_size<span class="hljs-number">-3</span>] = rgb.r;<br>      scratch[centroid_size<span class="hljs-number">-2</span>] = rgb.g;<br>      scratch[centroid_size<span class="hljs-number">-1</span>] = rgb.b;<br>    &#125;<br>    pcl::for_each_type &lt;FieldList&gt; (xNdCopyPointEigenFunctor &lt;PointT&gt; (input_-&gt;points[cp], scratch));<br>    hhe-&gt;centroid += scratch;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; histsize_; i++) <br>  &#123;<br>    he *hhe = &amp;history_[i];<br>    <span class="hljs-keyword">if</span> (hhe-&gt;count)<br>      <span class="hljs-built_in">flush</span> (output, op++, hhe, rgba_index, centroid_size);<br>  &#125;<br>  output.points.resize (op);<br>  output.<span class="hljs-built_in">width</span> = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; (output.points.<span class="hljs-built_in">size</span> ());<br>  output.<span class="hljs-built_in">height</span>       = <span class="hljs-number">1</span>;                    <span class="hljs-comment">// downsampling breaks the organized structure</span><br>  output.is_dense     = <span class="hljs-literal">false</span>;                 <span class="hljs-comment">// we filter out invalid points</span><br>&#125;   <br>&amp;emsp;&amp;emsp;为什么Dx必须&amp;gt;hx,后面的y也一样，Dx其实就是x的进位，h的表达式类似于hx*<span class="hljs-number">1</span>+hy*<span class="hljs-number">10</span>+hz*<span class="hljs-number">10</span>*<span class="hljs-number">10</span>，如果Dx=x了那必然会出现不同范围的点指到同一个索引h里面，譬如假设Dx=<span class="hljs-number">10</span>，hx可以等于<span class="hljs-number">10</span>，以（hx，hy）作为坐标的话，（<span class="hljs-number">0</span>,<span class="hljs-number">1</span>）和（<span class="hljs-number">10</span>,<span class="hljs-number">0</span>）在同一个voxel里面，显然这是不对的。<br></code></pre></td></tr></table></figure><h5 id="疑问">疑问</h5><p>我之前得到的voxel采样之后就不是原来的点云了，这个假设是怎么来的？</p>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Point Cloud </tag>
            
            <tag> PCL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux command usage</title>
      <link href="/blogs/2020/05/07/linux-command-usage/"/>
      <url>/blogs/2020/05/07/linux-command-usage/</url>
      
        <content type="html"><![CDATA[<p>一些常用的Linux的命令记录</p><h3 id="common-command">Common Command</h3><ol type="1"><li>查看当前系统的版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/issue<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>查看当前所安装的软件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg -l<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>查看某软件安装路径</li></ol><p><code>dpkg -L | grep ftp</code> 查看ftp的位置</p><a id="more"></a><ol start="4" type="1"><li>查看软件版本</li></ol><p><code>aptitude show</code> 后面跟着软件名字</p><ol start="5" type="1"><li>change the environment</li></ol><p><code>gedit ~/.bashrc</code> then add some thing and<code>sources ~/.bashrc</code></p><ol start="6" type="1"><li>删除带锁文件夹（文件）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod -R 777 文件或文件夹<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>打开隐藏文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl+h<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>创建快捷方式</li></ol><blockquote><p>以给Typora创建快捷方式为例：</p></blockquote><ul><li>首先创建一个<code>typora.desktop</code>的文件，将下列内容写入该文件中，</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Desktop Entry]<br>Name=Typora<br>Exec=/home/amazinghao/Downloads/Typora-linux-x64/bin/Typora-linux-x64/Typora<br>Type=Application<br>Icon=/home/amazinghao/Downloads/Typora-linux-x64/bin/Typora-linux-x64/resources/assets/icon/icon_512x512.png<br></code></pre></td></tr></table></figure><ul><li>然后把这个文件拷贝到系统应用目录下，<code>sudo cp typora.desktop /usr/share/applications/</code>，搞定。</li></ul><ol start="9" type="1"><li>文件解压</li></ol><ul><li>批量解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> *.tgz; <span class="hljs-keyword">do</span> tar -xvf <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ul><li>文件太大压缩包分成多个部分，解压到一个文件夹下</li></ul><blockquote><p>xxx.tar.gz.00.tar.gz.01.tar.gz.02</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cat</span> TRAIN.<span class="hljs-regexp">tar.gz.*</span> | tar -zxv<br>tar -zxv VAL.tar.gz<br></code></pre></td></tr></table></figure><ol start="10" type="1"><li>文件夹软连接</li></ol><blockquote><p>将一个文件夹软连接到另一个文件夹，但是在docker容器路径映射中没用。而且文件夹修改会同步生效。在使用ls命令时，文件夹路径后会有@符号。</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ln -s tar_dir src_dir</span><br></code></pre></td></tr></table></figure><ol start="11" type="1"><li><a href="https://www.51cto.com/article/630899.html">删除apt的缓存</a></li></ol><blockquote><p>节约磁盘空间，虽然下次再下载的时候时间会长一些。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get clean<br></code></pre></td></tr></table></figure><ol start="12" type="1"><li>服务器ssh服务开启</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/ssh status # 检查ssh服务状态<br>sudo /etc/init.d/ssh start<br>service ssh start # 或者<br></code></pre></td></tr></table></figure><blockquote><p>需要先检查是否有openssh安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install -y openssh-server vim<br></code></pre></td></tr></table></figure><ul><li>然后设置密码，才能远程连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/ssh/sshd_config # 设置允许密码连接<br>passwd #设置密码<br>service ssh restart # 重新打开ssh服务<br></code></pre></td></tr></table></figure><ol start="13" type="1"><li>服务器容器远程连接</li></ol><blockquote><p>首先服务器需要开启openssh服务</p></blockquote><ul><li>直接使用控制台终端连接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -p port_id root@server_ip<br></code></pre></td></tr></table></figure><ul><li>vscode连接</li></ul><p>需要一个插件Remote-SSH。然后点击<code>远程资源服务器</code>-<code>远程</code>，然后输入<code>ssh -p port_id root@server_ip</code>会更新配置config配置文件。比如：</p><blockquote><p>Host custom_name</p><p>​ HostName ip</p><p>​ Port 10008</p><p>​ User root</p></blockquote><ol start="14" type="1"><li>查看IP</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ifconfig<br>apt-<span class="hljs-builtin-name">get</span> install net-tools<br></code></pre></td></tr></table></figure><ol start="15" type="1"><li>清空回收站</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rm -rf ~/.<span class="hljs-built_in">local</span>/share/Trash/*<br></code></pre></td></tr></table></figure><ol start="16" type="1"><li>查看cpu的核数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /proc/cpuinfo| grep <span class="hljs-string">"cpu cores"</span>| uniq<br></code></pre></td></tr></table></figure><ol start="17" type="1"><li>如何在ubuntu中添加一个软件的快捷方式，例如Typora</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先使用vim新建一个文件</span><br>vim typora.desktop<span class="hljs-string">"</span><br><span class="hljs-string">#在文件中输入下列内容</span><br><span class="hljs-string">[Desktop Entry]</span><br><span class="hljs-string">Name=Typora</span><br><span class="hljs-string">Exec=/opt/Typora-linux-x64/Typora</span><br><span class="hljs-string">Type=Application</span><br><span class="hljs-string">Icon=/opt/Typora-linux-x64/resources/asserts/icon/icon_512x512.png</span><br><span class="hljs-string">#退出vim</span><br><span class="hljs-string">#拷贝这个文件到系统路径下</span><br><span class="hljs-string">sudo cp typora.desktop /usr/share/applications/</span><br><span class="hljs-string">#可能需要重启就出现了。</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowBat</title>
      <link href="/blogs/2020/03/21/WindowBat/"/>
      <url>/blogs/2020/03/21/WindowBat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_36838191/article/details/83046599">bat</a>中的一些语法学习，用于MicroStation多人编译</p><h2 id="parameter-setting">Parameter Setting</h2><h4 id="系统参数"><em>1、系统参数</em></h4><p>%SystemRoot% === C:(%windir% 同样)<br>%ProgramFiles% === C:Files<br>%USERPROFILE% === C:andSettings(子目录有“桌面”,“开始菜单”,“收藏夹”等)<br>%APPDATA% === C:and SettingsData<br>%TEMP% === C:<sub>1</sub>1~1(%TEM% 同样)<br>%APPDATA% === C:and SettingsData<br>%OS% === Windows_NT (系统)<br>%Path% === %SystemRoot%;%SystemRoot%;%SystemRoot%(原本的设置)<br>%HOMEDRIVE% === C: (系统盘)<br>%HOMEPATH% === and Settings :: 枚举当前的环境变量<br><a id="more"></a> #### <em>2、传递参数给批处理文件</em> ####<br>%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用%1 到 %9 顺序表示。 ## Basic Command ##<br>#### <em>0、help</em> ####<br>可以在console 输入 help /？查看 #### <em>1、echo</em> ####<br>语法: echo [{on|off}] [message]<br>ECHO [ON | OFF] 打开回显或关闭回显功能。<br>ECHO 显示当前回显设置。<br>ECHO [message] 显示信息。<br>echo off表示在此语句后所有运行的命令都不显示命令行本身；默认是on，on时会显示如：C:&gt;命令行。<br>在实际应用中我们会把这条命令和重定向符号( 也称为管道符号，一般用 &gt;&gt;&gt; ^ )结合来实现输入一些命令到特定格式的文件中。<br>#### <em>2、<span class="citation" data-cites="*">@*</span> ####<br>表示不显示@后面的命令，(在入侵过程中自然不能让对方看到你使用的命令啦)<br>@ 与 echo off相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行(只能影响当前行)。<br>Sample： <span class="citation" data-cites="echo">@echo</span> off(此语句常用于开头，表示不显示所有的命令行信息，包括此句)<br>#### </em>3、Goto* ####<br>语法：goto label (label是参数，指定所要转向的批处理程序中的行。)<br>指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。<br>label标签的名字可以随便起，但是最好是有意义的，<strong>字母前必须加个冒号“:”来表示这个字母是标签。</strong><br>goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if配合使用，根据不同的条件来执行不同的命令组。<br>#### <em>4、Rem</em> ####<br>rem 输出信息，可以用“::”代替 #### <em>5、Pause</em> ####<br>挂起，使console运行结束后不退出<br>#### <em>6、Call</em> ####<br>  语法:<code>__call [[Drive:][Path] FileName [BatchParameters]] [:label [arguments]]__</code>  参数: [Drive:][Path] FileName指定要调用的批处理程序的位置和名称。<strong>filename 参数必须具有 .bat或 .cmd 扩展名。</strong><br>  调用另一个批处理程序，并且不终止父批处理程序。如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。<br>call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。<br><code>Sample：call="%cd%\test2.bat" haha kkk aaa</code>(调用指定目录下的test2.bat，且输入3个参数给他)<br><code>Sample：call test2.bat arg1 arg2</code>(调用同目录下的test2.bat，且输入2个参数给他)<br>注：可以调用自身(死循环、递归)<br>#### <em>7、Start</em> ####<br>用的不多，调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令来调用。<br>入侵常用参数：<br>MIN 开始时窗口最小化<br>SEPARATE 在分开的空间内开始 16 位 Windows 程序<br>HIGH 在 HIGH 优先级类别开始应用程序<br>REALTIME 在 REALTIME 优先级类别开始应用程序<br>WAIT 启动应用程序并等候它结束<br>parameters 这些为传送到命令/程序的参数<br><code>Sample：start /MIN test2.bat arg1 arg2</code>(调用同目录下的test2.bat，且输入2个参数给他，且本窗口最小化)<br><code>Sample：e:\"program files"\极品列车时刻表\jpskb.exe</code>(文件路径名有空格时)<br>#### <em>8、If</em> ####<br>if 表示将判断是否符合规定的条件，从而决定执行不同的命令。有三种格式: 1.if 语法: if [not] "参数" == "字符串" 待执行的命令<br>参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号)<br><code>Sample: if "%1" == "a" format a:</code><br>{`Sample: if {%1} == {} goto noparms `}<br>2. if exist 语法: if [not] exist [路径]文件名 待执行的命令<br>如果有指定的文件，则条件成立，运行命令，否则运行下一句。<br><code>Sample: if exist config.sys edit config.sys</code>(表示如果存在这文件，则编辑它，用很难看的系统编辑器)<br><code>Sample: if exist config.sys type config.sys</code>(表示如果存在这文件，则显示它的内容)<br>3. if errorlevel number 语法: if [not] errorlevel <数字>待执行的命令<br>如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列)<br>Sample: <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">XCOPY</span> F:\test.bat D:\<br><span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">1</span> (<span class="hljs-built_in">ECHO</span> 文件拷贝失败) <br><span class="hljs-keyword">Else</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">ERRORLEVEL</span> <span class="hljs-number">0</span> <span class="hljs-built_in">ECHO</span> 成功拷贝文件<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure>  很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。<br>常见的返回码为0、1。通过iferrorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。<br>+ <strong>4) else</strong> 语法： if 条件 (成立时执行的命令) else(不成立时执行的命令)<br>如果是多个条件，建议适当使用括号把各条件包起来，以免出错。<br>Sample: if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) else(echo comment3 )<br><strong>注：如果 else 的语句需要换行，if 执行的行尾需用“^”连接，并且 if执行的动作需用(括起来)，否则报错</strong><br>Sample: if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) ^else (echo comment3 ) + <strong>5) 比较运算符:</strong> <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-keyword">EQU</span> - 等于 (一般使用“==”)<br><span class="hljs-keyword">NEQ</span> - 不等于 (没有 “!=”,改用“ <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">1</span>==<span class="hljs-number">1</span> ”的写法)<br><span class="hljs-keyword">LSS</span> - 小于<br><span class="hljs-keyword">LEQ</span> - 小于或等于<br><span class="hljs-keyword">GTR</span> - 大于<br><span class="hljs-keyword">GEQ</span> - 大于或等于<br><span class="hljs-keyword">if</span> /i &#123;%<span class="hljs-number">1</span>&#125;==&#123;&#125; (<span class="hljs-built_in">set</span> _BUILDARGS=+a) <span class="hljs-keyword">else</span> (<span class="hljs-built_in">set</span> _BUILDARGS=+avilC)<br><span class="hljs-comment">rem /i 表示启动IF命令扩展，使得IF可以支持多种运算操作：&#123;%1&#125;==&#123;&#125;如果第一个参数为空，就设置buildargs为+a 就是bmake后面跟的参数，否则就设置为其他的</span><br></code></pre></td></tr></table></figure> ####<em>9、Choice</em> ####<br>choice使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的errorlevel，然后配合 if errorlevel 选择运行不同的命令。<br><strong>注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice/?查看用法。</strong>使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234<br>Sample: choice /c:dme defrag,mem,end<br>将显示: defrag,mem,end[D,M,E]?<br>Sample:<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">choice /c:dme defrag,mem,end<br>if errorlevel 3<span class="hljs-built_in"> goto </span>defrag (应先判断数值最高的错误码)<br>if errorlevel 2<span class="hljs-built_in"> goto </span>mem<br>if errotlevel 1<span class="hljs-built_in"> goto </span>end<br></code></pre></td></tr></table></figure> #### <em>10、For</em> ####<br>for对一组文件中的每一个文件执行某个特定命令。<strong><em>主要用于参数在指定的范围内循环执行命令。</em></strong>+ 1)<strong>for {%variable | %%variable} in (set) do command[command-parameters]</strong><br><strong>%variable</strong>指定一个单一字母可替换的参数。变量名称是区分大小写的，所以 %i 不同于%I<br>在批处理文件中使用 FOR 命令时，指定变量建议用 __%%variable__而不要用%variable。<br>(set) 指定一个或一组文件。可以使用通配符。<br><strong>command</strong> 指定对每个文件执行的命令。<br><strong>command-parameters</strong>为特定命令指定参数或命令行开关。<br>+ 2)<strong>如果命令扩展名被启用，下列额外的 FOR命令格式会受到支持:</strong><br>+ a. FOR /D %variable IN (set) DO command [command-parameters]<br>如果集里面包含通配符，则指定与目录名匹配，而不与文件名匹配。<br>+ b. FOR /R [[drive:]path] %variable IN (set) DO command[command-parameters]<br>检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。 如果在 /R后没有指定目录，则使用当前目录。<strong>如果集仅为一个单点(.)字符，则枚举该目录树。</strong>+ c. FOR /L %variable IN (start,step,end) DO command[command-parameters]<br>该集表示以增量形式从开始到结束的一个数字序列。 如：(1,1,5) 将产生序列 12 3 4 5； 而(5,-1,1) 将产生序列 (5 4 3 2 1)。 + d. 有或者没有 usebackq选项:<br>FOR /F ["options"] %variable IN (file-set) DO command<br>FOR /F ["options"] %variable IN ("string") DO command<br>FOR /F ["options"] %variable IN (command) DO command<br>参数"options"为:<br>fileset 为一个或多个文件名。继续到 fileset中的下一个文件之前，每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For循环。以默认方式，/F通过每个文件的每一行中分开的第一个空白符号。跳过空白行。你可通过指定可选 "options"参数替代默认解析操作。这个带引号的字符串包括一个或多个指定不同解析选项的关键字。这些关键字为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">eol=c - 指一个行注释字符的结尾(就一个字符),(如“;”)<br>skip=n - 指在文件开始时忽略的行数。<br>delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。<br>tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 <span class="hljs-keyword">for</span> 本身。这会导致额外变量名称的分配。<br>m-n格式为一个范围。通过 nth 符号指定 mth。<br>如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。<br>usebackq - 指定新语法已在下类情况中使用:<br>在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 filenameset中使用双引号扩起文件名称。<br></code></pre></td></tr></table></figure> + 3)<strong>Sample:</strong><br>+ a. 如下命令行会显示当前目录下所有以bat或者txt为扩展名的文件名。<br>for %%c in (<em>.bat </em>.txt) do (echo %%c)<br>+ b. 如下命令行会显示当前目录下所有包含有 e 或者 i 的目录名。<br>for /D %%a in (<em>e</em> <em>i</em>) do echo %%a<br>+ c. 如下命令行会显示 E盘test目录下所有以bat或者txt为扩展名的文件名。<br>for /R E:%%b in (<em>.txt </em>.bat) do echo %%b<br>for /r %%c in (*) do (echo %%c) :: 遍历当前目录下所有文件<br>+ d. 如下命令行将产生序列 1 2 3 4 5<br>for /L %%c in (1,1,5) do echo %%c<br>+ e. 以下两句，显示当前的年月日和时间<br><strong>For /f "tokens=1-3 delims=-/. " %%j In ('Date /T') do echo%%j年%%k月%%l日</strong><br><strong>For /f "tokens=1,2 delims=: " %%j In ('TIME /T') do echo%%j时%%k分</strong><br>+ f. 把记事本中的内容每一行前面去掉8个字符<br>setlocal enabledelayedexpansion<br>for /f %%i in (zhidian.txt) do (<br>set atmp=%%i set atmp=!atmp:~8! if {!atmp!}=={} ( echo.) else echo!atmp! ) :: 读取记事本里的内容(使用 delims是为了把一行显示全,否则会以空格为分隔符) for /f "delims=" %%a in(zhidian.txt) do echo.%%a + g.<br><code>FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k</code><br>该行会分析 myfile.txt中的每一行，忽略以分号打头的那些行，将每行中的第二个和第三个符号传递给for 函数体，用逗号和/或 空格分隔符号。请注意，此 for 函数体的语句引用 %i来获得第二个符号，引用 %j 来获得第三个符号，引用%k来获得第三个符号后的所有剩余符号。对于带有空格的文件名，你需要用双引号将文件名括起来。为了用这种方式来使用双引号，还需要使用usebackq 选项，否则，双引号会被理解成是用作定义某个要分析的字符串的。<strong>%i 在 for 语句中显式声明，%j 和 %k 是通过tokens=选项隐式声明的。</strong> 可以通过 tokens= 一行指定最多 26个符号，只要不试图声明一个高于字母 "z" 或"Z" 的变量。请记住，FOR变量是单一字母、分大小写和全局的变量；而且，不能同时使用超过 52 个。</数字></p><p>还可以在相邻字符串上使用 FOR /F分析逻辑，方法是，用单引号将括号之间的 file-set括起来。这样，该字符串会被当作一个文件中的一个单一输入行进行解析。</p><p>最后，可以用 FOR /F 命令来分析命令的输出。方法是，将括号之间的file-set 变成一个反括字符串。该字符串会被当作命令行，传递到一个子CMD.EXE，其输出会被捕获到内存中，并被当作文件分析。如以下例子所示:<code>FOR /F "usebackq delims==" %i IN (</code>set<code>) DO @echo %i</code><br>会枚举当前环境中的环境变量名称。 + 4)<strong>continue 和break</strong><br>利用 goto 实现程序中常用的 continue 和 break 命令, 其实非常简单continue: 在 for 循环的最后一行写上一个标签，跳转到这位置即可 break: 在for 循环的外面的下一句写上一个标签，跳转到这位置即可 &gt; Sample:<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">for</span> /F [<span class="hljs-string">"options"</span>] %variable IN (<span class="hljs-keyword">command</span>) DO (<br>... <span class="hljs-keyword">do</span> <span class="hljs-keyword">command</span> ...<br><span class="hljs-keyword">if</span> ... <span class="hljs-keyword">goto</span> <span class="hljs-keyword">continue</span><br><span class="hljs-keyword">if</span> ... <span class="hljs-keyword">goto</span> <span class="hljs-keyword">break</span><br>... <span class="hljs-keyword">do</span> <span class="hljs-keyword">command</span> ...<br>:<span class="hljs-keyword">continue</span><br>)<br>:<span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure> ### For循环补充 ###<br>&gt; /D 参数只能显示当前目录下的目录名字<br><span class="citation" data-cites="echo">@echo</span> off<br>for /d %%i in (window?) do <span class="citation" data-cites="echo">@echo</span> %%i<br>pause<br>&gt; /R 递归进入根目录树[Drive:]Path，在树的每个目录中执行for语句。如果在 /R 后没有指定目录，则认为是 当前目录。如果 Set 只是一个句点(.)，则只枚举目录树。<br>系统帮助的格式:<br>FOR /R[[drive:]path] %%variable IN (set) DO command<br>for /r %%i in (<em>.exe) do <span class="citation" data-cites="echo">@echo</span> %%i<br>列出所有exe的名字<br>for /r c: %%i in (</em>.exe) do <span class="citation" data-cites="echo">@echo</span> %%i<br>列出c盘的exe名字<br>对于FOR /F %%i IN (file) DO command<br>file为文件名，按照官方的说法是，for会依次将file中的文件打开，并且在进行到下一个文件之前将每个文件读取到内存，按照每一行分成一个一个的元素，忽略空白的行，看个例子。<br>&gt; for/f "delims= " %%i in (a.txt) do echo %%i<br>输出a.txt文件中的每一行，用空格隔开？ #### <em>11、Ping</em> ####<br>测试网络联接状况以及信息包发送和接收状况。但是不能够测试端口。<br>语法：ping IP地址或主机名 [-t] [-a] [-n count] [-l size]<br>参数含义：<br>-t 不停地向目标主机发送数据；<br>-a 以IP地址格式来显示目标主机的网络地址；<br>-n count 指定要Ping多少次，具体次数由count来指定；<br>-l size 指定发送到目标主机的数据包的大小。<br>Sample: ping 192.168.0.1 -t (不停的测试192.168.0.1，按ctrl+c停止)<br>Sample: for /L %%a in (0,1,255) do ping 192.168.0.%%a -n 1 &gt;&gt;tmp.txt (ping一下所有的局域网电脑)<br>#### <em>12、Telnet</em> ####<br>测试端口使用 telnet IP地址或主机名 端口，使用tcp协议的<br>Sample: telnet 192.168.0.1 80 (测试192.168.0.1的80端口) ####<em>13、Color</em> ####<br>color [attr]<br>颜色属性由两个十六进制数字指定 --第一个对应于背景，第二个对应于前景。每个数字 可以为以下任何值:</p><pre><code>0 = 黑色       8 = 灰色1 = 蓝色       9 = 淡蓝色2 = 绿色       A = 淡绿色3 = 浅绿色     B = 淡浅绿色4 = 红色       C = 淡红色5 = 紫色       D = 淡紫色6 = 黄色       E = 淡黄色7 = 白色       F = 亮白色   </code></pre><p>如果没有给定任何参数，此命令会将颜色还原到 CMD.EXE启动时的颜色。这个值来自当前控制台 窗口、/T 命令行开关或 DefaultColor注册表值。 如果尝试使用相同的前景和背景颜色来执行rem COLOR 命令，COLOR命令会将 ERRORLEVEL 设置为 1。只有一个参数时，设置字体。只有一个字母时默认时设置字体的颜色<br>#### <em>14、Exit</em> ####<br>exit退出<br>#### <em>15、ShutDown</em> ####<br>shutdown -s +秒数（xx秒之后自动关闭）<br>#### <em>16、Dir</em> ####<br>显示目录中的文件和子目录列表。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">DIR [drive:][path][filename] [<span class="hljs-string">/A</span>[[:]attributes]] [<span class="hljs-string">/B</span>] [<span class="hljs-string">/C</span>] [<span class="hljs-string">/D</span>] [<span class="hljs-string">/L</span>] [<span class="hljs-string">/N</span>]<br>  [<span class="hljs-string">/O</span>[[:]sortorder]] [<span class="hljs-string">/P</span>] [<span class="hljs-string">/Q</span>] [<span class="hljs-string">/R</span>] [<span class="hljs-string">/S</span>] [<span class="hljs-string">/T</span>[[:]timefield]] [<span class="hljs-string">/W</span>] [<span class="hljs-string">/X</span>] [<span class="hljs-string">/4</span>]<br>  [drive:][path][filename]<br>              指定要列出的驱动器、目录和/或文件。<br><br><br>  <span class="hljs-string">/A</span>          显示具有指定属性的文件。<br>  属性         D  目录                R  只读文件<br>                  H  隐藏文件            A  准备存档的文件<br>                  S  系统文件            I  无内容索引文件<br>                  L  解析点             -  表示“否”的前缀<br>  <span class="hljs-string">/B</span>          使用空格式<span class="hljs-params">(没有标题信息或摘要)</span>。<br>  <span class="hljs-string">/C</span>          在文件大小中显示千位数分隔符。这是默认值。用 <span class="hljs-string">/-C</span> 来禁用分隔符显示。<br>  <span class="hljs-string">/D</span>          跟宽式相同，但文件是按栏分类列出的。<br>  <span class="hljs-string">/L</span>          用小写。<br>  <span class="hljs-string">/N</span>          新的长列表格式，其中文件名在最右边。<br>  <span class="hljs-string">/O</span>          用分类顺序列出文件。<br>  排列顺序     N  按名称<span class="hljs-params">(字母顺序)</span>     S  按大小<span class="hljs-params">(从小到大)</span><br>                   E  按扩展名<span class="hljs-params">(字母顺序)</span>   D  按日期/时间<span class="hljs-params">(从先到后)</span><br>                   G  组目录优先           -  反转顺序的前缀<br>  <span class="hljs-string">/P</span>          在每个信息屏幕后暂停。<br>  <span class="hljs-string">/Q</span>          显示文件所有者。<br>  <span class="hljs-string">/R</span>          显示文件的备用数据流。<br>  <span class="hljs-string">/S</span>          显示指定目录和所有子目录中的文件。<br>  <span class="hljs-string">/T</span>          控制显示或用来分类的时间字符域。<br>  时间段      C  创建时间<br>              A  上次访问时间<br>              W  上次写入的时间<br>  <span class="hljs-string">/W</span>          用宽列表格式。<br>  <span class="hljs-string">/X</span>          显示为非 8.3 文件名产生的短名称。格式是 <span class="hljs-string">/N</span> 的格式，<br>              短名称插在长名称前面。如果没有短名称，在其位置则<br>              显示空白。<br>  <span class="hljs-string">/4</span>          用四位数字显示年<br>可以在 DIRCMD 环境变量中预先设定开关。通过添加前缀 - <span class="hljs-params">(破折号)</span><br>来替代预先设定的开关。例如，<span class="hljs-string">/-W</span>。<br>上面是CMD命令自带的说明文件。<br>dir <span class="hljs-string">/d</span>      只显示当前目录下的文件名称<br>dir <span class="hljs-string">/od</span>     按文件修改时间排序，递增；<br>dir <span class="hljs-string">/o-d</span>    按文件修改时间排序，递减<br>dir <span class="hljs-string">/od/tc</span>   按文件创建时间排序，递增<br>dir <span class="hljs-string">/o-d/tc</span>  按文件创建时间排序，递减<br>dir/on 按文件名排序对应，递增<br>dir/o-n 按文件名排序对应，递减<br>dir/oe 按扩展名排序对应，递增<br>dir/o-e 按文件名排序对应，递减<br>dir <span class="hljs-string">/s</span> <span class="hljs-string">/b</span> &gt;a.txt 打印文件夹下的所有文件<br></code></pre></td></tr></table></figure> #### <em>17、重定向符</em> #### mycommand &gt;mylog.txt2&gt;&amp;1<br>应该是最经典的用法了。命令的结果可以通过“%&gt;”的形式来定向输出，%表示文件描述符：1为标准输出stdout、2为标准错误stderr。系统默认%值是1，也就是“1&gt;”，而1&gt;可以简写为&gt;，也就是默认为&gt;。<br>stdout的默认目标是终端，stderr的默认目标为也是终端。我们在批处理中执行：echo text &gt;result.txt ，我们就可以在屏幕上会看到 echo text1&gt;result.txt ，即是这个道理。 其中&amp;需要直接与重定向符号结合使用。应用实例：<br>1、将结果输出到result.txt<br>net stop myservices &gt;&gt;result 2&gt;&amp;1<br>2、隐藏程序输出结果<br>net stop myservices &gt;nul 2&gt;nul<br>微软关于重定向的文章：使用命令重定向操作符<br>可以使用重定向操作符将命令输入和输出数据流从默认位置重定向到其他位置。输入或输出数据流的位置称为句柄。<br>下面列出可用的句柄。 句柄 句柄的数字代号 描述 <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">STDIN <span class="hljs-number">0</span> 键盘输入   <br>STDOUT <span class="hljs-number">1</span> 输出到命令提示符窗口   <br>STDERR <span class="hljs-number">2</span> 错误输出到命令提示符窗口   <br>UNDEFINED <span class="hljs-number">3</span><span class="hljs-number">-9</span> 句柄由应用程序单独定义，它们是各个工具特有的<br></code></pre></td></tr></table></figure> 数字 0 到 9代表前 10 个句柄。可以使用命令 Cmd.exe 运行程序，并对该程序前 10个句柄中的任何一个句柄进行重定向。要指定要用的句柄，请在重定向操作符之前键入该句柄的数字。如果未定义句柄，则默认的&lt; 重定向输入操作符是 0，而默认的 &gt; 重定向输出操作符是 1。键入 &lt;或 &gt;操作符之后，必须指定数据的读写位置。可以指定文件名或其他现有的句柄。要指定重定向到现有句柄，请使用与 (&amp;)字符，后面接要重定向的句柄号（即 &amp;句柄号）。<br>例如，下面的命令可以将句柄 2（即 STDERR）重定向到句柄 1（即 STDOUT）：2&gt;&amp;1<br>下表列出了可用于重定向输入和输出数据流的操作符。<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs julia">重定向操作符 描述 <br>&gt; 将命令输出写入到文件或设备（如打印机），而不是命令提示符窗口或句柄。<br>&lt; 从文件而不是从键盘或句柄读入命令输入。<br>&gt;&gt; 将命令输出添加到文件末尾而不删除文件中已有的信息。<br>&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中。<br>&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中。<br>| 从一个命令中读取输出并将其写入另一个命令的输入中。也称作管道。<br>默认情况下，可以从键盘将命令输入（即 <span class="hljs-literal">STDIN</span> 句柄）发送到 <span class="hljs-built_in">Cmd</span>.exe，然后由 <span class="hljs-built_in">Cmd</span>.exe 将命令输出（即 <span class="hljs-literal">STDOUT</span> 句柄）发送到命令提示符窗口。<br></code></pre></td></tr></table></figure> ## 使用组合命令(Compound Command) ##<br>+ 1.__&amp;<strong><br>Usage：第一条命令 &amp; 第二条命令 [&amp; 第三条命令...]<br><strong>用这种方法可以同时执行多条命令，而不管命令是否执行成功</strong><br>Sample：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">C:\\&gt;dir z: &amp; dir c:\\Ex4rch   <br>The system cannot find the path specified.   <br>Volume <span class="hljs-keyword">in</span> drive C has no label.   <br>Volume Serial Number <span class="hljs-keyword">is</span> <span class="hljs-number">0078</span><span class="hljs-number">-59</span>FB   <br><br>Directory of c:\\Ex4rc<br><span class="hljs-number">2002</span><span class="hljs-number">-05</span><span class="hljs-number">-14</span> <span class="hljs-number">23</span>:<span class="hljs-number">51</span> &lt;DIR&gt; .<br><span class="hljs-number">2002</span><span class="hljs-number">-05</span><span class="hljs-number">-14</span> <span class="hljs-number">23</span>:<span class="hljs-number">51</span> &lt;DIR&gt; ..<br><span class="hljs-number">2002</span><span class="hljs-number">-05</span><span class="hljs-number">-14</span> <span class="hljs-number">23</span>:<span class="hljs-number">51</span> <span class="hljs-number">14</span> sometips.gif<br></code></pre></td></tr></table></figure> + 2.</strong>&amp;&amp;<strong><br>Usage：第一条命令 &amp;&amp; 第二条命令[&amp;&amp; 第三条命令...]<br><strong>用这种方法可以同时执行多条命令，当碰到执行出错的命令后将不执行后面的命令，如果一直没有出错则一直执行完所有命令；</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Sample：<br>C:\\&gt;dir z: &amp;&amp; dir c:\\Ex4rch<br>The<span class="hljs-built_in"> system </span>cannot <span class="hljs-builtin-name">find</span> the path specified.<br><br>C:\\&gt;dir c:\\Ex4rch &amp;&amp; dir z:<br>Volume <span class="hljs-keyword">in</span> drive C has <span class="hljs-literal">no</span> label.<br>Volume Serial Number is 0078-59FB<br><br>Directory of c:\\Ex4rch<br><br>2002-05-14 23:55 &lt;DIR&gt; .<br>2002-05-14 23:55 &lt;DIR&gt; <span class="hljs-built_in">..</span><br>2002-05-14 23:55 14 sometips.gif<br>1 File(s) 14 bytes<br>2 Dir(s) 768,671,744 bytes free<br>The<span class="hljs-built_in"> system </span>cannot <span class="hljs-builtin-name">find</span> the path specified.<br></code></pre></td></tr></table></figure> 在做备份的时候可能会用到这种命令会比较简单，如： dirfile://192.168.0.1/database/backup.mdb &amp;&amp; copyfile://192.168.0.1/database/backup.mdb E:\backup<br>如果远程服务器上存在backup.mdb文件，就执行copy命令，若不存在该文件则不执行copy命令。这种用法可以替换IFexist了 ：）<br>+ 3.</strong>||__<br>Usage：第一条命令 || 第二条命令 [|| 第三条命令...]<br><strong>用这种方法可以同时执行多条命令，当碰到执行正确的命令后将不执行后面的命令，如果没有出现正确的命令则一直执行完所有命令；</strong><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Sample：<br>C:\\Ex4rch&gt;dir sometips.gif || del sometips.gif<br>Volume <span class="hljs-keyword">in</span> drive C has no label.<br>Volume Serial Number <span class="hljs-keyword">is</span> <span class="hljs-number">0078</span><span class="hljs-number">-59</span>FB<br><br>Directory of C:\\Ex4rch<br><br><span class="hljs-number">2002</span><span class="hljs-number">-05</span><span class="hljs-number">-14</span> <span class="hljs-number">23</span>:<span class="hljs-number">55</span> <span class="hljs-number">14</span> sometips.gif<br><span class="hljs-number">1</span> File(s) <span class="hljs-number">14</span> bytes<br><span class="hljs-number">0</span> Dir(s) <span class="hljs-number">768</span>,<span class="hljs-number">696</span>,<span class="hljs-number">320</span> bytes free<br></code></pre></td></tr></table></figure> 组合命令使用的例子： sample： <span class="citation" data-cites="copy">@copy</span> trojan.exe \\%1\admin$\system32&amp;&amp; if not errorlevel 1 echoIP %1 USER %2 PASS %3&gt;&gt;victim.txt<br>+ 4.__管道命令的使用<strong> + 1. </strong>| 命令<strong><br>Usage：第一条命令 | 第二条命令 [| 第三条命令...]<br>将第一条命令的结果作为第二条命令的参数来使用，记得在unix中这种方式很常见。<br>sample： time /t&gt;&gt;D:\IP.log netstat -n -p tcp|find":3389"&gt;&gt;D:\IP.log start Explore<br>看出来了么？用于终端服务允许我们为用户自定义起始的程序，来实现让用户运行下面这个bat，以获得登录用户的IP。+ 2. </strong>&gt;、&gt;&gt;输出重定向命令<strong><br>将一条命令或某个程序输出结果的重定向到特定文件中, </strong>&gt; 与&gt;&gt;的区别在于，&gt;会清除调原有文件中的内容后写入指定文件，而&gt;&gt;只会追加内容到指定文件中，而不会改动其中的内容。<strong><br>sample1：<br>echo hello world&gt;c:\hello.txt (stupid example?)<br>sample2:<br>时下DLL木马盛行，我们知道system32是个捉迷藏的好地方，许多木马都削尖了脑袋往那里钻，DLL马也不例外，针对这一点我们可以在安装好系统和必要的应用程序后，对该目录下的EXE和DLL文件作一个记录：<br>运行CMD--转换目录到system32--dir<em>.exe&gt;exeback.txt &amp; dir</em>.dll&gt;dllback.txt,<br>这样所有的EXE和DLL文件的名称都被分别记录到exeback.txt和dllback.txt中,日后如发现异常但用传统的方法查不出问题时,则要考虑是不是系统中已经潜入DLL木马了.这时我们用同样的命令将system32下的EXE和DLL文件记录到另外的exeback1.txt和dllback1.txt中,然后运行:<br>CMD--fc exeback.txt exeback1.txt&gt;diff.txt &amp; fc dllback.txtdllback1.txt&gt;diff.txt.<br>(<strong>用FC命令比较前后两次的DLL和EXE文件,并将结果输入到diff.txt中</strong>),这样我们就能发现一些多出来的DLL和EXE文件,然后通过查看创建时间、版本、是否经过压缩等就能够比较容易地判断出是不是已经被DLL木马光顾了。没有是最好，如果有的话也不要直接DEL掉，先用 <strong>regsvr32 /utrojan.dll</strong>将后门DLL文件注销掉,再把它移到回收站里，若系统没有异常反映再将之彻底删除或者提交给杀毒软件公司。+ 3. </strong>&lt; 、&gt;&amp; 、&lt;&amp;<strong><br>"&lt;" 从文件中而不是从键盘中读入命令输入。<br>"&gt;&amp;" 将一个句柄的输出写入到另一个句柄的输入中。<br>"&lt;&amp;" 从一个句柄读取输入并将其写入到另一个句柄输出中。<br>这些并不常用，也就不多做介绍<br>## 字符串处理 ##<br>+ 1) 分割字符串，以查看时间为例<br></strong>%源字符串:~起始值,截取长度%(起始值从0开始；截取长度是可选的，如果省略逗号和截取长度，将会从起始值截取到结尾；截取长度如果是负数，表示截取到倒数第几个。)__<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-string">"%time%"</span> 显示如：<span class="hljs-string">"11:04:23.03"</span> (完整的时间<span class="hljs-string">"hh:mm:ss.tt"</span>)<br><span class="hljs-string">"%time:~0,5%"</span> 显示<span class="hljs-string">"hh:mm"</span>(即<span class="hljs-string">"11:04"</span>)，其中<span class="hljs-number">0</span>表示从右向左移位操作的个数，<span class="hljs-number">5</span>表示从左向右移位操作的个数<br><span class="hljs-string">"%time:~0,8%"</span> 显示标准时间格式<span class="hljs-string">"hh:mm:ss"</span>(即<span class="hljs-string">"11:04:23"</span>，前<span class="hljs-number">8</span>个字符串)<br><span class="hljs-string">"%time:~3,-3%"</span>显示<span class="hljs-string">"mm:ss"</span>(即从第<span class="hljs-number">4</span>个开始,截去最后<span class="hljs-number">3</span>个的字符串)<br><span class="hljs-string">"%time:~3%"</span> 显示<span class="hljs-string">"04:23.03"</span>(即去掉前<span class="hljs-number">4</span>个字符串)<br><span class="hljs-string">"%time:~-3%"</span> 显示<span class="hljs-string">".tt"</span>(即最后<span class="hljs-number">3</span>个字符串)<br></code></pre></td></tr></table></figure>上面的字串分割格式，也可以用于其它地方，如目录路径："%cd:~0,10%" + 2)替换字符串<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">set</span> <span class="hljs-keyword">a</span>=<span class="hljs-string">"abcd1234"</span><br>echo %<span class="hljs-keyword">a</span>% 显示：<span class="hljs-string">"abcd1234"</span><br><span class="hljs-built_in">set</span> <span class="hljs-keyword">a</span>=%<span class="hljs-keyword">a</span>:<span class="hljs-number">1</span>=kk% 替换“<span class="hljs-number">1</span>”为“kk”<br>echo %<span class="hljs-keyword">a</span>% 显示：<span class="hljs-string">"abcdkk234"</span><br></code></pre></td></tr></table></figure> + 3) 字符串合并<br>由于没有直接的字符串合并函数，只能用笨方法了。 set str1=%str1%%str2%(合并 str1 和 str2) + 4) 计算字符串长度<br>没有现成的函数。如下程序利用goto形成循环，不断将字符串截短1，并记录截短的次数，到字符串变成空时的次数即长度。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> testStr=This <span class="hljs-keyword">is</span> a <span class="hljs-keyword">test</span> <span class="hljs-keyword">string</span><br>:: 将 testStr 复制到<span class="hljs-keyword">str</span>，<span class="hljs-keyword">str</span> 是个临时字符串<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">str</span>=%testStr%<br>:: 标签，用于<span class="hljs-keyword">goto</span>跳转<br>:next1<br>:: 判断<span class="hljs-keyword">str</span>是不是空，如果不是则执行下边的语句<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-string">"%str%"</span>==<span class="hljs-string">""</span> (<br>:: 算术运算，使<span class="hljs-keyword">num</span>的值自增<span class="hljs-number">1</span>，相当于<span class="hljs-keyword">num</span>++或者++<span class="hljs-keyword">num</span>语句<br><span class="hljs-keyword">set</span> /a <span class="hljs-keyword">num</span>+=<span class="hljs-number">1</span><br>:: 截取字符串，每次截短<span class="hljs-number">1</span><br><span class="hljs-keyword">set</span> <span class="hljs-string">"str=%str:~1%"</span><br>:: 跳转到next1标签: 这里利用<span class="hljs-keyword">goto</span>和标签，构成循环结构<br><span class="hljs-keyword">goto</span> next1<br>)<br>:: 当以上循环结构执行完毕时，会执行下边的语句<br>echo testStr=%testStr%<br>echo testStr的长度为：%<span class="hljs-keyword">num</span>%<br></code></pre></td></tr></table></figure> + 5) 截取字符串时，需要传递参数<br>直接 <code>echo %args:~%num%,-5%</code><del>没办法想要的字符串</del>，(这里没懂)需要如下两步 setlocalenabledelayedexpansion<br><code>echo !args:~%num%,-5!</code><br>## Registration Table Command Omit ## see more detials at <a href="https://blog.csdn.net/qq_36838191/article/details/83046599">here</a>中的第六条<br>## <strong>More Tips</strong> ##<br>+ "&gt;&gt;"追加， “&gt;”在文件中末尾添加<br>+ 创建文件夹<br>md d: mkdir d: + 在命令末尾加上“&gt;NUL2&gt;NUL”，表示隐蔽返回信息。<br>+ 清屏<br>cls + 打开文件浏览器 start explorer.exe /e,/select,%_LOGFILE%（%_LOGFILE%指代文件路径+后缀） +修改文件的后缀名<br>ren C:*.jpg <em>.JPG<br>for /r %%c in (</em>.jpg) do (ren %%c <em>.JPG) ::修改当前目录下的所有文件的后缀名，包括子目录的<br>+ 修改文件的文件名<br>rename test.jpg test2.JPG<br>rename </em>.jpg <em>.888.JPG<br>+ 获取当前路径<br>cd ./<br>set CURE_PATH=%cd%<br>+ 打开某网站 </em>start Chrome.exe www.baidu.com*<br>+ show the current dir's name （<strong>for的用法</strong>）<br><span class="citation" data-cites="echo">@echo</span> off<br>for /d %%i in (???) do <span class="citation" data-cites="echo">@echo</span> %%i<br>pause<br>这样的话如果你当前目录下有目录名字只有1-3个字母的,就会显示出来,没有就不显示了。+ del<br>del /f /q "%_LOGFILE%"<br>将logfile变量对应的文件强制删掉，且无需提示 /f 是强制删除所有属性的文件/q是无需确认直接删除要是再加上/s开关，就可以删除子文件加中的文件 +choice<br>choice使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234<br>如: choice /c:dme defrag,mem,end<br>将显示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">defrag,mem,<span class="hljs-keyword">end</span>[D,M,E]?<br><span class="hljs-keyword">Sample</span>：<br>Sample.bat的内容如下:<br>@echo <span class="hljs-keyword">off</span><br>choice /c:dme defrag,mem,<span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> errorlevel <span class="hljs-number">3</span> <span class="hljs-keyword">goto</span> defrag （应先判断数值最高的错误码）<br><span class="hljs-keyword">if</span> errorlevel <span class="hljs-number">2</span> <span class="hljs-keyword">goto</span> mem<br><span class="hljs-keyword">if</span> errotlevel <span class="hljs-number">1</span> <span class="hljs-keyword">goto</span> <span class="hljs-keyword">end</span><br>:defrag<br>c:\\dos\\defrag<br><span class="hljs-keyword">goto</span> <span class="hljs-keyword">end</span><br>:mem<br>mem<br><span class="hljs-keyword">goto</span> <span class="hljs-keyword">end</span><br>:<span class="hljs-keyword">end</span><br>echo good bye<br></code></pre></td></tr></table></figure> 此文件运行后，将显示 defrag,mem,end[D,M,E]? 用户可选择d m e，然后if语句将作出判断，d表示执行标号为defrag的程序段，m表示执行标号为mem的程序段，e表示执行标号为end的程序段，每个程序段最后都以gotoend将程序跳到end标号处，然后程序将显示good bye，文件结束。<br>+ call<br>批脚本里的 %* 指出所有的参数(如 %1 %2 %3 %4 %5 ...)<br>+ set<br>显示、设置或删除 cmd.exe 环境变量。<br>SET [variable=[string]]<br>variable 指定环境变量名。<br>string 指定要指派给变量的一系列字符串。<br>要显示当前环境变量，键入不带参数的 SET。<br>如果命令扩展被启用，SET 会如下改变:<br>可仅用一个变量激活 SET 命令，等号或值不显示所有前缀匹配<br>SET 命令已使用的名称的所有变量的值。例如:<br>SET P<br>会显示所有以字母 P 打头的变量<br>如果在当前环境中找不到该变量名称，SET 命令将把 ERRORLEVEL<br>设置成 1。<br>SET 命令不允许变量名含有等号。<br>在 SET 命令中添加了两个新命令行开关:<br>SET /A expression<br>SET /P variable=[promptString]<br>#### More and More Details ####<br>具体语法还需详查看<a href="https://www.cnblogs.com/micro-chen/p/5694423.html">bat</a>语法格式，<a href="https://www.jianshu.com/p/399e5a3c7cc5">markdown</a>语法参见此。</p><p>另外，FOR 变量参照的替换已被增强。你现在可以使用下列 选项语法:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">~I          - 删除任何引号(<span class="hljs-string">")，扩展 %I</span></span><br><span class="hljs-meta">%</span><span class="bash">~fI        - 将 %I 扩展到一个完全合格的路径名</span><br><span class="hljs-meta">%</span><span class="bash">~dI        - 仅将 %I 扩展到一个驱动器号</span><br><span class="hljs-meta">%</span><span class="bash">~pI        - 仅将 %I 扩展到一个路径</span><br><span class="hljs-meta">%</span><span class="bash">~nI        - 仅将 %I 扩展到一个文件名</span><br><span class="hljs-meta">%</span><span class="bash">~xI        - 仅将 %I 扩展到一个文件扩展名</span><br><span class="hljs-meta">%</span><span class="bash">~sI        - 扩展的路径只含有短名</span><br><span class="hljs-meta">%</span><span class="bash">~aI        - 将 %I 扩展到文件的文件属性</span><br><span class="hljs-meta">%</span><span class="bash">~tI        - 将 %I 扩展到文件的日期/时间</span><br><span class="hljs-meta">%</span><span class="bash">~zI        - 将 %I 扩展到文件的大小</span><br><span class="hljs-meta">%</span><span class="bash">~<span class="hljs-variable">$PATH</span>:I   - 查找列在路径环境变量的目录，并将 %I 扩展</span><br>              到找到的第一个完全合格的名称。如果环境变量名<br>              未被定义，或者没有找到文件，此组合键会扩展到<br>              空字符串<br></code></pre></td></tr></table></figure> 可以组合修饰符来得到多重结果: <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">%~dpI       - 仅将 %I 扩展到一个驱动器号和路径<br>%~nxI       - 仅将 %I 扩展到一个文件名和扩展名<br>%~fsI       - 仅将 %I 扩展到一个带有短名的完整路径名<br>%~dp$PATH:I - 搜索列在路径环境变量的目录，并将 %I 扩展<br>              到找到的第一个驱动器号和路径。<br>%~ftzaI     - 将 %I 扩展到类似输出线路的 DIR<br></code></pre></td></tr></table></figure> 在以上例子中，%I 和PATH 可用其他有效数值代替。%~ 语法 用一个有效的 FOR 变量名终止。选取类似%I 的大写变量名 比较易读，而且避免与不分大小写的组合键混淆。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WindowsScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowBat实战</title>
      <link href="/blogs/2020/03/21/WindowBat%E5%AE%9E%E6%88%98/"/>
      <url>/blogs/2020/03/21/WindowBat%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<ul><li>自动拷贝文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>cls<br><span class="hljs-built_in">cd</span> ./bin<br><br>REM 打印当前文件夹中的dll名称<br>dir *.dll<br><br><span class="hljs-keyword">for</span> /r %%j <span class="hljs-keyword">in</span> (*.dll) <span class="hljs-keyword">do</span> (<br>REM 拷贝Release版的dll到指定目录<br><span class="hljs-built_in">echo</span> %%j | find <span class="hljs-string">"_d"</span> || xcopy %%j E:path\Release\ /Y<br>REM 拷贝Debug版的dll到指定目录<br><span class="hljs-built_in">echo</span> %%j | find <span class="hljs-string">"_d"</span> &amp;&amp; xcopy %%j E:path\Debug\ /Y<br>)<br><br>PAUSE<br></code></pre></td></tr></table></figure><ul><li>批量自动移动文件并自动建立同名文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>REM 首先遍历最外层的文件夹，<br><span class="hljs-keyword">for</span> /f  %%i <span class="hljs-keyword">in</span> (<span class="hljs-string">'"dir /ad/b/on *.*"'</span>) <span class="hljs-keyword">do</span> (  <br><span class="hljs-built_in">echo</span> <span class="hljs-string">"First Dir: %%~fi"</span><br>REM MKDIR OF DESTINATION<br>md E:\Destination\%%i<br><span class="hljs-built_in">cd</span> %%~<span class="hljs-keyword">fi</span><br>    REM 获取到子文件夹之后再递归遍历子文件夹<br><span class="hljs-keyword">for</span> /f  %%j <span class="hljs-keyword">in</span> (<span class="hljs-string">'"dir /ad/b/on *.*"'</span>) <span class="hljs-keyword">do</span> (  <br><span class="hljs-built_in">echo</span>  <span class="hljs-string">"Second Dir:%%~fj"</span><br>REM MKDIR OF DESTINATION<br>md E:\Destination\%%i\%%j<br><span class="hljs-built_in">cd</span> %%~fj<br>REM 拷贝每个文件到预定的路径中<br><span class="hljs-keyword">for</span> %%k <span class="hljs-keyword">in</span> (*.las) <span class="hljs-keyword">do</span> ( <br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Third Dir:%%~fk"</span><br>REM COPY EACH LAS FILE<br>xcopy %%k E:\Destination\%%i\%%j\ /E /D /R /Y<br>)<br>REM 返回到上层文件夹，继续后续的遍历<br><span class="hljs-built_in">cd</span> ..<br>)<br>REM 同理<br><span class="hljs-built_in">cd</span> ..<br>)<br>REM 脚本运行完之后不退出<br>pause<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WindowsScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSG中的坐标系</title>
      <link href="/blogs/2020/03/11/OSG%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/blogs/2020/03/11/OSG%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="osg中的坐标系和opengl中的坐标系">OSG中的坐标系和OpenGL中的坐标系</h3><p>OSG中采用四元数表示旋转：<code>osg::Quat(angle to rotate, rotate around axis);</code></p><p>///***<br>///Q quaternion * P quaternion means that first conduct a rotationP,Second conduct a rotation Q, means a fusion about two rotations with amultiplication operation ///***</p><p>The osg coordinate definition as left-hand coordinate which isright-front-up(x-y-z) and the OpenGL coordinate definition also asleft-hand coordinate which is right-up-behind(x-y-z), z axis is pointerto outside the screen The OSG default viewport is along down direction,so heading is rotate to be equal to the y positive direction, rotateaxis is x axis <a id="more"></a> <img src="/blogs/.io//osgcoordinate.jpg" alt="坐标系朝向"></p><h4 id="参考博客">参考博客</h4><ol type="1"><li>https://blog.csdn.net/tmljs1988/article/details/7561887</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSG </tag>
            
            <tag> Geometics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFMPEG-Usage</title>
      <link href="/blogs/2020/02/29/%E8%A7%86%E9%A2%91%E5%8A%A0%E9%80%9F%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/blogs/2020/02/29/%E8%A7%86%E9%A2%91%E5%8A%A0%E9%80%9F%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="usage">Usage</h3><p>  Here, i'm trying to sequeeze a normal video to a n times faster.<strong>But</strong>, i found that there are many ways to relize this,such as</p><ul><li>ffmpeg and adjust the speed while roamming, etc.<br></li><li>OpenCV requires being complied with <strong>ffmpeg</strong>, which ididn't have the condition and many video format(.mp4) is not wellsupported.</li></ul><h3 id="installation">Installation</h3><ul><li>Under Linux</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> ffmpeg<br></code></pre></td></tr></table></figure><ul><li>Under Windows</li></ul><p>Directly download the binary <strong>executable</strong> file from <a href="https://github.com/BtbN/FFmpeg-Builds">the official page</a>. Moveto the bin folder and run the <code>./ffmpeg</code> in command line.</p><p>For example the "ffmpeg-master-latest-win64-gpl-shared" file.</p><p><a id="more"></a></p><h3 id="some-common-command-line-arguments">Some common command linearguments</h3><p>From ffmpeg <a href="https://ffmpeg.org/ffmpeg-filters.html#v360">officialpage</a>.</p><ol type="1"><li><code>-y</code>: (default) to automatically override the out filewithout further confirmation.</li><li><code>-i</code>: input file.</li><li><code>-vf</code>: video filter, e.g. v360 et al.</li><li><code>-bufsize</code>: set the buffer size.</li><li><code>-c:v libx265</code>: libx265 video encoder.</li><li><code>-b:v 40000k</code>: setting code rate of video.</li><li><code>--preset</code>:主要调节编码速度和质量的平衡，有ultrafast（转码速度最快，视频往往也最模糊）、superfast、veryfast、faster、fast、medium、slow、slower、veryslow、placebo，从快到慢.</li></ol><h3 id="video-speed-acceleration">Video speed acceleration</h3><ol type="1"><li>Speed or slow down the video, and the example as followings （butthe content is not smooth at all）: *** 4 times faster:+1:</li></ol><p><code>ffmpeg -i origin.mp4 -vf  "setpts=0.25\*PTS" UpTheOrigin.mp4</code>4 times slower</p><p><code>ffmpeg -i origin.mp4 -vf "setpts=4\*PTS" DownTheOrigin.mp4</code></p><hr><ol start="2" type="1"><li>Change the video format</li></ol><hr><p><code>ffmpeg -i origin.ogv -vcodec h264 output.mp4</code></p><p><code>ffmpeg -i origin.ogv -vcodec mpeg4 output.mp4</code></p><p><code>ffmpeg -i origin.ogv -vcodec libxvid output.mp4</code></p><p><code>ffmpeg -i origin.mp4 -vcodec wmv1 output.wmv</code></p><p><code>ffmpeg -i origin.mp4 -vcodec wmv2 output.wmv</code></p><hr><ol start="3" type="1"><li>Compress video into a smaller one.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i input.mp4 -vcodec libx265 -crf 28 output.mp4<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>More resources</li></ol><p>Please dive the <a href="https://blog.csdn.net/WuLex/article/details/101513018"><strong>Blog</strong></a>.</p><h3 id="attach-two-imagesvideos-into-one-imagevideo">Attach twoimages(videos) into one image(video)</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">.<span class="hljs-symbol">\f</span>fmpeg.exe -i D:<span class="hljs-symbol">\C</span>odeSpace<span class="hljs-symbol">\f</span>isheye_image<span class="hljs-symbol">\0</span>000000007-l.png -i D:<span class="hljs-symbol">\C</span>odeSpace<span class="hljs-symbol">\f</span>isheye_image<span class="hljs-symbol">\0</span>000000007-r.png -filter_complex hstack -y ./dual_fisheye_image.png<br></code></pre></td></tr></table></figure><p>-filter_complex hstack: <code>hstack</code> means images are stackedhorizontally, vertically is set to <code>vstack</code>.</p><p>the raw separate images are here:</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th style="text-align: center;">left image</th><th style="text-align: center;">right image</th></tr></thead><tbody><tr><td style="text-align: center;"><img src="/blogs/.io//0000000007-l.png"></td><td style="text-align: center;"><img src="/blogs/.io//0000000007-r.png"></td></tr></tbody></table><p>the returned joined image (./dual_fisheye_image.png) is asfollowings:</p><p><img src="/blogs/.io//dual_fisheye_image.png"></p><h4 id="references">References</h4><ul><li><a href="https://stackoverflow.com/questions/24604689/how-to-join-two-images-into-one-with-ffmpeg">jointtwo images into one</a>:+1:</li></ul><h3 id="fisheye-image-to-equirectangular-image">Fisheye Image toequirectangular Image</h3><ul><li>For single dual fisheye image to equirectangular image.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ffmpeg -i .\dual_fisheye_image.png -vf v360=dfisheye:e:ih_fov=185:iv_fov=185:yaw=-90 -y ./equirectangle_image.png<br></code></pre></td></tr></table></figure><p>185 is the image FOV.</p><p><img src="/blogs/.io//equirectangle_image.png"></p><h4 id="references-1">References</h4><ul><li><a href="https://stackoverflow.com/questions/37796911/is-there-a-fisheye-or-dual-fisheye-to-equirectangular-filter-for-ffmpeg">fisheyeto equirectangular image</a>(<strong>Recommanded</strong>:+1::+1::+1:)</li><li><a href="https://stackoverflow.com/questions/68114739/unable-to-convert-dual-fisheye-image-to-equirectangular-image-using-ffmpeg-packa">similaras upper</a> for yaw angle setting demonstration.</li><li><a href="https://stackoverflow.com/questions/70489535/is-it-possible-to-join-two-fisheye-images-to-one-equirectangular-image-using-ffm">here</a>is information-less:-1:.</li></ul><h3 id="sequence-image-to-video-back-and-forth">Sequence image to videoback and forth</h3><ul><li>image to video</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ffmpeg.exe -f image2 -r 1 -i xxx/000000000%d.png -vcodec libx265 -pix_fmt yuv420p -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy -y -r 1 ./fisheye_rgb.mp4<br></code></pre></td></tr></table></figure><p>-f: <code>image2</code> image type.</p><p>-r: video frame equal to 1, default by 25, which means extract 1(25)frames/s. Also known as definition how fast the pictures are read in. Tonote that, the position of the <code>-r</code> argument has differentmeanings. If we want to change the framerate of the output video,<code>-r</code> should be at the front of the<code>./fisheye_rgb.mp4</code></p><p>-pix_fmt <code>yuv420p</code>: is required under Windowsplatform.</p><ul><li>video to image</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">.\ffmpeg.exe -i .\fisheye_rgb_l.mp4 -r <span class="hljs-number">1</span> -q:v <span class="hljs-number">1</span> -start_number <span class="hljs-number">0</span> ./%<span class="hljs-number">10</span>d.png<br></code></pre></td></tr></table></figure><p>%10d: rename the out put images with int, e.g 0000000001.png.</p><p>-start_number <code>0</code>: means the result image id will startfrom 0. Also this argument could be used for selecting the specificimages for video generation. Deeper operations(e.g. glob, cat and etc)from reference1.</p><h4 id="references-2">References</h4><ul><li><a href="https://shotstack.io/learn/use-ffmpeg-to-convert-images-to-video/">shotstack</a></li><li><a href="https://stackoverflow.com/questions/24961127/how-to-create-a-video-from-images-with-ffmpeg">createa video from images with FFMPEG</a>:+1:</li></ul><h3 id="dual-fisheye-image-video-to-equirectangular-video">Dual fisheyeimage video to equirectangular video</h3><ul><li>For dual fisheye video to equirectangular video.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ffmpeg -y -i <span class="hljs-variable">$file</span> -vf v360=dfisheye:e:yaw=-90:ih_fov=187.8:iv_fov=185 -c:v libx265 -b:v 40000k -bufsize 5000k -preset ultrafast -c:a copy out.mp4<br></code></pre></td></tr></table></figure><p>here we choose the ==v360== filter, <a href="https://ffmpeg.org/ffmpeg-filters.html#v360">v360</a> basiccommand as followings:<code>input:output:interp:w:h:in_stereo:out_stereo:yaw(pitch\roll):rorder:h_filp(v_flip\d_flip):ih_flip(iv_flip):in_trans:out_trans:h_offset(\v_offset):alpha_mask:reset_rot</code></p><p>and the corresponding parameters as followings:</p><p><code>dfisheye</code> = input format is dual fisheye video for<code>input</code>.</p><p><code>e</code> = 'Equirectangular projection' for <code>output</code>video format.</p><p><code>yaw</code> = rotation along yaw direction for output video.Values in degrees.</p><p><code>ih_fov</code> &amp; <code>iv_fov</code> = is outputhorizontal/vertical/diagonal field of view. Values in degrees.</p><p>there are no blending operation for the basic command code.</p><h4 id="references-3">References</h4><ul><li>More details at <a href="https://ffmpeg.org/ffmpeg-filters.html#v360">here</a></li><li>Basic pipeline from <a href="https://en.wikiversity.org/wiki/3D_Modelling/360_Degree_Video">wiki</a>(Recommand:+1::+1::+1:)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFMPEG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown初体验</title>
      <link href="/blogs/2020/02/29/Markdown%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/blogs/2020/02/29/Markdown%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><ul><li>本文结合<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a>与个人实践完成 （仅用于博主个人经验记录）<br>## Markdown语言介绍</li><li>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</li><li>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub等多种格式的文档。</li><li>Markdown 编写的文档后缀为 .md, .markdown。</li><li>可以编辑MarkDown的编辑器种类很丰富，如<a href="https://typora.io/">Typora</a>, <a href="https://notepad-plus-plus.org/downloads/">Notepad++</a>, <a href="https://code.visualstudio.com/">VSCode</a><br>笔者目前使用的是比较常用的 Notepad++ 配合 MarkDownViewer++插件进行编辑的。（博客导出为PDF有问题，存为HTML网页没问题，公式，图表功能不全）</li></ul><a id="more"></a><p>1、层次划分</p><ol type="1"><li>标题划分<br># "#"最少的标题字号最大<br>##<br>###<br>####<br>#####<br>###### 第7级就是普通字体了</li><li>小标题<ol type="1"><li>第一小点<br></li><li>第二小点<br></li><li>第三小点<br></li></ol><ul><li>"+"号也行<br>&gt; 再来一行<br></li></ul></li><li>整段缩进<br>&gt; 第一层<br>&gt;&gt; 第二层<br>&gt;&gt;&gt; 第三层<br></li><li>列表<br>- 第一行<br>- 第二行<br>* 第三行 *比-的行间距要大一些<br>2、插入图片<ul><li>插入本地图片<br><code>![name](url)</code>插入相对路径即可，但是想要作为博客上传到网络上时，就需要将对应的图片也上传，而且图片还不能太大，不然的话就会导致加载很慢而失败。</li><li>插入网络图片<br><code>![name2](url)</code> 直接跟着网络上的图片链接即可，如下：<br><code>![极地星光] (http://img0.dili360.com/ga/M01/02/D7/wKgBzFQ28e-AZ_M2AAHHuRnwnLQ779.jpg@!rw17)</code><img src="http://img0.dili360.com/ga/M01/02/D7/wKgBzFQ28e-AZ_M2AAHHuRnwnLQ779.jpg@!rw17" alt="极地星光"><br></li></ul></li></ol><ul><li>目前Markdown只能添加图片，若想调整图片大小，只能通过Html中标签的方式进行修改缩小一半并居中显示图片<code>&lt;div align=right&gt;&lt;img src="http://img0.dili360.com/ga/M01/01/FA/wKgBy1Q2wYGADMaxAAg9yYHclXE843.jpg@!rw17" width="50%" height="50%"&gt;&lt;/div&gt;</code><div data-align="center"><img src="http://img0.dili360.com/ga/M01/01/FA/wKgBy1Q2wYGADMaxAAg9yYHclXE843.jpg@!rw17" width="50%" height="50%"></div></li></ul><p>3、插入链接<br>- <code>[name](url)</code>，如: <a href="www.baidu.com">百度</a><br>- 或者直接写链接url也可以</p><p>4、插入代码片段<br>-用反引号(<code>)，也就是~在英文输入法下对应的那个键,包含单行代码   - 用反引号</code>``<code></code> 将代码包起来</p><p>5、首行缩进<br> &amp;enmsp;原生MarkDown不支持首行缩进,采用斜两个&amp;emsp;&amp;emsp;来解决.<br>6、 字体变化<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-strong">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-strong">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure> &gt;若要想文档更加绚烂点的话，就只能使用Html的格式来进行修改了<br>+ <font face="黑体">我是黑体字</font><br>+ <font face="微软雅黑">我是微软雅黑</font><br>+ <font face="STCAIYUN">我是华文彩云</font><br>+ <font color="red">我是红色</font><br>+ <font color="#008000">我是绿色</font><br>+ <font color="Blue">我是蓝色</font><br>+ <font size="5">我是尺寸</font><br>+<font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"黑体"</span>&gt;</span>我是黑体字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">red</span>&gt;</span>我是红色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">#008000</span>&gt;</span>我是绿色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">Blue</span>&gt;</span>我是蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span>我是尺寸<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"黑体"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">green</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span>我是黑体，绿色，尺寸为5<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7、添加短划线<br>~~删除文字~~<br>8、添加表格</p><div class="line-block">左对齐 | 右对齐 | 居中对齐 |<br>:- | -: | :- : |<br>单元格 | 单元格 | 单元格 |<br>单元格 | 单元格 | 单元格 |</div><p>9、公式&amp;图表<br>未探索，还需要进一步学习高级功能 <a href="https://www.runoob.com/markdown/md-advance.html">Markdown高级</a><br>- 公式<br>&gt;&gt; 需要使用额外latex &amp; tex，然后自动渲染<br>- 图表<br>&gt;&gt; notepad+=中这两个功能好像支持的不是很好，目前没有测试成功。</p>]]></content>
      
      
      <categories>
          
          <category> 写作工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker初体验</title>
      <link href="/blogs/2020/02/28/docker%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/blogs/2020/02/28/docker%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><p>泡泡机器人SLAM与你一同成长<font color="green">❤</font></p><h3 id="docker简介"><strong>Docker简介</strong></h3><p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。</p><p>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上，也可以实现虚拟化。</p><p>容器可以认为是一种虚拟环境，它完全使用沙箱机制，相互之间不会有任何接口（类似iPhone的app）,更重要的是容器性能开销极低。</p><p>(我认为是一种管理虚拟环境的引擎，方便快速构建任何虚拟环境，而各个环境之间不会相互影响，并且支持快速移植和部署。)<a id="more"></a></p><h3 id="和其他虚拟机软件之间的不同"><strong>和其他虚拟机软件之间的不同</strong></h3><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，可以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>与VirtualBox相比，<strong>VirtualBox虚拟化硬件，Docker虚拟化操作系统。</strong>两者<a href="http://dockone.io/article/258">比较</a>：</p><ol type="1"><li>VirtualBox，是创建硬件虚拟化的软件。</li></ol><blockquote><p>通常情况下，一个操作系统运行在硬件上，其中硬件和操作系统之间的通信是通过移动数据到内存地址，然后发出指令来通知可使用该数据的硬件（或者是数据在被读取时）。在VirtualBox（或其它虚拟机）设置的环境中，那些内存地址实际上是虚拟机软件自身的内存区域，并且那些指令是由虚拟机而不是直接由底层的CPU解释的。实际结果是，你在VirtualBox中运行一个操作系统，对于这个操作系统来说，VirtualBox程序看起来像一台完整计算机，硬件以及所有配件都有。实际上它不知道自己是在另一个程序中运行的。</p></blockquote><ol type="1"><li>Docker，则是不进行硬件的虚拟化。</li></ol><blockquote><p>Docker的作用是创建一个文件系统，使其看起来像一个普通的Linux文件系统，并且运行应用程序在一个所有文件和资源都在文件系统内的锁定环境中。事实上，该应用程序的容器并不模仿任何硬件，应用程序仍然在硬件上运行，它只是隔离了应用程序并允许开发人员可以运行该应用程序跟特定的并且完全不是主机操作系统的软件和第三方库合作。这意味着，在启动或停止Docker应用程序时几乎没有开销，因为它们不需要预先分配的内存和磁盘空间等等。因此Docker容器很容易设置或者拆除。此外，容器在加装需要系统中各种硬件组件上运行软件的时候并不浪费任何开销，因为它是基于系统内核，直接使用硬件的，不需要独立分配物理资源。多个容器共享内存，CPU等物理资源。</p></blockquote><h3 id="docker的一些优点"><strong>Docker的一些优点</strong></h3><h5 id="快速一致地交付应用程序">1、快速，一致地交付应用程序</h5><ul><li>Docker允许开发人员使用提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。容器非常适合持续集成和持续交付（CI/ CD）工作流程，请考虑以下示例方案：</li></ul><blockquote><p>开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</p><p>他们使用 Docker将其应用程序推送到测试环境中，并执行自动或手动测试。</p><p>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</p><p>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</p></blockquote><h5 id="响应式部署和扩展">2、响应式部署和扩展</h5><ul><li>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</li><li>Docker的可移植性和轻量级的特性，还可以使开发人员轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</li></ul><h5 id="在同一硬件上运行更多工作负载">3、在同一硬件上运行更多工作负载</h5><ul><li>Docker轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此可以利用更多的计算能力来实现业务目标。</li><li>Docker非常适合于高密度环境以及中小型部署，而开发人员可以用更少的资源做更多的事情。</li></ul><h3 id="docker的基本概念"><strong>Docker的基本概念</strong></h3><p>核心概念：镜像，容器</p><figure><img src="https://cdn.jsdelivr.net/gh/whu-lyh/images//img/Docker_images_container.png" alt="Docker_images_container"><figcaption aria-hidden="true">Docker_images_container</figcaption></figure><h4 id="docker安装以win10安装为例linux详见另一个博客">Docker安装/(以Win10安装为例，Linux详见另一个博客)</h4><p>Docker <a href="https://www.docker.com">官网</a>，Github Docker <a href="https://github.com/docker/docker-ce">源码</a></p><h5 id="docker-desktop下载">1. Docker-Desktop下载</h5><p>打开 DockerHub 直接下载 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">docker-desktop</a>安装包即可。下载完成会得到<font color="blue"><strong>"Docker DesktopInstaller.exe"</strong></font>软件，选个合适的路径，一路Next安装即可。</p><ul><li>Win7 或Win8 需要借助 <a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/">dockertoolbox</a> 完成安装。<br></li><li>Win10需要开启Hyper-V功能，开启位置位于：Win10左下角第一个图标右键单击-&gt;应用和功能-&gt;启用或关闭Windows功能，从中找到Hyper-V选中即可。</li></ul><p>安装完成之后会在Windows的图标中出现一个小鲸鱼的图标。</p><h5 id="安装测试">2. 安装测试</h5><p>可以右键单击Docker图标进行一些个性化调整。为了加速软件和镜像的下载速度，最好将Docker镜像源为阿里云或中科大源，不然下载速度会很慢。如下：</p><p><img src="/blogs/.io//setting.jpg"></p><h4 id="docker基础命令">Docker基础命令</h4><p>安装完之后，在系统任何位置打开控制台或bash命令行（终端均可运行docker命令）</p><ul><li><code>docker --version</code></li></ul><p>查看docker的版本。</p><ul><li><code>docker</code></li></ul><p>即可列出Docker客户端的所有命令行选项，当想要查找某一命令时非常方便。</p><ul><li><code>docker search</code></li></ul><p>如：<code>docker search ubuntu</code> 在DockerHub中搜索名为ubuntu的镜像。</p><ul><li><code>docker pull DockerHubID/imageName</code></li></ul><p>如：<code>docker pull ubuntu</code> 。若当前DockerHub账户中没有该名称的镜像，则会自动从DockerHub公共仓库中下载并拉取到本地。因此这个名字需要注意，不然很容易就下载错了或下载成别人的开源镜像了。另外还可以指定不同标签版本的镜像：<code>docker pull ubuntu:18.04</code>，即可拉取18.04的ubuntu。</p><ul><li><code>docker images</code></li></ul><p>列出本地主机的全部镜像。</p><ul><li><code>docker ps</code></li></ul><p>将全部的容器列出来，添加<code>-a</code>命令可以显示全部容器，不加<code>-a</code>仅列正在运行的容器，未运行或退出的容器将不会被列出来。<strong>ps=processstatus</strong>。</p><ul><li><code>docker run imageName</code></li></ul><p>运行imageName这个镜像，得到一个容器。如：<code>docker run -it ubuntu /bin/bash</code>，<code>-i</code>表示交互式操作，<code>-t</code>表示终端，ubuntu为镜像名称，放在镜像名后的是命令，这里我们希望有个交互式Shell，因此用的是<code>/bin/bash</code>。若想在后台运行Docker服务，则需要通过<code>-d</code>指定容器的运行方式。如：<code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code>，另外可以通过：<code>docker run -t -i ubuntu:18.04 /bin/bash</code>，可以运行不同tag标签的镜像。</p><ul><li><code>docker exec containerId</code></li></ul><p>进入Docker容器，这里指进入后台运行的容器，<strong>如果从这个容器退出，不会导致容器的停止</strong>。如：<code>docker exec -it id /bin/bash</code></p><ul><li><code>docker attach containerId</code></li></ul><p>同为进入已经开启的容器中，如果从这个容器退出，会导致容器的停止。</p><ul><li><code>exit</code></li></ul><p>接在控制台输入exit即可退出当前镜像。</p><ul><li><code>docker stop containerId</code></li></ul><p>停止容器。</p><ul><li><code>docker start/restart containerId</code></li></ul><p>通过容器id开启或重启容器。</p><ul><li><code>docker rm containerId</code></li></ul><p>删除容器，这个操作需要十分小心，因为是不可逆的操作，比如你在容器中写的代码，文档将会全部丢失。</p><ul><li><code>docker rmi imageName</code></li></ul><p>删除镜像，需要注意的是再删除镜像的时候需要将正在运行的容器先删除掉。</p><ul><li><code>docker container prune</code></li></ul><p>清理掉所有处于终止状态的容器。</p><ul><li><code>docker top containerId</code></li></ul><p>使用docker top来查看容器内部运行的进程。一般用不到。</p><ul><li><code>docker login/logout</code></li></ul><p>登入登出Docker Hub账号，这样就可以下载自己仓库中的镜像了。</p><h3 id="注意事项"><strong>注意事项</strong></h3><p>安装软件时最好提前将ubuntu的软件源换为国内镜像，不然速度慢到你难以想象，这里在安装好后已经及时对软件源进行了更新。</p><h3 id="参考教程"><strong>参考教程</strong></h3><ol type="1"><li><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo初体验</title>
      <link href="/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p><font color="red"><strong>Hexo</strong></font>本身是一个<strong>静态博客</strong>生成工具，具备编译Markdown、拼接主题模板、生成 HTML、上传 Git 或 FTP等基本功能。本博客将不会介绍git实用技巧而是着重于介绍在Windows上hexo的搭建及测试过程</p><h3 id="node.js-安装">1、Node.js 安装</h3><p>首先搭建hexo个人博客网站需要电脑中有Node.js环境，而Node.js即使是一个没有写过前端界面的人也可以完全傻瓜式安装完成的。参照官网下载对应版本<a href="https://nodejs.org/en/download/"><strong>Node.js</strong></a>。</p><a id="more"></a><p><img src="/blogs/.io//Nodejs.png">另外如果你想要进一步学习Node.js这个强大的服务器端的JavaScript绚丽技术以及体验高性能服务配置技术，请移步<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html"><strong>这里</strong></a>,一路Next安装即可。最后在控制台或bash命令行上输入：<code>node --version(或node -v)</code>，以查看Node.js版本来验证否配置完成。</p><p><img src="/blogs/.io//Nodejs2.png"></p><p>npm的install或者uninstall需要在安装Nodejs的目录下才能行，需要有package.json存在。</p><p>如果是在新电脑上安装之前的环境，直接npminstall就能根据打包好的包的名字进行安装。<code>npm install</code>即可。</p><h3 id="hexo安装">2、Hexo安装</h3><p>在安装Node.js的时候一般来说会自动安装一个叫做npm的软件安装程序，功能类似于python中的pip以及linux下的apt-get。然后通过在本地路径打开命令行或gitbash命令行，并输入：<code>npm install hexo-cli -g</code>，CLI = CommandLine Interface为命令行界面。</p><h4 id="hexo初始化">2.1 Hexo初始化</h4><p>在本地找个合适的位置新建一个文件夹，作为Hexo博客存放的位置，这里名为NotesRecording，并在此文件夹下打开控制台或bash命令行，并输入:<code>hexo init NotesRecording</code>，然后输入:<code>hexo --version</code>即可查看Hexo版本，如下: (这里采用了 <a href="https://github.com/ppoffice/hexo-theme-icarus"><strong>icarus</strong></a>主题，因此和你现在能看到的可能有所出入。)</p><p><img src="/blogs/.io//hexo-v.jpg"></p><p>在控制台或bash命令行输入：<code>npm install</code>，指定文件夹目录下有：<img src="/blogs/.io//notesrecording.jpg" alt="notesrecording"></p><blockquote><p>node_modules: Hexo的依赖包，和插件</p><p>public：存放生成的页面,这些index.html都是要上传到服务器端的</p><p>scaffolds：生成文章的一些模板</p><p>source：用来存放编辑好的文章</p><p>source/_post：用来存放正式发布的文章</p><p>themes：存放喜欢的主题，比如本文的 <a href="https://github.com/ppoffice/hexo-theme-icarus"><strong>icarus</strong></a></p><p>_config.yml: Hexo博客的配置文件</p></blockquote><p>接着再运行：<code>hexo server</code>，等待几秒之后，通过按照提示在本地浏览器打开 http://localhost:4000/网址，即可预览初始化好的Hexo博客界面。</p><h4 id="hexo配置以及主题修改">2.2 Hexo配置以及主题修改</h4><ul><li>修改为中文：如 : language: zh-CN</li><li>修改Hexo的主题，可以从 <a href="https://hexo.io/themes/"><strong>官方主题</strong></a>处寻找并下载。然后放置在themes路径下并在_config.yml配置文件中设置：</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">theme</span>: <span class="hljs-function"><span class="hljs-title">icarus</span>(这里以<span class="hljs-variable">icarus</span>为例)</span><br></code></pre></td></tr></table></figure><ul><li>设置Hexo关联git仓库，设置好关联的Git账号之后，就可以将每次写好的博客以及对Hexo的配置进行保存，方便后续进行回顾和修改。需要先安装hexo关联的git，命令如下：<code>npm install hexo-deployer-git --save</code>，在_config.yml文件中找到如下对应的地方，并修改:</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>    <span class="hljs-attribute">type</span>: git    <br>    <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/yourGitName/yourGitName.github.io.git    </span><br>    <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><p>配置好之后在控制台或者bash命令行中输入：<code>Hexo -g -d</code>，按照新的修改生成博客。+ 修改icarus配置文件，详见<a href="https://blog.csdn.net/marvine/article/details/89816846">飞鱼的博客</a>+在写博客时难免会有一些图片需要添加，Hexo在添加本地图片时需要修改两个地方：</p><blockquote><p>找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true。安装一个Hexo的插件<code>npm install hexo-asset-image --save</code>即可。将图片放入这个文件夹，然后引用</p></blockquote><h3 id="环境配置好后就可以开始写博客啦">3、环境配置好后就可以开始写博客啦</h3><h4 id="首先创建一个新的博客">3.1 首先创建一个新的博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><ul><li>本地文件夹中会出现一个名为“My NewPost.md”的文档，如果在上述Hexo配置过程中开启了本地图片加载功能,则还会生成一个同名的文件夹，用来存放在.md文档中要上传的照片；</li><li>另外使用命令还会自动在md文档中生成一些头文件，包含<strong>属性</strong>信息，如下，可以更好地帮助构建Hexo界面上的文档显示。新建文档时手动就该就行，自定义文件头的位置位于：/scaffolds/post.md`。如果是直接新建md文件，则只能手动拷贝一个合适的头文件到新建文档的最前面，就能正常显示了。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">postName</span> <span class="hljs-comment">#文章页面上的显示名称，一般是中文</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">23</span><span class="hljs-string">:38:32</span> <span class="hljs-comment">#文章生成时间</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">默认分类</span> <span class="hljs-comment">#分类</span><br><span class="hljs-attr">tags:</span> <span class="hljs-string">[tag1,tag2,tag3]</span> <span class="hljs-comment">#文章标签，可空，多标签请用格式=</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h4 id="博客预览">3.2 博客预览</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server (hexo -s)<br></code></pre></td></tr></table></figure><p>通过在浏览器中打开 http://localhost:4000/ ,即可预览到刚刚创建好的博客内容，如有问题，可立马修改。</p><p>使用<code>-p</code>可以修改端口号。</p><h4 id="生成hexo文档">3.3 生成Hexo文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate (hexo -g)<br></code></pre></td></tr></table></figure><h4 id="部署到远程服务器上">3.4 部署到远程服务器上</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy (hexo -d)<br></code></pre></td></tr></table></figure><ul><li>打开对应的gitname.github.io即可查看博客啦。</li></ul><h3 id="注意事项">4、注意事项</h3><ul><li>Hexo每次deploy，generate之后会加原来的文档资料全部覆盖掉，因此为了便于找回之前的内容，方便进行版本管理。建议使用github进行文档和操作同步，即在本地博客目录下同时初始化一个git仓库，每次更新完博客之后，随手进行仓库的同步更新，这样的话，将会极大地方便后续博客管理。<br></li><li>当你将写好的MarkDown文章推送到Hexo的时候，会发现Hexo默认显示了全部的文档内容，这对于博客内容比较多的人来说，显然是不合适的，因此有一个解决方案是：采用Html的语法，在合适的地方添加，当然也可以在hexo中设置<code>&lt;!--more--&gt;</code> 。</li><li>在generate之前最好再清理一下本地缓存，以免由于缓存更新延迟造成“误会”，<code>hexo clean</code>。</li><li>如果出现下面的问题(在12.16.1版本上出现的非常频繁)，那么需要找到Nodejs的安装包，点击repair才能解决。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">internal/modules/cjs/loader.js:985<br>  throw err;<br>  ^<br><br>Error: Cannot find module <span class="hljs-string">'D:\SoftWare\Nodejs\node_modules\npm\bin\npm-cli.js'</span><br>    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:982:15)<br>    at Function.Module._load (internal/modules/cjs/loader.js:864:27)<br>    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)<br>    at internal/main/run_main_module.js:18:47 &#123;<br>  code: <span class="hljs-string">'MODULE_NOT_FOUND'</span>,<br>  requireStack: []<br>&#125;<br>internal/modules/cjs/loader.js:985<br>  throw err;<br>  ^<br><br>Error: Cannot find module <span class="hljs-string">'D:\SoftWare\Nodejs\node_modules\npm\bin\npm-cli.js'</span><br>[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:982:15)[39m<br>[90m    at Function.Module._load (internal/modules/cjs/loader.js:864:27)[39m<br>[90m    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)[39m<br>[90m    at internal/main/run_main_module.js:18:47[39m &#123;<br>  code: [32m<span class="hljs-string">'MODULE_NOT_FOUND'</span>[39m,<br>  requireStack: []<br></code></pre></td></tr></table></figure><h3 id="问题记录">5、问题记录</h3><p>我个人常用的工作流是本地用Typora写好博客，然后用hexo部署到网页端。</p><h4 id="markdown冲突">5.1 Markdown冲突</h4><ol type="1"><li>Typora在写博客时可以手动添加目录，使用<code>[TOC]</code>，为了在hexo发布的时候页面也能显示目录，需要在.md文件的头部添加<code>toc: true</code>的标注。但是经过hexo发布之后，目录无法显示，目前考虑是一个不兼容的问题。如果想在发布的时候自动显示就不要手动添加[TOC]标记了。</li><li>Typora中的<span class="math inline">\(\LaTeX\)</span>代码公式渲染出来非常漂亮，但是经过hexo发布之后公式就出现了排版错误的情况。</li></ol><ul><li>要么是$$符号无法识别，要么是渲染出来和本地渲染结果不一样。由于我的hexo+icarus的版本比较老了，目前一些比较新的解决方案均无法实现，找了好久，试了很多都不行，最后找到一个适用于我的解决方案：主要问题应该就是渲染的问题，<span class="math inline">\(\LaTeX\)</span>代码写的应该没问题。首先<code>npm uninstall</code>卸载掉和math相关的所有库，e.g.hexo-math、hexo-filter-mathjax等，然后和官方的<a href="https://github.com/ppoffice/hexo-theme-icarus/blob/master/package.json">hexo-theme-icarus</a>比较，看看少了哪些dependencies，e.g.hexo-renderer-marked、hexo-renderer-stylus、hexo-renderer-inferno等。<a href="https://github.com/jgm/pandoc/releases">pandoc</a>需要独立安装。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-marked --save <span class="hljs-comment"># 原来icarus就是使用的marked作为渲染的</span><br><span class="hljs-comment"># 上面的可以不用卸载，卸载了会发现hexo也没了，直接装hexo-renderer-pandoc就行。</span><br>npm install hexo-renderer-pandoc --save <span class="hljs-comment"># latex公式渲染之后，变得很奇怪，使用pandoc之后就和本地的一样了。但是得先装一个pandoc。</span><br><span class="hljs-comment"># 下面的会自动安装上</span><br>npm install hexo-renderer-ejs --save<br>npm install hexo-renderer-stylus --save<br>npm install hexo-renderer-inferno --save<br></code></pre></td></tr></table></figure><ul><li>最后得到package.json如下：（让然也可能有一些没用的dependencies）吓得我赶紧保存下来。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Json">&#123;<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"hexo-related"</span>,<br>    <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,<br>    <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>,<br>    <span class="hljs-attr">"dependencies"</span>: &#123;<br>        <span class="hljs-attr">"hexo-renderer-ejs"</span>: <span class="hljs-string">"^2.0.0"</span>,<br>        <span class="hljs-attr">"hexo-renderer-inferno"</span>: <span class="hljs-string">"^0.1.3"</span>,<br>        <span class="hljs-attr">"hexo-renderer-marked"</span>: <span class="hljs-string">"^6.0.0"</span>,<br>        <span class="hljs-attr">"hexo-renderer-pandoc"</span>: <span class="hljs-string">"^0.3.1"</span>,<br>        <span class="hljs-attr">"hexo-renderer-stylus"</span>: <span class="hljs-string">"^2.1.0"</span><br>    &#125;,<br>    <span class="hljs-attr">"devDependencies"</span>: &#123;&#125;,<br>        <span class="hljs-attr">"scripts"</span>: &#123;<br>        <span class="hljs-attr">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br>    &#125;,<br>    <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>Typora中使用markdown的语法进行脚注标记是正常的，但是hexo发布之后无法正常渲染。这个是hexo的问题，不是icarus主题的问题，有人曾说<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/572#issuecomment-565253447">换用hexo-renderer-markdown-it</a>可以解决，但是我尝试了，没用。但其实有用的是hexo-footnotes这个插件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-markdown-it --save <span class="hljs-comment">#没用</span><br>npm install hexo-footnotes --save <span class="hljs-comment">#有用</span><br></code></pre></td></tr></table></figure><ul><li>一些关于markdown-it的<a href="https://blog.bugimg.com/works/hexo-renderer-markdown-it_and_plugins_config.html">插件解释</a>。一顿操作之后的package.json文件。依然没反应。hexo-footnotes已经不再维护了。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"hexo-related"</span>,<br>    <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,<br>    <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>,<br>    <span class="hljs-attr">"dependencies"</span>: &#123;<br>        <span class="hljs-attr">"hexo-renderer-ejs"</span>: <span class="hljs-string">"^2.0.0"</span>,<br>        <span class="hljs-attr">"hexo-renderer-inferno"</span>: <span class="hljs-string">"^0.1.3"</span>,<br>        <span class="hljs-attr">"hexo-renderer-markdown-it"</span>: <span class="hljs-string">"^6.1.0"</span>,<br>        <span class="hljs-attr">"hexo-renderer-pandoc"</span>: <span class="hljs-string">"^0.3.1"</span>,<br>        <span class="hljs-attr">"hexo-renderer-stylus"</span>: <span class="hljs-string">"^2.1.0"</span>,<br>        <span class="hljs-attr">"markdown-it-cjk-breaks"</span>: <span class="hljs-string">"^1.1.3"</span>,<br>        <span class="hljs-attr">"markdown-it-footnote"</span>: <span class="hljs-string">"^3.0.3"</span>,<br>        <span class="hljs-attr">"markdown-it-task-lists"</span>: <span class="hljs-string">"^2.1.1"</span><br>    &#125;,<br>    <span class="hljs-attr">"devDependencies"</span>: &#123;&#125;,<br>        <span class="hljs-attr">"scripts"</span>: &#123;<br>        <span class="hljs-attr">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br>    &#125;,<br>    <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>Typora中插入公式、图表等markdown语法都没什么问题，但是hexo部署完之后就发现各种缩进问题，可能是因为空行导致的，因此如果发现有缩进错误，就尝试增加一个空行，可以解决问题。</li></ol><h4 id="图片渲染不兼容">5.2 图片渲染不兼容</h4><h5 id="问题">问题</h5><p>本地Typora写的博客，使用到hexo部署之后，其中的图片不能正确的显示。</p><p>Typora中使用<code>![image name](image relative path)</code>或者是使用html的语法<code>&lt;div align=center&gt;&lt;img src="image relative path" width="100%" height="100%"&gt;&lt;/div&gt;</code>都可以加载图片，其中使用后者的原因是可以控制图片的位置和大小，排版出来比较美观。</p><blockquote><p>后来喜欢用github的图床实现图片保存，但是后面发现图片数量增加时，图片保存的时候，名字不好取，而且非常不好管理，容易出现冲突，因此后面是否继续使用，打个问号。</p></blockquote><p>但是hexo部署之后，网页端就打不开了，本地预览也不行。</p><blockquote><p>hexo部署带有图床链接的图片时，也会自动重新拷贝一份图像到新的文件夹下，并不会直接使用图床链接。图片依旧加载不出来。</p></blockquote><h5 id="分析原因">分析原因</h5><p>使用的hexo-asset-image插件有问题（这个插件会给<a href="http://disq.us/p/2il5c89">添加的图片一个错误的前缀</a>，导致无法正确链接，只支持版本较低的hexo，e.g.3.0，而我使用的是4.2.+，目前hexo-asset-image这个库已经暂停维护了）。有<a href="https://github.com/yiyungent/hexo-asset-img">解决方案</a>称，应该使用这个插件hexo-asset-img，于是按照要求首先使用<code>npm uninstall hexo-asset-image</code>卸载之前的插件，然后使用<code>npm install hexo-asset-img</code>安装新的插件。但是发现图片依然加载失败，后面发现是在插入图片时，原先使用的都是添加了<code>./</code>最为前缀的，这里完全不需要，直接写文件夹名字加图片名，比如：<code>![](./Hexo初体验/Nodejs.png)</code>，按照正常的流程清空-生成-部署，之后图片就正常显示了。<strong>But</strong>，如果typora中使用html的方式引入图片，一开始的命令是<code>&lt;div align=center&gt;&lt;img src="./Bspline/viz_basis_function.svg" width="100%" height="100%"&gt;&lt;/div&gt;</code>但是这样只能在typora中看到，hexo部署之后就看不到了.使用<code>&lt;div align=center&gt;&lt;img src="viz_basis_function.svg" width="100%" height="100%"&gt;&lt;/div&gt;</code>之后，typora中看不到，但是hexo部署之后可以。对于排版有一定要求的我，并不满意这样的解决方案。</p><h5 id="定位问题">定位问题</h5><p>通过检查几种可能得解决方案后发现，主要是这些插件在生成图片链接的时候多多少少有点问题，问题如下所示。发现一个和我相同问题的<a href="https://zhuanlan.zhihu.com/p/645679541">老哥</a>， 尝试了一下，他的解决方案并不能解决我的问题，于是我开始小改了一下hexo-asset-image的代码。</p><blockquote><p>可以发现，使用旧的插件部署之后，图片链接变成了<code>http://localhost:4000/blogs/2023/03/06/B-Spline/viz_basis_function.svg</code>，</p><p>而使用新的插件部署之后，在路径上自动添加了一个前缀<code>http://localhost:4000/blogs/2023/03/06/B-Spline/B-Spline/viz_basis_function.svg</code></p></blockquote><h5 id="解决方案">解决方案</h5><p>可以重新仿照hexo-asset-image写一个插件，也可以直接hack掉他的源码，修改一下对应的路径。使用方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重新用回不维护的插件</span><br>npm install hexo-asset-image<br></code></pre></td></tr></table></figure><p>在_modules-asset-image找到index.js这个文件，将里面的东西换成下面的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">'use strict'</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cheerio'</span>);<br>     <br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br>     <br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">'.'</span>);<br>hexo.extend.filter.register(<span class="hljs-string">'after_post_render'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>       <span class="hljs-keyword">var</span> link = data.permalink;<br>   <span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>      <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><br>   <span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br>     <br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">'excerpt'</span>, <span class="hljs-string">'more'</span>, <span class="hljs-string">'content'</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br>      <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        ignoreWhitespace: <span class="hljs-literal">false</span>,<br>        xmlMode: <span class="hljs-literal">false</span>,<br>        lowerCaseTags: <span class="hljs-literal">false</span>,<br>        decodeEntities: <span class="hljs-literal">false</span><br>      &#125;);<br>     <br>      $(<span class="hljs-string">'img'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">if</span> ($(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>))&#123;<br>           <span class="hljs-comment">// For windows style path, we replace '\' to '/'.</span><br>           <span class="hljs-keyword">var</span> src = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>).replace(<span class="hljs-string">'\\'</span>, <span class="hljs-string">'/'</span>);<br>           <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>              !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>             <span class="hljs-comment">// For "about" page, the first part of "src" can't be removed.</span><br>             <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>             <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>               <span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span>;<br>             &#125;);<br>             <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>               <span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span> &amp;&amp; elem != <span class="hljs-string">'.'</span>;<br>             &#125;);<br>             <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>               srcArray.shift();<br>             src = srcArray.join(<span class="hljs-string">'/'</span>);<br>             $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>, src);<br>             <span class="hljs-comment">//$(this).attr('src', config.root + link + src);</span><br>             <span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+config.root);</span><br>             <span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+link);</span><br>             <span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+src);</span><br>             <span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src);</span><br>             <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"update link as:--&gt;"</span> + link + src);<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"no src attr, skipped..."</span>);<br>           <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-keyword">this</span>));<br>       &#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>特别是第50行左右的地方：注释掉的就是之前的出问题的地方。（其他问题可同理解决。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>, src);<br><span class="hljs-comment">//$(this).attr('src', config.root + link + src);// 产生问题的地方</span><br><span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+config.root);</span><br><span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+link);</span><br><span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+src);</span><br><span class="hljs-comment">//console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); // 产生问题的地方</span><br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"update link as:--&gt;"</span> + link + src);<br></code></pre></td></tr></table></figure><p>But，突然发现这样之后再Hexo本地预览的时候，没法正常显示照片，就想着能否不用Html来居中图像，就发现了<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/386">魔改icarus的模板</a>的方案，需要在icarus的主体路径下.styl文件，在187行附近添加如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">.article<br>    .article-meta<br>        margin-bottom: <span class="hljs-number">0.5</span>rem !important<br>    .content<br>        font-size: <span class="hljs-number">1.1</span>rem<br>        blockquote.pullquote<br>            float: right<br>            max-width: <span class="hljs-number">50</span>%<br>            font-size: <span class="hljs-number">1.15</span>rem<br>            position: relative<br>        a<br>            word-wrap: <span class="hljs-keyword">break</span>-word<br>            img # 图像居中<br>                margin: auto # 图像居中<br>                display: block # 图像居中<br></code></pre></td></tr></table></figure><p>然后icarus默认的设置全部图像都自动居中刻，一些简单的图片不需要html也可以实现居中，复杂彩涉及到html语言了。</p><h4 id="其他">5.3 其他</h4><ol type="1"><li>hexo中设置<strong>related_posts</strong>似乎在生成时有问题，但是不影响部署。（换了一台电脑，问题消失了）</li><li>每个博客添加一个缩略图（和文章题目一起显示的那个）。这个属于主题的范畴与hexo无关了，icarus默认使用的事thumbnail.svg这个图像做的缩略图。我手动换成了其他的格式。如果有不一样的就手动设置就行。</li></ol><p>在每个md文档的前面，有些属性可以设置。其中：</p><blockquote><p>当只设置 banner 时，文章的缩略图 和 banner 将都是 banner所设置的图片； 当只设置 thumbnail 时， 文章只有缩略图，无banner；当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail为缩略图， 两者各自生效；</p></blockquote><p>例如这里就是：<code>banner:/(article_year)/(article_month)/(article_day)/(article_name)/xxx.png</code></p><p>这里有点难受的就是，参考了<a href="https://blog.maodai.site/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/">这里</a>的方法，在hexo部署的时候报了一个错误，而我又没解决，因此就放弃了。</p><blockquote><p>缩略图没有显示的主要原因还是因为图片的链接错了，需要检查几个地方：</p><ol type="1"><li>在hexo本地预览时，F12打开源码，找到一个没正常显示图像的位置，比如这里：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"media"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"media-left"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"image is-64x64"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/hexo-logo.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Hexo初体验"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"media-content"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"has-text-grey is-size-7 is-uppercase"</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">"2020-02-22T07:38:32.000Z"</span>&gt;</span>2020-02-22<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title has-link-black-ter is-size-6 has-text-weight-normal"</span>&gt;</span>Hexo初体验<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以发现图片的路径是<code>/blogs/2020/02/22/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/Nodejs.png</code>的格式，即部署时会自动转换成这个路径，那么我们需要做的就是在每个博客的开头设定<code>/blogs</code>之后的路径即可，比如本文就是<code>thumbnail: /2020/02/22/Hexo初体验/hexo-logo.png</code>，还要注意冒号后有一个空格。</p><ol start="2" type="1"><li>对照上面的检查thumbnail的路径，一定写对，大概率缩略图就能显示了。</li></ol></blockquote><ol start="3" type="1"><li>站内搜索，而不是直接联网搜索。</li></ol><ul><li><p>首先在主题的_config.yaml文件中找到search，设置<code>use: local</code>，icarus主题大约位于73行左右。</p></li><li><p>然后在博客的_config.yaml文件中添加如下，文件结尾处即可：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># search inside blogs</span><br><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p>出现一个错误，导致无法部署成功，原来是_config.yml中的一个时间设置的不对，原来不知道为什么是beijing，改成<code>timezone: 'Asia/Shanghai'</code>就好了，<a href="https://www.cnblogs.com/mmzuo-798/p/10510225.html">详见</a>。</p></li><li><p>部署时出现错误<code>WARN No layout: index.html</code></p></li></ol><p>解决方案：主题一定要选对，并且安装对，如果安装过程中提示错误，那就按照对应的说明安装相应的依赖库就行。</p><ol start="6" type="1"><li>执行<code>hexo -g</code>时出错，错误为pandoc exited with codenull</li></ol><p>解决方案：安装<a href="https://github.com/jgm/pandoc/releases">pandoc</a>就行。参考这里。</p><h4 id="换台工作电脑">5.4 换台工作电脑</h4><p>工作一台，家里一台，随时想写博客怎么办？只需要按照前面的步骤安装npm，pandoc，同步修改对应的插件（很重要），把日志克隆下来，开始写，写完部署，然后把本地的仓库使用git同步更新即可。</p><h3 id="参考博客">6、参考博客</h3><ol type="1"><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学</a><br></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">fangzh的个人博客</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/">韦阳的博客</a></li><li><a href="https://annewqx.top/posts/65512/?nsukey=Ky9s%2BVwfoeIxBfNyS7TyLGKo9BSPWmG6AcQbnEXL9BKoN4AKFRf84H5Xc%2FwkRFTUp6m9SC80E5J2F4MCLvtqRpVFM37o0K1pYKV4pxKWvtT5AeqIbzUZcf5V4qiu58kzzz6PNTha2oG8w2EMgAMhXGEQTNAri4fGuaDM1KLMFQMtpljAfJ0m2uaL2P8ZNNDhLcmSl1SwyAP7RmTi2imwlg%3D%3D#功能">ICARUS美化</a></li><li>图片渲染不兼容的<a href="https://blog.csdn.net/qq_42009500/article/details/118788129">可能解决方案1：改源码</a></li><li>图片渲染不兼容的<a href="https://github.com/iotctech/hexo-asset-image">可能解决方案2：改源码</a></li><li>站内搜索源于<a href="http://tanglab.pku.edu.cn/2022/11/24/R&amp;D/2022/GitHub_pages_tutorial_sequel/">这里</a></li><li>博客缩略图的<a href="https://zhangjichengcc.github.io/blog/2018/02/27/hexo-%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0/">设置</a>，以及<a href="https://blog.maodai.site/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/">这里</a>，icarus官方issue中<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/344">使用缩略图的讨论</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 写作工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
